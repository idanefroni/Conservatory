#!/usr/bin/perl

use POSIX;
use strict;
use Cwd 'abs_path';
use List::Util qw(min max);
use Bio::AlignIO;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;

print STDERR "\nUsage: buildCNSTables referenceGenome cnsFile mapFile\n\nAccepts CNS and alignment map files and output generate two files:\n\n";
print STDERR "\t\t[referenceGenome].cns.table.csv\t\tFiltered and merged CNS file\n\t\t[referenceGenome].cns.position.table.csv\t\tThe position of the CNS in each genomes\n";

if(scalar @ARGV< 3) {
	die "\n\nERROR: No CNS and map file provided.\n";
}

open (my $CNSInputFile,"sort -t',' -k1,1 -k3,3 -k4,4n $ARGV[1] |") ||  die "ERROR: Cannot find CNS file $ARGV[1].\n";


my %CNSDB;
my $CNSCounter=1;
my @CNSList;
my %targetSpecies;
my %targetSpeciesPerLocus;

$| = 1;

######## Read the mapping file into memory
#### Now add the positions from the mapping file and index it
my %mappings;

print localtime() . ": Reading mapping file...";
open (my $mapInputFile, $ARGV[2]) ||  die "ERROR: Cannot find map file $ARGV[2].\n";
while(<$mapInputFile>) {
	chomp;
	my ($locus, $startRefRel, $length, $targetGenome,$targetLocus, $targetStartRel) = split /\t/;
	push (@ { $mappings{$locus} }, {
		'Locus' => $locus,
		'StartRefRel' => $startRefRel,
		'Length' => $length,
		'TargetGenome' => $targetGenome,
		'TargetLocus' => $targetLocus,
		'TargetStartRel' => $targetStartRel	
	});
	$targetSpecies{$targetGenome} = 1;
	$targetSpeciesPerLocus{$locus}{$targetGenome} = 1;

}

close($mapInputFile);
print "\n" . localtime() . ": Done.";

## A CNS Object has the following fields: Name, Chromosome, Start, End, ORFCheck, TECheck, ConservationLevel, PositionVariability
##     

# First pass. Generate the CNS databse while merging overlapping CNS and marking TE
my $previousCNS = "";
print "\n" . localtime() . ": Collecting and merging CNS...";
while(<$CNSInputFile>) {
	my $overlapCNS = "";
	my $overlapTE;
	my $doneWithTE=0;
	my $startlog=0;
	
	chomp;
	my ($locus, $startRel, $endRel, $pval,$upordown, $chromosome, $start, $end, $orf) = split /,/;
	### Check for overlaps 
	if($previousCNS ne "") {
		if($CNSDB{$previousCNS}{'Chromosome'} == $chromosome && overlap($start, $end, $CNSDB{$previousCNS}{'Start'},$CNSDB{$previousCNS}{'End'})) {
			$overlapCNS = $previousCNS;
		}
	}
	
	if($overlapCNS eq "") {
		my $newCNSName = "CNS_" . $referenceGenome . "_$CNSCounter";
		$CNSDB{$newCNSName} = {
			'Name' => $newCNSName, 
			'Chromosome' => $chromosome,
			'Start' => $start,
			'End' => $end,
			'ORFCheck' => $orf,
			'TECheck' => $overlapTE,
			'Position' => ()};
		$previousCNS = $newCNSName;
		
		push @CNSList, $newCNSName;
			
		$CNSCounter++;
	} else {
		## Merge the CNS.
		$CNSDB{$overlapCNS}{'Start'} = min($start, $CNSDB{$overlapCNS}{'Start'});
		$CNSDB{$overlapCNS}{'End'} = max($end, $CNSDB{$overlapCNS}{'End'});
		if($overlapTE eq "1") {
			$CNSDB{$overlapCNS}{'TECheck'} = "1";
		}
		if($orf eq "1") {
			$CNSDB{$overlapCNS}{'ORFCheck'} = "1";
		}
		push @CNSList, $overlapCNS;
		
		$previousCNS = $overlapCNS;
	}
	if($CNSCounter % 10000 == 0 ) { print "."; }
}
print "\n" . localtime() . ": Collected " . scalar %CNSDB . " CNSs.\n";
close($CNSInputFile);

print localtime() . ": Collect positions of CNS from reference and target genomes...\n";

open ($CNSInputFile,"sort -t',' -k6,6 -k7,7n $ARGV[1] |") ||  die "ERROR: Cannot find CNS file $ARGV[1].\n";
my $CNSLineCounter =0;

while(<$CNSInputFile>) {
	chomp;
	my ($locus, $startRel, $endRel, $pval,$upordown, $chromosome, $start, $end, $orf) = split /,/;
	my $relatedCNSName = $CNSList[$CNSLineCounter];
	push (@{ $CNSDB{$relatedCNSName}{'Position'} }, {
		'Genome' => $referenceGenome,
		'RefLocus' => "$referenceSpecies-$referenceGenome-$locus",
		'TargetLocus' => "$referenceSpecies-$referenceGenome-$locus",
		'StartRel' => $startRel,
		'phyloPval' => $pval,
		'UpDown' => $upordown});
	
	### There is a minimum overlap of 10bp between mapping and CNS to count as overlapping - to remove dubious alignments
	my @targetPositions = @{ $mappings{$locus} };
	foreach my $curTargetPos (@{ targetPositions}) {
#		if(overlap($startRel, $endRel,  $curTargetPos->{'StartRefRel'},  $curTargetPos->{'StartRefRel'} +  $curTargetPos->{'Length'},"ABS")>=6) {
		if(overlap($startRel, $endRel,  $curTargetPos->{'StartRefRel'},  $curTargetPos->{'StartRefRel'} +  $curTargetPos->{'Length'})>=0.5) {
			push (@{ $CNSDB{$relatedCNSName}{'Position'} }, {
				'Genome' => $curTargetPos->{'TargetGenome'},
				'RefLocus' => "$referenceSpecies-$referenceGenome-$locus",
				'TargetLocus' => $curTargetPos->{'TargetLocus'},
				'StartRel' => $curTargetPos->{'TargetStartRel'},
				'phyloPval' => $pval,
				'UpDown' => $upordown});
		}
	}
	
	$CNSLineCounter++;
}

print localtime() . ": Done collecting positions from reference.\n";

close ($CNSInputFile);

print localtime() . ": Done calculating statistics.\n";
######### Finally, dump the tables
mkdir("$conservatoryDir/output");

open (my $outputCNS, ">$conservatoryDir/output/$referenceGenome.cns.table.csv");
open (my $outputPosition, ">$conservatoryDir/output/$referenceGenome.cns.position.table.csv");

foreach my $curCNS ( keys %CNSDB ) {
	print $outputCNS $curCNS . "," .
					 $referenceGenome . "," .
					 $CNSDB{$curCNS}{'Chromosome'} . "," . 
					 $CNSDB{$curCNS}{'Start'} . "," .
					 $CNSDB{$curCNS}{'End'} . "," .
					 $CNSDB{$curCNS}{'ORFCheck'} . "," .
					 $CNSDB{$curCNS}{'TECheck'} . "\n";
				 
				 
	my @positions = @{ $CNSDB{$curCNS}{'Position'} };
	
	foreach my $curPos ( @positions ) {
		print $outputPosition $curCNS . "," .
							  $curPos->{'RefLocus'} . "," . 
						      $curPos->{'Genome'} . "," .
						      $curPos->{'TargetLocus'} . "," .
						      $curPos->{'StartRel'} . "," .
						      $curPos->{'UpDown'} . "," . 
						      $curPos->{'phyloPval'} . "\n";	
	}
}

close($outputCNS);
close($outputPosition);


### Compute overlap between two fragments. Parameters:
### overlap(startOne, endOne, StartTwo, endTwo, mode)
### mode can be "ABS", in which case returns the absolute overlap in bp
### else, returns relative overlap (0-1).
###

sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo, $mode) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		#### return the percent overlap
		if($endOne < $endTwo) {
			if($startOne >= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endOne -$startTwo);
				} else {
					return ($endOne -$startTwo) /($endOne - $startOne);
				}
			} 
		} else {
			if($startOne <= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);					
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endTwo -$startOne);
				} else {
					return ($endTwo -$startOne) /($endOne - $startOne);
				}
			} 			
		}
	}
}
