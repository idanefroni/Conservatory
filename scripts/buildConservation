#!/usr/bin/perl

use POSIX;
use strict;

use Text::CSV;
use Data::Dumper qw(Dumper);
use List::Util qw(min max sum);
use List::MoreUtils qw(uniq firstidx);
use Bio::AlignIO;
use Bio::Align::DNAStatistics;
use Bio::Tools::Run::Alignment::Muscle;
use Bio::Tools::Run::Phylo::PAML::Codeml;
use Bio::Align::Utilities;
use Bio::TreeIO;
use Statistics::Basic qw(:all nofill);
use Cwd;
use Cwd 'abs_path';
use Getopt::Long;
use experimental 'smartmatch';

use lib './scripts';
use ConservatoryUtils;

$|=1;

###############################################################################
######### Setup

my $conservatoryDir=abs_path(".");

my $EMPTY_FILE = 0; # The size of an empty MAF file, containing no alignments
my $CLASSIFICATION_CLASSES_NUM=6;  ## The number of phylogeny classification categories in the genome_database file. Currently default is 6 (starts from 0).

my $curDir;
my $tmpDir;
my $locus;
my $locusFullName;
my $referenceGenome;
my $referenceGenomeSpecies;
my $referenceGenomeFamily;
my @referenceClassification;

#### Sequence Filtering and parameters
my $homoPolymerFilterLength = 8;         ### Filter homopolymer of this length
my $homoPolymerFuzzyFilterLength = 12;   ### Filter homopolymer with one variant of this length
my $atRichRegionFilterLength = 10;       ### Filter atrich regions of this length
my $atRichRegionFilterFlankLength = 2;   ###   when filtering atrich, leave flanks of this length
my $dimerPolymerFilterLength = 5;        ### Filter repeating dimers of these many repeats
my $filterCharacter = 'X';
my $noPositionFilter =0;                 ### Filter CNS based on position (upstream vs downstream)
									
##### Alignment parameters
my $minIdentityFamily= 70;
my $minIdentityGlobal= 70;
my $minQuality = 1000;
my $alignmentSeqOverlapToMerge = 0.8; # In case we have multiple alignments from a single promoter to the same region in the reference genome, we will filter them
									# This parameter defines the minimal overlap to consider two alignments.

### PhyloP parameters and CNS filtering parameters
my $minOrthologsForConservationAnalysis =5; # The smallest number of orthologs to consider conservation analysis
my $minPhyloPscore=2;  # Default minumum phyloP score
my $minCNSLength=8;
my $CNSMergeLength=5;   # What is the maximum distance between conserved nucleotides to merge into a single CNS

my $minFamilySpeciesForCNS=0.333; # The minimum number of species in the family (out of the total species in the family) that have a CNS to be considered as one

#### CNS coverage and splitting parameters
my $minAlignmentLengthToTestOverlap = 30; ### Alignments of less than this length will be checked to see that they significally overlap with the CNS
my $minCNSCoverageInitial=0.2; ### The minimum coverage of the CNS to be acceptable for an initial deep alignment
my $minCNSCoverageAfterSplit=0.5; ### The minimum coverage of CNS to assign to a sub-CNS after splitting
my $minCNSConservationAfterSplit = 0.2; ### The minimal relative number of bases with significant conservation score to have for a split CNS to be considered


my $minCNSCoverageFinal=0.7; ## The coverage a final CNS must have to be considered a hit to the CNS (after spliting and filtering)


#### Alignment filtering parameters
my @minSpeciesPerConservationLevel= (200,125,100,80,30,10); ## Must have atleast these many alignments to support level assignment
my @minSpeciesAtConservationLevel= (1,1,1,3,5,5); ## Must have atleast these many species from each level to support level assignment

my $minSpeciesPerConservationLevelString="";
my $minORFLength="auto";
my $minHSPthresholdFamily=2000;
my $minHSPthresholdGlobal=1600;
my $orthologSelectionStrategy = "bestmean";

###### Other parameters
my $keep_tmp = 0;
my $verbose = 0;
my $force=0;  
my $dumpBam = 0;
my $skipKaKs=0;
my $skipMissingGenomes=0;
my $justFamilyAlignment = 0;

my $help = 0;

########### Reg Seq lengths
my $upstreamLength;
my $downstreamLength;

my %upstreamLengthReference;
my %downstreamLengthReference;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"locus=s" => \$locus,
			"reference=s" => \$referenceGenome,
			"min-identity-family=i" => \$minIdentityFamily,
			"min-identity-global=i" => \$minIdentityGlobal,
			"min-align-threshold-family=i" => \$minHSPthresholdFamily,
			"min-align-threshold-global=i" => \$minHSPthresholdGlobal,			
			"min-phylop-score=f" => \$minPhyloPscore,
			"min-deep-cns-coverage" => \$minCNSCoverageInitial,
			"min-species-per-conservation-level" => \$minSpeciesPerConservationLevelString,
			"min-orf-length=i" => \$minORFLength,
			"atrich-length-filter=i" => \$atRichRegionFilterLength,
			"no-position-filter" => \$noPositionFilter,
			"cns-merge-length" => \$CNSMergeLength,
			"just-family-alignment" => \$justFamilyAlignment,
			"keep-tmp" => \$keep_tmp,
			"tmp-dir=s" => \$tmpDir,
			"verbose" => \$verbose,
			"bam-dump" =>\$dumpBam,
			"force" => \$force,
			"skip-kaks" => \$skipKaKs,
			"skip-missing-genomes" => \$skipMissingGenomes,
			"help" => \$help) or die ("Error in command line arguments\n");

if($verbose) { print "Conservatory version 2.0.1\n\n"; }

if($minCNSCoverageInitial <0 || $minCNSCoverageInitial>1) {
	print "\n\nBad parameters: min-deep-cns-coverage must be between 0 and 1.\n\n";
	$help = 1;
}

#### Redefine the conservation level filters - not implemented
if($minSpeciesPerConservationLevelString ne "") {
    ## TDB
}

if( $locus eq "" or $referenceGenome eq "" or $help or !($orthologSelectionStrategy eq "bestmean" or $orthologSelectionStrategy eq "bestsum" ) ) {
	if($locus eq "" or $referenceGenome eq "") {
		print "\n\nMissing parameter: must supply both reference genome and locus.\n\n";
	}
	if (!($orthologSelectionStrategy eq "bestmean" or $orthologSelectionStrategy eq "bestsum")) {
		print "\n\nBad parameter: ortholog-selection-strategy can be either bestsum or bestmean.\n\n";
	}

   print "buildConservation --reference <familyName> --locus <Locus>\n\n\n";
   print "\t--reference\tReference genome name (REQUIRED). Genomes must be processed with processGenome --global for the reference genome before running buildConservation.\n";
   print "\t--locus\t\t\tLocus in the reference genome for the family (REQUIRED).\n";
   print "\t--conservatoryDirectory\t\tPath of the main conservatory directory.\n";
   print "\t--force\t\tOverwrite existing CNS file.\n";
   print "\n\t\tAlignment options\n\n";
   print "\t--min-identity-family\t\tMinimum identity for alignments within the family. Default is 70.\n";
   print "\t--min-identity-globa\t\tMinimum identity for alignments of CNS for genomes outside the family. Default is 60.\n";
   print "\t--min-align-threshold-family\t\tMimimum alignment score threshold for within family alignments. Default is 2000.\n";
   print "\t--min-align-threshold-global\t\tMimimum alignment score threshold for global alignments. Default is 1600.\n";
   print "\t--min-phylop-score\t\tMinimum phyloP score to consider as significant CNS (default: 1.5).\n";
   print "\t--min-deep-cns-coverage\t\tMimimum alignment coverage for deep CNS (Expressed as ratio of CNS length: 0-1). Default is 0.2.\n";
   print "\t--min-species-per-conservation-level\t\tSpecies number filter for level conservation. Defines the mimimum number of species a CNS has to be found it to allow a certain conservation level. A string of 6 comma delimited values. Default is 150,100,100,50,5,5.\n";   
   print "\t--min-orf-length\t\tMinimum length (in bp) of ORF to identify in CNS. Deafult is \"auto\" which is automatically calculated based on expected random ORF occurance in data.\n";
   print "\t--atrich-length-filter\t\tLength of AT-rich strech to mask (Default 10).\n";
   print "\t--cns-merge-length\t\tMerge CNSs which distance apart is less than this parameter (Default 5).\n";   
   print "\t--no-position-filter\t\tDo not filter CNS conservation based on relative position to the gene (allow CNSs to move up/down stream to the gene).\n";

   
   print "\t--bam-dump\t\tGenerate bam files for the alignments.\n";
   print "\t--skip-kaks\t\tSkip KaKs calculation (run faster)\n";
   print "\t--skip-missing-genomes\t\tIf genome information can't be found, skip and continue analysis (DEFAULT: Terminate with error message),\n";
   print "\t--tmp-dir\t\tSpecify the temporary directory (DEFAULT is alignments/<referenceName>/tmp).\n"; 
   print "\t--keep-tmp\t\tDo not delete all the temporary files produced in the temporary directory.\n";

 
   print "\n\t\tGeneral options\n\n";
   print "\t--verbose\t\tOutput extra messages.\n";
   print "\t--help\t\t\tPrints this message.\n\n";
   
   exit();
}

### Set up directory and file access
my $genomedbFile = $conservatoryDir . "/genome_database.csv";

my $outputDir = "$conservatoryDir/alignments/$referenceGenome/";
my $outputCNSDir = "$conservatoryDir/CNS/$referenceGenome/";

if($tmpDir eq "") {
	$tmpDir = "$conservatoryDir/alignments/$referenceGenome/tmp";
}

my $genomeDir ="$conservatoryDir/genomes";
my $finalFASTAUpFileName = "$outputDir/$locus.up.fasta";
my $finalFASTADownFileName = "$outputDir/$locus.down.fasta";
my $finalCNSFileName = "$outputCNSDir/$locus.cns.csv";
my $tmpCNSFileName = "$tmpDir/$locus.cns.csv";
my $finalMapFileName = "$outputCNSDir/$locus.map.csv";

### Alignment, orthologs and CNSs
my %fastaUpstreamAlignment;
my %fastaDownstreamAlignment;
my %speciesDatabase;
my %regulatoryRegionLengthDatabase;
my %speciesClassification;

my %mapAlignmentFamily;
my %orthologs;

my @phyloPconservationMapUp;
my @phyloPconservationMapDown;

my $lastzParametersFamily = "--gap=200,100 --nochain --noytrim --seed=match4 --gapped --strand=both --step=1 --ambiguous=iupac --identity=$minIdentityFamily --ydrop=1000 --hspthreshold=$minHSPthresholdFamily --gappedthresh=$minHSPthresholdFamily";
my $lastzParametersGlobal = "--gap=200,100 --nochain --noytrim --seed=match4 --gapped --strand=both --step=1 --ambiguous=iupac --identity=$minIdentityGlobal --ydrop=1000 --hspthreshold=$minHSPthresholdGlobal --gappedthresh=$minHSPthresholdGlobal";

####### First, sanity checks. Check to see if directory structure is OK and if programs are installed
####### 
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;
die "ERROR: Conservatory directory structure at ($conservatoryDir) is corrupt\n" unless (-e "$conservatoryDir/genomes" && -e "$conservatoryDir/genomes/blastdb/" && -e "$conservatoryDir/scripts" && -e "$conservatoryDir/alignments");

my $t_lastz = `sh -c 'command -v lastz'`;
die "ERROR: Cannot find lastz in path. Please make sure it is installed.\n" unless ($t_lastz ne ""); 

my $t_samtools = `sh -c 'command -v samtools'`;
die "ERROR: Cannot find samtools in path. Please make sure it is installed.\n" unless ($t_samtools ne "");  

my $t_phyloP = `sh -c 'command -v phyloP'`;
die "ERROR: Cannot find phyloP in path. Please make sure phast is installed.\n" unless ($t_phyloP ne "");  

my $t_wig2bed = `sh -c 'command -v wig2bed'`;
die "ERROR: Cannot find wig2bed in path. Please make sure bedops is installed.\n" unless ($t_wig2bed ne "");  
my $t_muscle = `sh -c 'command -v muscle'`;
die "ERROR: Cannot find muscle in path. Please make sure muscle v3.8.1551 is installed.\n" unless ($t_muscle ne "");  

die "ERROR: Cannot find fastMLexecutable at $conservatoryDir/scripts/fastml.\n" unless (-x "$conservatoryDir/scripts/fastml");
###############################################
### Make sure we are not over-writing existing CNS file (unless we are forced to)
if ( (-e $finalCNSFileName) && !$force  ) { die "END: Output CNS file for $locus ($finalCNSFileName) already exists. Use --force to overwrite.\n"; }

if ( (-e "$outputCNSDir/$locus.phylop.bed" ) && !$force  ) { die "END: Output Bed file for $locus ($finalCNSFileName) already exists. Use --force to overwrite.\n"; }

if( (-e $finalFASTAUpFileName) && (!$force) && $justFamilyAlignment) { die "END: Output family alignment file for $locus ($finalFASTAUpFileName) already exists. Use --force to overwrite.\n"; }

###############################################
if($verbose) { print "START: Begin conservatory analysis for $locus.\n"; }

if( (-e $finalCNSFileName) && $force && $verbose) { print "PROGRESS: Overwriting existing file $finalCNSFileName.\n"; }

###############################################
##### Now set things up
##### Find out what is our reference genome family and length parameters
open (my $genomeDatabase, "<", $genomedbFile);
while((my $curgenomeline = <$genomeDatabase>)) {
	chomp($curgenomeline);
	if(substr($curgenomeline,0,1) ne "#")  {
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$speciesDatabase{$curgenomeFamily}{$curgenomeSpecies}=0;
		$regulatoryRegionLengthDatabase{$curgenomeName}{'upstreamLength'} = $upstreamLength * 1000;
		$regulatoryRegionLengthDatabase{$curgenomeName}{'downstreamLength'} = $downstreamLength * 1000;
		$speciesClassification{$curgenomeSpecies} = $classification;
		
		if($curgenomeName eq $referenceGenome) {
			$referenceGenomeFamily = $curgenomeFamily;
			$referenceGenomeSpecies = $curgenomeSpecies;
			$locusFullName = "$curgenomeSpecies-$curgenomeName-$locus";

			$upstreamLengthReference{$locusFullName} = $upstreamLength  * 1000;
			$downstreamLengthReference{$locusFullName} = $downstreamLength * 1000;
		}
	}
}
seek ($genomeDatabase,0,SEEK_SET);

die "ERROR: Cannot find reference genome $referenceGenome in the genome database file.\n" unless $referenceGenomeFamily ne "";
@referenceClassification = split /-/ , $speciesClassification{$referenceGenomeSpecies};

### Setup model and tree
my $treeFileName = "$conservatoryDir/genomes/$referenceGenomeFamily.tree";
my $modelFileName = "$conservatoryDir/genomes/$referenceGenomeFamily.mod";

if(!$justFamilyAlignment) { ## Check to see if we have a tree, if we need
	die "ERROR: Cannot find tree file $treeFileName for reference genome $referenceGenome.\n" unless (-e $treeFileName);
	die "ERROR: Cannot find model file $modelFileName for reference genome $referenceGenome.\n" unless (-e $modelFileName);
}
### Read tree to memory
my $treeReader = new Bio::TreeIO(-file   => $treeFileName,
                            -format => "newick");
my $tree = $treeReader->next_tree;

### make place for the alignment and CNS
if (! -e $outputDir) { mkdir($outputDir); }
if (! -e $tmpDir) { mkdir($tmpDir); }
if (! -e $outputCNSDir) { mkdir($outputCNSDir); }	

### Extract the absolute coordinates of the locus
my $refFootprintFileName = "$conservatoryDir/genomes/$referenceGenomeFamily/$referenceGenome.footprint.gff3";
my ($refGeneStart, $refGeneEnd, $refGeneChr, $refGeneDir) = ("","","","");

open (my $refFootprintFile, "<", $refFootprintFileName);
while ((my $line = <$refFootprintFile>) && $refGeneChr eq "" ){
	chomp($line);
	my @array = split /\t/, $line;
	my %fields = split /[;=]/, $array[8];
	
	if($fields{'Name'} eq $locusFullName) {
		$refGeneChr = $array[0];
		$refGeneStart = $array[3];	
		$refGeneEnd = $array[4];
		$refGeneDir= $array[6];
	}
}
close($refFootprintFile);
die "ERROR: Cannot find locus $locusFullName in reference genome $referenceGenome.\n" unless ($refGeneChr ne "");

if($verbose) { print "PROGRESS: Extracted genome coordinates $locus:$refGeneChr:$refGeneStart:$refGeneEnd. Upstream sequence $upstreamLengthReference{$locusFullName} bp. Downstream sequence $downstreamLengthReference{$locusFullName} bp.\n"; }

	
#remember where we are
$curDir = getcwd;
chdir $tmpDir;

####### Set up the reference fasta files
my $upstreamRefFastaName = "$tmpDir/$referenceGenome.$locus.up.fasta";
my $downstreamRefFastaName = "$tmpDir/$referenceGenome.$locus.down.fasta";

#### Perform family alignments

$fastaUpstreamAlignment{$locusFullName}{$referenceGenomeSpecies} = extractFastaToFile("$genomeDir/$referenceGenomeFamily/$referenceGenome" . ".upstream.fasta.gz", $locusFullName, $upstreamRefFastaName);
$fastaDownstreamAlignment{$locusFullName}{$referenceGenomeSpecies} = extractFastaToFile("$genomeDir/$referenceGenomeFamily/$referenceGenome" . ".downstream.fasta.gz", $locusFullName, $downstreamRefFastaName);
if($verbose) { print localtime() . ": Done extracting reference sequences.\n";}

# set up CRE-orthology hashes
##############################################################################
# First pass. Determine CNS for family
  
while(<$genomeDatabase>) {
	chomp;
	my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx) = split /,/;

	if(substr($curgenomeName,0,1) ne "#" && $curgenomeFamily eq $referenceGenomeFamily) { #if this is not a comment and if it within the family 
 
		### get ortholog sequences
		my $orthologFileName = "$genomeDir/$curgenomeFamily/$referenceGenome.$curgenomeName.orthologs.csv";
		my $orthologFileFound = open (my $orthologFile, "<", $orthologFileName);
		
		if(!$orthologFileFound && !$skipMissingGenomes) { die "ERROR: Can't open ortholog file $orthologFileName. Did you run processGenomes for this reference genome?\n"; }
		if($orthologFileFound && -e "$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz" && -e "$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz") {
			while(my $orth_line = <$orthologFile>) {
				chomp($orth_line);
				(my $curPutativeOrtholog, my $curRefLocus, my $score) = split /,/,$orth_line;
				if($curRefLocus eq $locusFullName && $curPutativeOrtholog ne $curRefLocus) {
					my $upstreamFastaName ="$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.up.fasta";
					my $downstreamFastaName = "$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.down.fasta";
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz", $curPutativeOrtholog, $upstreamFastaName);
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz", $curPutativeOrtholog, $downstreamFastaName);

					my $MAFUpFileName = "$locus.$curPutativeOrtholog.up.maf";
					system("lastz --format=maf $lastzParametersFamily $upstreamRefFastaName $upstreamFastaName > $MAFUpFileName");
					my $upQuality = getMAFQuality($MAFUpFileName);
					my $MAFDownFileName = "$locus.$curPutativeOrtholog.down.maf";
					system("lastz --format=maf $lastzParametersFamily $downstreamRefFastaName $downstreamFastaName > $MAFDownFileName");
					my $downQuality = getMAFQuality($MAFDownFileName);

					#############################################################
					if($upQuality+$downQuality > $minQuality) {				
						if($verbose && $curgenomeName ne $referenceGenome) { print "PROGRESS: Found possible CRE-ortholog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: " . ($upQuality+$downQuality) . ".\n"; }
						if($verbose && $curgenomeName eq $referenceGenome) { print "PROGRESS: Found possible CRE-paralog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: " . ($upQuality+$downQuality) . ".\n"; }
					
						if(not defined $orthologs{$curgenomeSpecies}) {
							$orthologs{$curgenomeSpecies} = [ {
								'Name' => $curPutativeOrtholog,
								'Genome' => $curgenomeName,
								'Family' => $curgenomeFamily,
								'upstreamLength' => $upstreamLength *1000,
								'downstreamLength' => $downstreamLength *1000,
								'upstreamFileName' => $upstreamFastaName,
								'downstreamFileName' => $downstreamFastaName,
								'MAFUpFileName' => $MAFUpFileName,
								'MAFDownFileName' => $MAFDownFileName,
								'UpQuality' => $upQuality,
								'DownQuality' => $downQuality} ];		
						} else {
							push( @{ $orthologs{$curgenomeSpecies} },
								{
									'Name' => $curPutativeOrtholog,
									'Genome' => $curgenomeName,
									'Family' => $curgenomeFamily,
									'upstreamLength' => $upstreamLength *1000,
									'downstreamLength' => $downstreamLength *1000,
									'upstreamFileName' => $upstreamFastaName,
									'downstreamFileName' => $downstreamFastaName,
									'MAFUpFileName' => $MAFUpFileName,
									'MAFDownFileName' => $MAFDownFileName,
									'UpQuality' => $upQuality,
									'DownQuality' => $downQuality});
							}
					} else {
						if($verbose && $curgenomeName ne $referenceGenome) { print "PROGRESS: Rejected CRE-ortholog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: $upQuality.\n"; }
						if($verbose && $curgenomeName eq $referenceGenome) { print "PROGRESS: Rejected CRE-paralog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: $upQuality.\n"; }
						unlink($MAFDownFileName);
						unlink($MAFUpFileName);
						unlink($upstreamFastaName);
						unlink($downstreamFastaName);
					}
				}
			}
			close($orthologFile);
		}
	}
}
close ($genomeDatabase);	
  	
if(!$keep_tmp) {
	unlink($upstreamRefFastaName);
	unlink($downstreamRefFastaName);
}

#####################################################################################################
##### Now we have assembled the list of putative CRE orthologs. Select the best genome for each species

%orthologs = pickBestPutativeOrthologs(%orthologs);

####################################################################################################################################
##### At this point, we have selected our "CRE orthologs" (%orthologs) and have all the filtered upstream and downstream sequences in fasta files 
##### Perform alignments to the reference genome
my @species = keys %orthologs;
my $numOfSpecies = scalar @species;

if ($verbose) { print "PROGRESS: Done with CRE-ortholog selection. Collected $numOfSpecies CRE-orthologs.\n"; }

if ($numOfSpecies > $minOrthologsForConservationAnalysis ) {
	#### Now all alignments were performed, assemble MAF files to a single alignment. 
	### First, move everything to an array. Dump a copy to the CRE-ortholog file
	if($verbose) { print "PROGRESS: Multiple sequence assembly"; }
	
	my $finalCREorthologFileName = "$outputDir/$locus.CREorthologs.txt";
	open(my $finalCREorthologFile, ">$finalCREorthologFileName");
	
	my @orthologsToProcess;
	foreach my $speciesToAlign (@species) {
		foreach my $curOrtholog (@{ $orthologs{$speciesToAlign} }) {
			if($curOrtholog->{'UpQuality'} > $EMPTY_FILE || $curOrtholog->{'DownQuality'} > $EMPTY_FILE) {
				push @orthologsToProcess, $curOrtholog;
				print $finalCREorthologFile  $curOrtholog->{'Genome'} . "\t" . $curOrtholog->{'Name'} . "\t" . $curOrtholog->{'UpQuality'} . "\t" . $curOrtholog->{'DownQuality'} ."\n"; 
			}
		}
	}

	if((scalar @orthologsToProcess) > 0) {
		my @orthologsToProcessSorted = reverse sort { $a->{'UpQuality'} <=> $b->{'UpQuality'} } @orthologsToProcess;
	
		### Load all MAF, collapse species-specific paralogs and convert to FASTA.
	
		foreach my $curOrthologToMultipleAlignment (@orthologsToProcessSorted) {
		
			MAFtoFASTA($curOrthologToMultipleAlignment->{'MAFUpFileName'}, \%upstreamLengthReference, $curOrthologToMultipleAlignment->{'upstreamLength'}, \%fastaUpstreamAlignment, \%mapAlignmentFamily, "U");
			MAFtoFASTA($curOrthologToMultipleAlignment->{'MAFDownFileName'}, \%downstreamLengthReference,$curOrthologToMultipleAlignment->{'downstreamLength'}, \%fastaDownstreamAlignment, \%mapAlignmentFamily, "D");
				
			if(!$keep_tmp) {
				unlink($curOrthologToMultipleAlignment->{'MAFUpFileName'});
				unlink($curOrthologToMultipleAlignment->{'MAFDownFileName'});
				unlink($curOrthologToMultipleAlignment->{'upstreamFileName'});
				unlink($curOrthologToMultipleAlignment->{'downstreamFileName'});
			}
		}
		open (my $finalFASTAUpFile, ">$finalFASTAUpFileName");
		open (my $finalFASTADownFile, ">$finalFASTADownFileName");

		# replace 'X' with 'N' for phyloP and Dump fasta alignment
		my $upOutSeq = $fastaUpstreamAlignment{$locusFullName}{$referenceGenomeSpecies};
		my $downOutSeq = $fastaDownstreamAlignment{$locusFullName}{$referenceGenomeSpecies};
		$upOutSeq =~ s/X/N/g;
		$downOutSeq =~ s/X/N/g;

		print $finalFASTAUpFile ">$referenceGenomeSpecies\n$upOutSeq\n";
		print $finalFASTADownFile ">$referenceGenomeSpecies\n$downOutSeq\n";
		
		## output the fasta file in order - from most aligned to least aligned
		my %alignedSeqPerSpecies;
		for my $curspecies (keys %{ $fastaUpstreamAlignment{$locusFullName} } ) {
			### If it is an empty string, pad with unknown
			if($fastaUpstreamAlignment{$locusFullName}{$curspecies} eq "" ) { $fastaUpstreamAlignment{$locusFullName}{$curspecies} = 'N' x length($upOutSeq) }
			my $alignedSeqLength = $upstreamLengthReference{$locusFullName} - $fastaUpstreamAlignment{$locusFullName}{$curspecies} =~ tr/N//;
			$alignedSeqPerSpecies{$curspecies} = $alignedSeqLength;
		}

		for my $curspecies ( reverse sort { $alignedSeqPerSpecies{$a} <=> $alignedSeqPerSpecies{$b} } keys %alignedSeqPerSpecies ) {
			if($curspecies ne $referenceGenomeSpecies) {
				print $finalFASTAUpFile ">$curspecies\n" . $fastaUpstreamAlignment{$locusFullName}{$curspecies} . "\n";
			}
		}
		for my $curspecies (keys %{ $fastaDownstreamAlignment{$locusFullName} } ) {
			if($fastaDownstreamAlignment{$locusFullName}{$curspecies} eq "" ) { $fastaDownstreamAlignment{$locusFullName}{$curspecies} = 'N' x length($downOutSeq) }			
			my $alignedSeqLength = $downstreamLengthReference{$locusFullName} - $fastaDownstreamAlignment{$locusFullName}{$curspecies} =~ tr/N//;
			$alignedSeqPerSpecies{$curspecies} = $alignedSeqLength;
		}

		for my $curspecies ( reverse sort { $alignedSeqPerSpecies{$a} <=> $alignedSeqPerSpecies{$b} } keys %alignedSeqPerSpecies ) {
			if($curspecies ne $referenceGenomeSpecies) {
				print $finalFASTADownFile ">$curspecies\n" . $fastaDownstreamAlignment{$locusFullName}{$curspecies} . "\n";
			}
		}	
		close($finalFASTAUpFile);
		close($finalFASTADownFile);
	}
	if($verbose) { print "\n"; }
} else {
	if($verbose) { print "PROGRESS: Not enough CRE-orthologs for $locus.\n"; }
	exit;
} 
if($verbose) { if(-e "$outputDir/$locus.up.fasta") { print "PROGRESS: Done alignment for $locus.\n"; } }

if($justFamilyAlignment) {
	die "END: --justFamilyAlignment is selected. Finish performing family alignments\n";
}

##########################################################################################################
### Alignments for all CRE-orthologs are ready. Now process with phyloP to identify family-CNS

if (! -e $outputCNSDir) { mkdir($outputCNSDir); }

if($verbose) { print "PROGRESS: Begin family conservation analysis for $locus. Model file: $modelFileName. Minimum phyloP score: $minPhyloPscore.\n"; }

my $coordinateTranslateAwkUp;
my $coordinateTranslateStrUp;
my $coordinateTranslateAwkDown;
my $coordinateTranslateStrDown;

if($refGeneDir eq "+") {
	$coordinateTranslateAwkUp = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneStart-$upstreamLengthReference{$locusFullName} + \$2,$refGeneStart-$upstreamLengthReference{$locusFullName} + \$3,\$5);}}'";
	$coordinateTranslateStrUp = " \"$refGeneChr\", $refGeneStart- $upstreamLengthReference{$locusFullName} + \$2, $refGeneStart - $upstreamLengthReference{$locusFullName} + \$3";
	$coordinateTranslateAwkDown = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneEnd + 1 + \$2,$refGeneEnd + 1 + \$3,\$5);}}'"; 
	$coordinateTranslateStrDown = " \"$refGeneChr\", $refGeneEnd + 1 + \$2, $refGeneEnd + 1 + \$3";	
} else { 
	$coordinateTranslateAwkUp = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneEnd + $upstreamLengthReference{$locusFullName}-\$3 + 1 ,$refGeneEnd+ $upstreamLengthReference{$locusFullName}-\$2 + 1,\$5);}}'";
	$coordinateTranslateStrUp = " \"$refGeneChr\", $refGeneEnd+$upstreamLengthReference{$locusFullName}-\$3 + 1 , $refGeneEnd+$upstreamLengthReference{$locusFullName}-\$2 + 1";
	$coordinateTranslateAwkDown = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneStart-\$3 - 1 ,$refGeneStart-\$2 - 1,\$5);}}'";
	$coordinateTranslateStrDown = "\"$refGeneChr\",$refGeneStart-\$3 - 1,$refGeneStart-\$2 - 1";
}
	
#### Run phyloP 
my $phyloPParameters = "--seed 123 --wig-scores --no-prune --method SCORE --mode CON";
my $CNSFound=0;

if(-s $finalFASTAUpFileName > $EMPTY_FILE) {

	system("phyloP $phyloPParameters $modelFileName $finalFASTAUpFileName | wig2bed > $tmpDir/$locus.up.bed");
	system("sort -k1,1 -k2,2n -o $tmpDir/$locus.up.bed $tmpDir/$locus.up.bed");

	if((-s "$tmpDir/$locus.up.bed") > $EMPTY_FILE) { 
		system("awk '{ if(\$5>$minPhyloPscore) {print;}}' $tmpDir/$locus.up.bed > $tmpDir/$locus.up.fil.bed");
		if(-s "$tmpDir/$locus.up.fil.bed" > $EMPTY_FILE) {
			$CNSFound=1;
			if($verbose) { print "PROGRESS: Found possible family upstream CNS.\n"; }
			system("bedtools merge -d $CNSMergeLength -c 5 -o mean -i $tmpDir/$locus.up.fil.bed | awk 'BEGIN{OFS=\",\"}{ if( (\$3 - \$2)>=$minCNSLength) print(\"$locus\", \$2-$upstreamLengthReference{$locusFullName}, \$3-$upstreamLengthReference{$locusFullName}, \$4,\"UP\",$coordinateTranslateStrUp); }' > $tmpCNSFileName");
		} else {
			if($verbose) { print "PROGRESS: No family upstream CNS.\n"; }
		}
		if(!$keep_tmp) {unlink("$tmpDir/$locus.up.fil.bed"); }
	}
}

if(-s $finalFASTADownFileName > $EMPTY_FILE) {
	system("phyloP $phyloPParameters $modelFileName $finalFASTADownFileName | wig2bed > $tmpDir/$locus.down.bed");
	system("sort -k1,1 -k2,2n -o $tmpDir/$locus.down.bed $tmpDir/$locus.down.bed ");

	if(-s "$tmpDir/$locus.down.bed"> $EMPTY_FILE) { 
		system("awk '{ if(\$5>$minPhyloPscore) {print;}}' $tmpDir/$locus.down.bed > $tmpDir/$locus.down.fil.bed");
		if(-s "$tmpDir/$locus.down.fil.bed" > $EMPTY_FILE) {
			$CNSFound=1;
			if($verbose) { print "PROGRESS: Found possible family downstream CNS.\n"; }
			system("bedtools merge -d $CNSMergeLength -c 5 -o mean -i $tmpDir/$locus.down.fil.bed | awk 'BEGIN{OFS=\",\"}{ if( (\$3 - \$2)>=$minCNSLength) print(\"$locus\", 1+ \$2, 1+ \$3, \$4 ,\"DOWN\",$coordinateTranslateStrDown); }' >> $tmpCNSFileName");
		} else {
			if($verbose) { print "PROGRESS: No family downstream CNS.\n"; }
		}
		if(!$keep_tmp) {unlink("$tmpDir/$locus.down.fil.bed"); }
	}
}
	
if( (-e $tmpCNSFileName) && ((-s $tmpCNSFileName) > $EMPTY_FILE )) {
	### Now convert coordinates,dump a BEDGRAPH file for merging and load the phyloP scores for further filtering
	@phyloPconservationMapUp = (0) x ( $upstreamLengthReference{$locusFullName} );
	@phyloPconservationMapDown = (0) x ( $downstreamLengthReference{$locusFullName} );

	if(-e "$tmpDir/$locus.up.bed") {
		system("$coordinateTranslateAwkUp $tmpDir/$locus.up.bed > $tmpDir/$locus.phylop.bed");
		open (my $upstreamPhylopFile, "<$tmpDir/$locus.up.bed");
		while(<$upstreamPhylopFile>) {
			my ($locus,$start,$end,$id,$pvalue) = split;
			$phyloPconservationMapUp[$start] = ($pvalue + 0);
		}
		close($upstreamPhylopFile);
	}
	if(-e "$tmpDir/$locus.down.bed") {
		system("$coordinateTranslateAwkDown $tmpDir/$locus.down.bed >> $tmpDir/$locus.phylop.bed");
		open (my $downstreamPhylopFile, "<$tmpDir/$locus.down.bed");
		while(<$downstreamPhylopFile>) {
			my ($locus,$start,$end,$id,$pvalue) = split;
			$phyloPconservationMapDown[$start] = ($pvalue + 0);
		}
		close($downstreamPhylopFile);		
	}
	if( (-e "$tmpDir/$locus.phylop.bed") && ( (-s "$tmpDir/$locus.phylop.bed") > $EMPTY_FILE) ) {
		system("cp $tmpDir/$locus.phylop.bed $outputCNSDir");
	}
} else {
	$CNSFound =0;
}

if(!$keep_tmp) { 
	unlink("$tmpDir/$locus.up.bed");
	unlink("$tmpDir/$locus.down.bed");
	unlink("$tmpDir/$locus.phylop.bed");
}

if($verbose) { print "PROGRESS: End conservation analysis for $locus.\n"; }

if(!$CNSFound) {
	unlink($tmpCNSFileName);
	if($verbose) { print ("END: No CNS found for $locus.\n"); } 
	exit();
}

###############################################################################################################################
### Prepare the reconstructed ancesteral sequence of the CNS
### filter CNS and prepare for CNS alignments with all genomes

if($verbose) { print "PROGRESS: Begin ancesteral sequence reconstruction for $locus.\n"; }

### Replace 'N' with missing data in alignments
foreach my $curSpecies (keys %{ $fastaUpstreamAlignment{$locusFullName} }) {
	$fastaUpstreamAlignment{$locusFullName}{$curSpecies} =~ s/N/-/g;
}

foreach my $curSpecies (keys %{ $fastaDownstreamAlignment{$locusFullName} }) {
	$fastaDownstreamAlignment{$locusFullName}{$curSpecies} =~ s/N/-/g;
}

###### Assemble ancesteral family CNS for locus

my $CNSNum=0;
my $totalCNSLength=0;
my %CNSforLocus;
my %cnsReferenceLength;
my %deepCNSFasta;
my %mapAlignmentDeepCNS;

my $ancesteralLocusCNSFileName = "$tmpDir/$locus.ancesteral.cns.fasta";
open (my $ancesteralLocusCNSFasta, ">$ancesteralLocusCNSFileName");	
open (my $CNSFile, $tmpCNSFileName) || die ("INTERNAL ERROR ($locusFullName).\n");


while(my $CNSLine = <$CNSFile>) {
	chomp($CNSLine);
	my ($cnsLocus,$cnsRelStart,$cnsRelEnd,$pval,$upOrDown,$chromosome,$absStart,$absEnd) = split /,/,$CNSLine;
	
	if(($cnsRelEnd - $cnsRelStart)>= $minCNSLength) {
		
		my $curCNSLength = ($cnsRelEnd - $cnsRelStart);
		my $shortestAlignment = $curCNSLength;
		my $CNSName = "$locus.$cnsRelStart";
		$CNSforLocus{$CNSName} = {
				'Name' => $CNSName,
				'Start' => $cnsRelStart,
				'End' => $cnsRelEnd,
				'Locus' => $cnsLocus,
				'Chromosome' => $chromosome,
				'absStart' => $absStart,
				'absEnd' => $absEnd,
				'Strand' => $refGeneDir,
				'NumberOfSpecies' => 0,
				'NumberOfFamilySpecies' => 0,				
				'ConservationLevel' => $referenceGenomeFamily};
				
		my %cnsSeqs;
				
		$cnsReferenceLength{$CNSName} = $cnsRelEnd - $cnsRelStart;
		
		my $tmpCNSFastaFileName = "$tmpDir/$CNSName.cns.fasta";
		open (my $tmpCNSFile, ">$tmpCNSFastaFileName");

		my $cnsSeq;
		my $referenceCNSSeq;
		my $numOfSpeciesWithCNS=0;
		if($cnsRelStart <= 0 ) { ## If this is upstream seqeunce
			for my $curSpecies (keys %{ $speciesDatabase{$referenceGenomeFamily} }) {
				
				if(defined $fastaUpstreamAlignment{$locusFullName}{$curSpecies}) {
					$cnsSeq=substr($fastaUpstreamAlignment{$locusFullName}{$curSpecies}, $upstreamLengthReference{$locusFullName}+$cnsRelStart, $cnsRelEnd-$cnsRelStart);
					$cnsSeqs{$curSpecies}=$cnsSeq;
					$numOfSpeciesWithCNS++;
				} else {		
					$cnsSeq = ("-" x ($cnsRelEnd-$cnsRelStart));
				}
				
				print $tmpCNSFile ">$curSpecies\n$cnsSeq\n";
			}
		} else {	
			for my $curSpecies (keys %{ $speciesDatabase{$referenceGenomeFamily} }) {
				if(defined $fastaDownstreamAlignment{$locusFullName}{$curSpecies}) {
					### Get the sequence for the CNS (with extra padding, to avoid problems with edge alignments)

					$cnsSeq = substr(($fastaDownstreamAlignment{$locusFullName}{$curSpecies} . "--------") , $cnsRelStart-1, $cnsRelEnd-$cnsRelStart);
					$cnsSeqs{$curSpecies}=$cnsSeq;
					$numOfSpeciesWithCNS++;
				} else {					
					$cnsSeq = ("-" x ($cnsRelEnd-$cnsRelStart));
				}				
				print $tmpCNSFile ">$curSpecies\n$cnsSeq\n";
			}	
		}
		close ($tmpCNSFile);
				
		#### Now invoke FASTML to reconstruct ancestral sequence
		my $ancesteralCNSFileName = "$tmpDir/$locus.$cnsRelStart.ancesteral.fasta";
		system("$conservatoryDir/scripts/fastml -s $tmpCNSFastaFileName -t $treeFileName -b -mh -qf -e /dev/null -x /dev/null -y /dev/null -k /dev/null -d /dev/null -e /dev/null -j $ancesteralCNSFileName >/dev/null");
		if(!$keep_tmp) { unlink("$tmpCNSFastaFileName"); }
		unlink("log.txt");
		if($verbose) {
			print("PROGRESS: Reconstructed $locus.$cnsRelStart. Length: " . ($cnsRelEnd-$cnsRelStart) . "\n")
		}
		my $ancesteralCNS;
		open(my $ancesteralCNSFasta, $ancesteralCNSFileName) || die ("INTERNAL ERROR ($locusFullName).\n");
		while((my $seqName = <$ancesteralCNSFasta>) && $ancesteralCNS eq "") {
			my $seq = <$ancesteralCNSFasta>;
			chomp($seqName);
			chomp($seq);
			if(substr($seqName,1) eq "N1") { $ancesteralCNS = $seq;}
		}
		close($ancesteralCNSFasta);
		unlink($ancesteralCNSFileName);

		###### Mask ancesteral sequence for homopolymers
		my $ancesteralCNSMasked = $ancesteralCNS;

		## First, lastz does not handle ambigious characters very well (basically assuming N)
		# replace W with A. Not ideal, but better than alternative. Also, too many A's will be masked.
		$ancesteralCNSMasked =~ s/W/A/g;

		$ancesteralCNSMasked = fuzzyFilterHomopolymers($ancesteralCNSMasked,$homoPolymerFilterLength,0);
		$ancesteralCNSMasked = fuzzyFilterDimers($ancesteralCNSMasked, $dimerPolymerFilterLength,0);

		$ancesteralCNSMasked = fuzzyFilterHomopolymers($ancesteralCNSMasked,$homoPolymerFuzzyFilterLength,1);

		$CNSforLocus{$CNSName}{'ancesteralSequence'} = $ancesteralCNS;
		$CNSforLocus{$CNSName}{'referenceSequence'} = $cnsSeqs{$referenceGenomeSpecies};

		print $ancesteralLocusCNSFasta ">$CNSName\n$ancesteralCNSMasked\n";
		$totalCNSLength += $curCNSLength;
		$CNSNum++;
		

		##### Check for ORF in reconstructed CNS
		my ($ancesteralORFLength, $ancesteralORF, $ancesteralORFStand) = getLongestORF($ancesteralCNS);
		my $randomORFLength;
		if($minORFLength eq "auto") {
			$randomORFLength = getRandomORFLength($ancesteralCNS);
		} else {
			$randomORFLength = $minORFLength;
		}
		my $ancesteralCNSORF = Bio::LocatableSeq->new(-seq => $ancesteralORF,
						    	  					  -id => "Reconstructed",
						    	  					  -start => 1,
						    	  					  -end => $ancesteralORFLength);	
		
		if($ancesteralORFLength > $randomORFLength) {	### If there is a potential ORF, mark it and calc KaKs rate
			if($verbose) { print "PROGRESS: $CNSName: Detected ORF ($ancesteralORFLength/$randomORFLength,$ancesteralORFStand):$ancesteralORF.\n"; }
			$CNSforLocus{$CNSName}{'ORF'}= $ancesteralORFLength;
			$CNSforLocus{$CNSName}{'ORFDir'}= $ancesteralORFStand;			
			
			### Determine KaKs
			### First, assemble all ORFs
			if(!$skipKaKs) {
				my %cnsORFs;
				my @cnsPeptides;
				$cnsORFs{'Reconstructed'} = $ancesteralCNSORF;
				my $peptide = dropAsterixFromProtein($ancesteralCNSORF->translate);
				push @cnsPeptides, $peptide;

				foreach my $curCNSSpecies (keys %cnsSeqs) {
					$cnsSeqs{$curCNSSpecies} =~ s/-//g;
					$cnsSeqs{$curCNSSpecies} =~ s/X/N/g;
					if(length($cnsSeqs{$curCNSSpecies})>0) {
						my ($curLongestORFLength, $curLongestORF, $curLongestORFStand) = getLongestORF($cnsSeqs{$curCNSSpecies},$ancesteralORFStand);
						my $curCNSORF = Bio::LocatableSeq->new(-seq => $curLongestORF,
												    	   	-id => $curCNSSpecies,
												    	   	-start => 1,
												    	   	-end => $curLongestORFLength);
						$cnsORFs{$curCNSSpecies} = $curCNSORF;
						$peptide = dropAsterixFromProtein($curCNSORF->translate);
						push @cnsPeptides, $peptide;
					}
				}
			
				my $stats = Bio::Align::DNAStatistics->new();
				my $cnsAlignmentPep = quietAlign(\@cnsPeptides);
				### Filter low identity alignments
				my @filteredCNSPeptides;		

				my @seqCharAncesteral = split //, $cnsAlignmentPep->get_seq_by_id('Reconstructed')->seq();

				foreach my $seq ($cnsAlignmentPep->each_seq) {
					if($seq->id() ne "Reconstructed") {
						my $pairwiseAln = $cnsAlignmentPep->select_noncont_by_name('Reconstructed', $seq->id());
						my $nogappairwiseAln = $pairwiseAln->remove_gaps();

						if($nogappairwiseAln->length > 4 && $pairwiseAln->percentage_identity > 60)  { ### If too divergent, do not include sequence
							my $nogapSeq = $seq->seq();
							$nogapSeq =~ s/-//g;
							$seq->seq($nogapSeq);
							push @filteredCNSPeptides, $seq;
						}
					}
				}
			
				if(@filteredCNSPeptides >1) {
			
					my $filteredCNSAlignmentPep = quietAlign(\@filteredCNSPeptides);
					my $cnsDNAAlignment = Bio::Align::Utilities::aa_to_dna_aln($filteredCNSAlignmentPep, \%cnsORFs);
					### See that we have something to align, and its not too divergent or not divergent enough
					my $nogapalignment = $cnsDNAAlignment->remove_gaps();
					if($nogapalignment->length > 0) {
						## Calculate KsKa
						if($verbose) { printf "PROGRESS: $CNSName: Calculating KaKs..."; }

						my $kaks_factory = Bio::Tools::Run::Phylo::PAML::Codeml->new(
							-verbose => 0,
							-tree => $tree,
							-branchlengths => 1,
							-params => { 'runmode' => -2,
                      				'seqtype' => 1});

                		$kaks_factory->alignment($cnsDNAAlignment);
                		my ($rc, $parser) = $kaks_factory->run();
                		$kaks_factory->cleanup();
			
                		if($rc>0) {
                			my $results = $parser->next_result;
                			my $MLmatrix = $results->get_MLmatrix();
                			my @outseq = $results->get_seqs();
                			my $ancesteralPos= -1;
                			for(my $i=0; $i< @outseq; $i++) {
	                			if($outseq[$i]->display_id eq "Reconstructed") {
                					$ancesteralPos = $i;
                				}
                			}
                			my $totalOmega=0;
                			my $totaldN=0;
                			my $totaldS=0;
                			for(my $i =0; $i< @outseq; $i++) {
	                			if($outseq[$i]->display_id() ne "Reconstructed") {
                					$totalOmega = $totalOmega + $MLmatrix->[$ancesteralPos]->[$i]->{'omega'};
									$totaldN = $totaldN + $MLmatrix->[$ancesteralPos]->[$i]->{'dN'};
									$totaldS = $totaldS + $MLmatrix->[$ancesteralPos]->[$i]->{'dS'};
                				}
                			}
							my $meanOmega = $totalOmega / (@outseq - 1);
							my $meandS = $totaldS / (@outseq - 1);
							my $meandN = $totaldN / (@outseq - 1);
							### See if we have enough substitutions for omega to make sense
							### dS > 0.01
							if($meandS > 0.01) {
	                			$CNSforLocus{$CNSName}{'omega'} = $meanOmega;
 							} else {
		          				$CNSforLocus{$CNSName}{'omega'} = -1;   ## dS is too low
							}

                			if($verbose) { printf("... Omega: %.2f (dS: %.2f;dN: %.2f)\n", $CNSforLocus{$CNSName}{'omega'}, $meandS, $meandN); }	
                		} else {
							if($verbose) { print "..cannot determine(" . $kaks_factory->error_string() .")\n";}
                			$CNSforLocus{$CNSName}{'omega'} = -99;  ## Error
                		}
					} else {
                		$CNSforLocus{$CNSName}{'omega'} = -2; ### Cannot find consistent ORF
					}
            	} else {
            		$CNSforLocus{$CNSName}{'omega'} = -2; ### Cannot find consistent ORF
            	} 
			} else {
				$CNSforLocus{$CNSName}{'omega'} = -4; ### No KaKs value calculated
			}
		} else {
				$CNSforLocus{$CNSName}{'ORF'}=0;
				$CNSforLocus{$CNSName}{'omega'} = -3;  ### There is no ORF
		}
	}
	
}
close($ancesteralLocusCNSFasta);
close($CNSFile);
if(!$keep_tmp) { unlink("$tmpCNSFileName"); }

if($verbose) { print "PROGRESS: End ancesteral sequence reconstruction for $locus. $CNSNum CNSs. Total Length $totalCNSLength.\n"; }

#############################################################################################################
####  Assign the family alignments hits to the CNSs
my %familySpeciesHittingCNS;

foreach my $curSpecies (keys %{ $mapAlignmentFamily{$locusFullName} }) {
	foreach my $curHit ( @{ $mapAlignmentFamily{$locusFullName}{$curSpecies} } ) {
		## Find the CNS that overlaps this alignment
		my ($start,$end);
		if($curHit->{'ReferenceUpDown'} eq "U") {
			$start = $curHit->{'ReferenceRelativePosition'} - $upstreamLengthReference{$locusFullName};
		} else {
			$start = $curHit->{'ReferenceRelativePosition'};
		}
		$end = $start + $curHit->{'Length'};
		
		foreach my $curCNS (keys %CNSforLocus) {
			my $CNSLength = $CNSforLocus{$curCNS}{'End'} - $CNSforLocus{$curCNS}{'Start'};

			if (overlap($CNSforLocus{$curCNS}{'Start'}, $CNSforLocus{$curCNS}{'End'},$start, $end)) {

				my $startInCNS = max(0, $start - $CNSforLocus{$curCNS}{'Start'});
				my $endInCNS = min($CNSLength , $end - $CNSforLocus{$curCNS}{'Start'});

				my $startCNSInAlignment = max(0, $CNSforLocus{$curCNS}{'Start'} - $start);

				my $cnsHitSeq = substr($curHit->{'TargetSequence'}, $startCNSInAlignment, $endInCNS - $startInCNS);

				### Calculate insertsions
				my $untrimmedSequence = substr($curHit->{'UntrimmedSequence'}, 0, $startCNSInAlignment);
				my $insertions = $untrimmedSequence =~ tr/Z//;

				# Change N back to gaps
				$cnsHitSeq =~ s/N/-/g;

				push @{ $mapAlignmentDeepCNS{$curCNS}{$curSpecies} }, {
						"ReferenceLocus" => $curCNS,
						"ReferenceRelativePosition" => $startInCNS,
						"ReferenceUpDown" => $curHit->{'ReferenceUpDown'},
						"Length" => length($cnsHitSeq),
						"TargetSpecies" => $curHit->{'TargetSpecies'},
						"TargetLocus" => $curHit->{'TargetLocus'},
						"TargetSequence" => $cnsHitSeq,
						"TargetStrand" => $curHit->{'TargetStrand'},
						"TargetPosition" => $curHit->{'TargetPosition'} + $startCNSInAlignment + $insertions }; 
				if(! (defined $familySpeciesHittingCNS{$curCNS}{$curSpecies}) ) {
					$CNSforLocus{$curCNS}{'NumberOfSpecies'}++;
					$CNSforLocus{$curCNS}{'NumberOfFamilySpecies'}++;

					$familySpeciesHittingCNS{$curCNS}{$curSpecies} = 1;
				}
			}
		}
	}
}

#################################################################
##### Now search for deep CNS (outside the family)
#####

open (my $genomeDatabase, "<", $genomedbFile);

my %deepAlignmentQualityForSpecies;

while(<$genomeDatabase>) {
	chomp;
	my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx) = split /,/;

	if(substr($curgenomeName,0,1) ne "#" && $curgenomeFamily ne $referenceGenomeFamily) { #if this is not a comment and outside the family
 
		### get ortholog sequences
		my $orthologFileName = "$genomeDir/$curgenomeFamily/$referenceGenome.$curgenomeName.orthologs.csv";
		my $orthologFileFound = open (my $orthologFile, "<", $orthologFileName);
		
		if(!$orthologFileFound && !$skipMissingGenomes) { die "ERROR: Can't open ortholog file $orthologFileName. Did you run processGenomes for this reference genome?\n"; }
		
		if($orthologFileFound && -e "$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz" && -e "$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz") {
			while(my $orth_line = <$orthologFile>) {
				chomp($orth_line);
				(my $curPutativeOrtholog, my $curRefLocus, my $score) = split /,/,$orth_line;
				if($curRefLocus eq $locusFullName && $curPutativeOrtholog ne $curRefLocus) {
					my $upstreamFastaName ="$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.up.fasta";
					my $downstreamFastaName = "$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.down.fasta";
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz", $curPutativeOrtholog, $upstreamFastaName);
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz", $curPutativeOrtholog, $downstreamFastaName);

					my $MAFUpFileName = "$locus.$curPutativeOrtholog.up.maf";
					my $MAFDownFileName = "$locus.$curPutativeOrtholog.down.maf";
					system("lastz --format=maf $lastzParametersGlobal $ancesteralLocusCNSFileName" . "[multiple] $upstreamFastaName > $MAFUpFileName");
					my $upQuality = getMAFQuality($MAFUpFileName);
					system("lastz --format=maf $lastzParametersGlobal $ancesteralLocusCNSFileName" . "[multiple] $downstreamFastaName > $MAFDownFileName");
					my $downQuality = getMAFQuality($MAFDownFileName);
						
					#############################################################
					if($upQuality+$downQuality > $minQuality) {
						if($verbose) {
							print "PROGRESS: Found deep CNS hit ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: " . ($upQuality+$downQuality) . ".\n";
						}
						## If this alignment is superior to existing alignment for the same species, delete the previous alignment and replace with current one. If not, just ignore alignment.
						$deepAlignmentQualityForSpecies{$curgenomeSpecies}{$curgenomeName} += $upQuality + $downQuality;

						### Log alignment to fasta, but only if long enough (covers more than minCNSCoverage of the CNS)							
						MAFtoFASTA($MAFUpFileName,  \%cnsReferenceLength, $regulatoryRegionLengthDatabase{$curgenomeName}{'upstreamLength'} , \%deepCNSFasta, \%mapAlignmentDeepCNS, "U",$minCNSCoverageInitial);
						MAFtoFASTA($MAFDownFileName,  \%cnsReferenceLength, $regulatoryRegionLengthDatabase{$curgenomeName}{'downstreamLength'} , \%deepCNSFasta, \%mapAlignmentDeepCNS, "D",$minCNSCoverageInitial);
					}

				if(!$keep_tmp) {
					unlink($upstreamFastaName);
					unlink($downstreamFastaName);
					unlink($MAFUpFileName);
					unlink($MAFDownFileName);
				}					
		}
	 }
	close($orthologFile);
	}
  }
}
close ($genomeDatabase);
  
if(!$keep_tmp) {
	unlink($ancesteralLocusCNSFileName);
}

###########################################################################################################
########################### BEGIN FILTERING DEEP CNS ######################################################

## Filter for confilicting multiple genomes for species
## If we have a species with multiple genome hits, pick the best one

for my $curSpecies (keys %deepAlignmentQualityForSpecies) {
	my @alignmentGenomes = keys %{ $deepAlignmentQualityForSpecies{$curSpecies} };

	if( (scalar @alignmentGenomes)  > 1 ) { ### We have more than one genome hit for this species, leave only the first one.
		my @alignmentScores = values %{ $deepAlignmentQualityForSpecies{$curSpecies} };
		my $bestAlignmentScore = max( @alignmentScores );
		my $foundBest=0;
		## now delete all the other genomes
		for my $curAlignmentGenome (keys %{ $deepAlignmentQualityForSpecies{$curSpecies}}) {
			if ($deepAlignmentQualityForSpecies{$curSpecies}{$curAlignmentGenome} == $bestAlignmentScore && !$foundBest) {
				$foundBest=1;
			} else {
				if($verbose) { print "PROGRESS: Removing hits for genome $curAlignmentGenome because better hit was found for species $curSpecies ($bestAlignmentScore).\n"; }
				for my $curCNS (keys %mapAlignmentDeepCNS) {
					if(defined $mapAlignmentDeepCNS{$curCNS}{$curSpecies}) {
						my @alignmentsToCNS = @{ $mapAlignmentDeepCNS{$curCNS}{$curSpecies}};
						my @newAlignmentsToCNS;
						for my $curAlignment (@alignmentsToCNS) {
							if($curAlignment->{'TargetGenome'} ne $curAlignmentGenome) {
								push (@newAlignmentsToCNS, $curAlignment);
							} else {
#								if($verbose) { print "DEBUG: Removing hit $curAlignmentGenome to $curCNS.\n"; }
							}
						}
						$mapAlignmentDeepCNS{$curCNS}{$curSpecies} = \@newAlignmentsToCNS;
					}
				}
			}
		}
	}
}

###########################################################################################################
#### Filter Family CNSs that have too few hits

if($verbose) { print "PROGRESS: Filtering family CNS.\n"; }
my @speciesInReferenceFamily = keys %{$speciesDatabase{$referenceGenomeFamily}};
for my $curCNS (keys %mapAlignmentDeepCNS) {
	my @curCNSFamSpecies = keys %{ $familySpeciesHittingCNS{$curCNS}};
	if((scalar @curCNSFamSpecies) <  $minFamilySpeciesForCNS * (scalar @speciesInReferenceFamily)) {
		if($verbose) { print "PROGRESS: Removing CNS $curCNS because number of species in family is too low (" . scalar @curCNSFamSpecies . " out of " . (scalar @speciesInReferenceFamily) .")\n"; }
		delete $mapAlignmentDeepCNS{$curCNS};
		delete $cnsReferenceLength{$curCNS};
		delete $CNSforLocus{$curCNS};
	}
}

############################################################################################################
# Family CNS are not all deeply conserved. See if we can identify conserved regions within the CNS
#  then split the CNS accordingly

# First, determine what are the breakpoints
foreach my $curCNS (keys %mapAlignmentDeepCNS) {
	my $CNSLength = $cnsReferenceLength{$curCNS};
	my @CNShitsSpecies =  keys %{ $mapAlignmentDeepCNS{$curCNS} };
	my @CNShits;


	for my $curSp (@CNShitsSpecies) {
		push @CNShits, @{ $mapAlignmentDeepCNS{$curCNS}{$curSp} };
	}

	my $CNSBreakpointsRef = getCNSbreakpoints($CNSLength, \@CNShits , $minCNSLength);
	my @CNSBreakpoints = @$CNSBreakpointsRef;

	### If we have breakpoints, break the CNS, polish and reassign all hits
	if(@CNSBreakpoints >2) {
		if($verbose) { print "PROGRESS: Breaking CNS $curCNS. Length: $CNSLength. Breakpoints: " . join(",", @CNSBreakpoints) . "\n"; }
		my $polishedAlignmentsRef = polishCNSAlignments(\@CNSBreakpoints, \@CNShits, $minCNSConservationAfterSplit, $minCNSLength);
		my @polishedAlignments = @$polishedAlignmentsRef;

		for my $curBreakpoint (0.. ((scalar @CNSBreakpoints) - 2)) {
			### Create a new sub-CNS
			my $newSubCNSName = "$curCNS.$CNSBreakpoints[$curBreakpoint]";

			## Build the CNS
			my ($newAbsStart, $newAbsEnd);
			if($CNSforLocus{$curCNS}{'Strand'} eq "+" ) {
				$newAbsStart = $CNSforLocus{$curCNS}{'absStart'} + $CNSBreakpoints[$curBreakpoint];
				$newAbsEnd = $CNSforLocus{$curCNS}{'absStart'} + $CNSBreakpoints[$curBreakpoint+1]-1;
			} else {
				$newAbsStart = $CNSforLocus{$curCNS}{'absEnd'} - $CNSBreakpoints[$curBreakpoint+1];
				$newAbsEnd = $CNSforLocus{$curCNS}{'absEnd'} - $CNSBreakpoints[$curBreakpoint]-1;
			}

			$CNSforLocus{$newSubCNSName} = {
				'Name' => $newSubCNSName,
				'Start' => $CNSforLocus{$curCNS}{'Start'} + $CNSBreakpoints[$curBreakpoint],
				'End' => $CNSforLocus{$curCNS}{'Start'} + $CNSBreakpoints[$curBreakpoint+1]-1,
				'PositionInCompositeCNS' => $CNSBreakpoints[$curBreakpoint],				
				'Locus' => $CNSforLocus{$curCNS}{'Locus'},
				'Chromosome' => $CNSforLocus{$curCNS}{'Chromosome'},
				'absStart' => $newAbsStart,
				'absEnd' => $newAbsEnd,
				'Strand' => $CNSforLocus{$curCNS}{'Strand'},
				'NumberOfSpecies' => 0,
				'NumberOfFamilySpecies' => 0,
				'ConservationLevel' => $CNSforLocus{$curCNS}{'ConservationLevel'},
				'ORF' => $CNSforLocus{$curCNS}{'ORF'},
				'ORFDir' => $CNSforLocus{$curCNS}{'ORFDir'},
				'omega' => $CNSforLocus{$curCNS}{'omega'},
				'ancesteralSequence' => substr($CNSforLocus{$curCNS}{'ancesteralSequence'}, $CNSBreakpoints[$curBreakpoint], $CNSBreakpoints[$curBreakpoint+1] - $CNSBreakpoints[$curBreakpoint]),
				'referenceSequence' => substr($CNSforLocus{$curCNS}{'referenceSequence'}, $CNSBreakpoints[$curBreakpoint], $CNSBreakpoints[$curBreakpoint+1] - $CNSBreakpoints[$curBreakpoint])
			};
			$cnsReferenceLength{$newSubCNSName} = $CNSBreakpoints[$curBreakpoint+1] - $CNSBreakpoints[$curBreakpoint] ;

			my $numberOfHitsReassigned=0;
			## Reassign deep alignments
			foreach my $curHit (@polishedAlignments) {
				### If there is an overlap, assign the deep CNS to the new subCNS.

				if($cnsReferenceLength{$newSubCNSName} ==0) { print "ERROR: $newSubCNSName has length 0.\n"; }
				if(overlap($CNSforLocus{$newSubCNSName}{'PositionInCompositeCNS'}, $CNSforLocus{$newSubCNSName}{'PositionInCompositeCNS'} + $cnsReferenceLength{$newSubCNSName},
						   $curHit->{'ReferenceRelativePosition'}, $curHit->{'ReferenceRelativePosition'} + $curHit->{'Length'})>$minCNSCoverageAfterSplit) {

					if(not defined $mapAlignmentDeepCNS{$newSubCNSName}{ $curHit->{'TargetSpecies'} }) {
						$mapAlignmentDeepCNS{$newSubCNSName}{ $curHit->{'TargetSpecies'} } = [];
					}
					my $newSubCNSTargetSequence = substr($curHit->{'TargetSequence'}, max(0, $CNSforLocus{$newSubCNSName}{'PositionInCompositeCNS'} - $curHit->{'ReferenceRelativePosition'}),  min($curHit->{'Length'}, $cnsReferenceLength{$newSubCNSName}));

					push @{ $mapAlignmentDeepCNS{$newSubCNSName}{ $curHit->{'TargetSpecies'} } }, {
							"ReferenceLocus" => $newSubCNSName,
							"ReferenceRelativePosition" => max( 0, $curHit->{'ReferenceRelativePosition'} - $CNSforLocus{$newSubCNSName}{'PositionInCompositeCNS'}) ,
							"ReferenceUpDown" => $curHit->{'ReferenceUpDown'},
							"Length" => length($newSubCNSTargetSequence),
							"TargetSpecies" => $curHit->{'TargetSpecies'},
							"TargetLocus" => $curHit->{'TargetLocus'},
							"TargetSequence" => $newSubCNSTargetSequence,
							"TargetStrand" => $curHit->{'TargetStrand'},							
							"TargetPosition" => $curHit->{'TargetPosition'} + $CNSBreakpoints[$curBreakpoint] }; 
					$numberOfHitsReassigned++;
				}
			}
			if($verbose) { print "PROGRESS: Sub CNS $newSubCNSName (Length:$cnsReferenceLength{$newSubCNSName}) has $numberOfHitsReassigned deep alignments.\n"; }
			### If the new split CNS has little support, delete it
			my $numberOfConservedBasesInCNS=0;
			my $CNSLength = $CNSforLocus{$newSubCNSName}{'End'} - $CNSforLocus{$newSubCNSName}{'Start'};
			if($CNSforLocus{ $newSubCNSName}{'Start'} < 0) {   ### If it's upstream
				my $startInPhyloPMap = $CNSforLocus{$newSubCNSName}{'Start'} + $upstreamLengthReference{$locusFullName};
				foreach my $curBase ( @phyloPconservationMapUp[ ($startInPhyloPMap)..($startInPhyloPMap+ $CNSLength) ] )  { if($curBase>= $minPhyloPscore) { $numberOfConservedBasesInCNS++; } }
			} else {
				my $startInPhyloPMap = $CNSforLocus{$newSubCNSName}{'Start'};
				foreach my $curBase ( @phyloPconservationMapDown[ ($startInPhyloPMap)..($startInPhyloPMap+ $CNSLength) ] )  { if($curBase>= $minPhyloPscore) { $numberOfConservedBasesInCNS++; } }
			}
			if($numberOfConservedBasesInCNS / $CNSLength < $minCNSConservationAfterSplit) {
				if($verbose) { print "PROGRESS: Removing $newSubCNSName because number of conserved bases is $numberOfConservedBasesInCNS out of $CNSLength.\n"; }
				delete $CNSforLocus{$newSubCNSName};
				delete $mapAlignmentDeepCNS{$newSubCNSName};
				delete $cnsReferenceLength{$newSubCNSName};
			}			
		}
		### Finally, delete the original CNS
		delete $mapAlignmentDeepCNS{$curCNS};
		delete $cnsReferenceLength{$curCNS};
		delete $CNSforLocus{$curCNS};
	}
}


#####################################################################
## Filter CNS for unlikely and sporious alignments
## Then classify the conservation level of the CNS 

### Filter CNSs hits that have too little coverage

foreach my $curCNS (keys %mapAlignmentDeepCNS) {
	foreach my $curSpeciesAlignment (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
		my @filteredAlignmentsForCNS;
		foreach my $curAlignment ( @{ $mapAlignmentDeepCNS{$curCNS}{$curSpeciesAlignment}}) {
			if( $curAlignment->{'Length'} / ($CNSforLocus{$curCNS}{'End'} - $CNSforLocus{$curCNS}{'Start'})  > $minCNSCoverageFinal) {
				push @filteredAlignmentsForCNS, $curAlignment;
			} else {
				if($verbose) { print "PROGRESS: Removing hit of $curAlignment->{'TargetLocus'} to $curCNS because overlap is too low.\n"; }
			}
		}
		if(scalar @filteredAlignmentsForCNS > 0) {
			$mapAlignmentDeepCNS{$curCNS}{$curSpeciesAlignment} = \@filteredAlignmentsForCNS;
		} else {
			delete $mapAlignmentDeepCNS{$curCNS}{$curSpeciesAlignment};
		}
	}
}


### Filter CNSs that switch position (up to downstream)

if(!$noPositionFilter) {
	my $spToDelete;
	foreach my $curCNS (keys %mapAlignmentDeepCNS) {
		foreach my $curSpeciesAlignment (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
			$spToDelete = "";
			foreach my $curAlignment ( @{ $mapAlignmentDeepCNS{$curCNS}{$curSpeciesAlignment} } ) {
				if(($CNSforLocus{$curCNS}{'Start'}<0) && ($curAlignment->{'TargetPosition'} >0)) {
					$spToDelete = $curSpeciesAlignment;
				}
				if(($CNSforLocus{$curCNS}{'Start'}>0) && ($curAlignment->{'TargetPosition'} <0)) {
					$spToDelete = $curSpeciesAlignment;
				}
				if($spToDelete ne "") {
					if($verbose) { print "PROGRESS: Deleting alignment of $curSpeciesAlignment to $curCNS because of mismatched positions. Target position: " . $curAlignment->{'TargetPosition'} . ".\n"; }
				}
			}
			if($spToDelete ne "") {
				delete $mapAlignmentDeepCNS{$curCNS}{$curSpeciesAlignment};
			}
		}
	}
}

##### Filter CNS that are too distant evolutionary without sufficient support

foreach my $curCNS (keys %mapAlignmentDeepCNS) {
  my @CNSConservationLevel= ( (0) x $CLASSIFICATION_CLASSES_NUM );	 
  my $numberOfDeepSpecies = scalar (keys %{ $mapAlignmentDeepCNS{$curCNS} });
  my $numberOfSpecies = $numberOfDeepSpecies + $CNSforLocus{$curCNS}{'NumberOfFamilySpecies'};
  $CNSforLocus{$curCNS}{'NumberOfSpecies'} = $numberOfSpecies;

  #### Now calculate conservation levels
  foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
  	  my @classification = split /-/ , $speciesClassification{$curSpecies};
    	foreach my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {	
    	 	if($referenceClassification[$curClassificationLevel] ne $classification[$curClassificationLevel]) {
    	 	 	$CNSConservationLevel[$curClassificationLevel]++;
    	 	}
    	}
  }
  if($verbose) { print "PROGRESS: Testing CNS $curCNS. $numberOfDeepSpecies species have the CNS. Conservation levels are (" . join(",",@CNSConservationLevel) .").\n"; }
  	  
  # check for possible misalignments by making sure we are not skipping levels.
  	  
  foreach my $levelToCheck ( 1..($CLASSIFICATION_CLASSES_NUM-1)) {
   	  if(($CNSConservationLevel[$levelToCheck] == $CNSConservationLevel[$levelToCheck+1] && $CNSConservationLevel[$levelToCheck]==1)
	  	  || $numberOfDeepSpecies < $minSpeciesPerConservationLevel[$levelToCheck]
		  || $CNSConservationLevel[$levelToCheck] < $minSpeciesAtConservationLevel[$levelToCheck]) {
   	  	  if($verbose && $CNSConservationLevel[$levelToCheck]>0) { print "PROGRESS: Found possible sporious alignment for $curCNS at level " . ($CLASSIFICATION_CLASSES_NUM-$levelToCheck) . ".\n"; }

  	  	  if($verbose && ($numberOfDeepSpecies < $minSpeciesPerConservationLevel[$levelToCheck] && $CNSConservationLevel[$levelToCheck]>0)) {
			print "PROGRESS: Number of species too low to support alignments at level " . ($CLASSIFICATION_CLASSES_NUM-$levelToCheck) . ".\n";
		}
  	  	  ### Remove the misalignment
		  foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
		  	  my @classification = split /-/ , $speciesClassification{$curSpecies};
		  	  if($classification[$levelToCheck] ne $referenceClassification[$levelToCheck]) {
  	  	  	  	if($verbose) { print "PROGRESS: Removing alignment of $curSpecies for $curCNS.\n"; }
				delete ($mapAlignmentDeepCNS{$curCNS}{$curSpecies});
				$numberOfDeepSpecies--;
			  }
		  }
  	  }
  }
  ### Recalculate conservation levels after filtering
  @CNSConservationLevel= ( (0) x $CLASSIFICATION_CLASSES_NUM );	  

  foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
  	  my @classification = split /-/ , $speciesClassification{$curSpecies};
    	foreach my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {	
    		if($referenceClassification[$curClassificationLevel] ne $classification[$curClassificationLevel]) {
    			$CNSConservationLevel[$curClassificationLevel]++;  
    	 	 }
   	  }
  }
	
  # Now mark the "Deepness" level of each CNS
  $CNSforLocus{$curCNS}{'ConservationLevel'}= $referenceGenomeFamily;
  foreach my $curLevel (0..$CLASSIFICATION_CLASSES_NUM) {
  	  if($CNSforLocus{$curCNS}{'ConservationLevel'} eq $referenceGenomeFamily && $CNSConservationLevel[$curLevel]>0) {
  	  	  $CNSforLocus{$curCNS}{'ConservationLevel'}= $referenceClassification[$curLevel-1] ;
  	  }
  }

  ### And recount the number of species
  my @newSpeciesCount = keys %{ $mapAlignmentDeepCNS{$curCNS} };
  $CNSforLocus{$curCNS}{'NumberOfSpecies'} = scalar @newSpeciesCount;
}
  
if($verbose) { print "PROGRESS: End analysis for $referenceGenome:$locus. Writing output files...\n";	}
 
###########################################################
#### Now we are done. Export CNS table and position maps  
  
open(my $finalCNSFile, ">$finalCNSFileName");
open (my $finalMapFile, ">$finalMapFileName");
foreach my $curCNS (keys %CNSforLocus) {
	print $finalCNSFile "$referenceGenome,$curCNS,$CNSforLocus{$curCNS}{'Chromosome'},$CNSforLocus{$curCNS}{'Strand'},$CNSforLocus{$curCNS}{'absStart'},$CNSforLocus{$curCNS}{'absEnd'},$CNSforLocus{$curCNS}{'Locus'},$CNSforLocus{$curCNS}{'Start'},$CNSforLocus{$curCNS}{'End'},$CNSforLocus{$curCNS}{'ConservationLevel'},$CNSforLocus{$curCNS}{'NumberOfSpecies'},$CNSforLocus{$curCNS}{'ORF'},$CNSforLocus{$curCNS}{'ORFDir'},$CNSforLocus{$curCNS}{'omega'},$CNSforLocus{$curCNS}{'ancesteralSequence'}\n";
  	print $finalMapFile "$curCNS,$referenceGenomeSpecies,$locusFullName,$CNSforLocus{$curCNS}{'Start'},+,0," . ($CNSforLocus{$curCNS}{'End'} - $CNSforLocus{$curCNS}{'Start'}) . "," . $CNSforLocus{$curCNS}{'referenceSequence'} . "\n";
} 
close($finalCNSFile);
 
### Then the CNS alignments
foreach my $curCNS (keys %CNSforLocus) {
	foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {	  	   	  	  
		foreach my $curHit ( @{ $mapAlignmentDeepCNS{$curCNS}{$curSpecies} } ) {
			print $finalMapFile "$curCNS,$curSpecies,$curHit->{'TargetLocus'},$curHit->{'TargetPosition'},$curHit->{'TargetStrand'},$curHit->{'ReferenceRelativePosition'},$curHit->{'Length'},$curHit->{'TargetSequence'}\n";
		}
    }
}
 	
close($finalMapFile);

#### Go back to the original directory, and we are done!
chdir $curDir;	

if($verbose) { print "DONE: End $referenceGenome:$locus.\n";	}

###############################################################################################################################
###############################################################################################################################
###############################################################################################################################
#####################################                END                     ##################################################
###############################################################################################################################
###############################################################################################################################
###############################################################################################################################


################################################################################
###### utility functions #######################################################

####################################################################################################################################
#### Extract sequence for locus from a compressed fasta file, filter for low-information sequence and output to a seperate fasta file
####    and return the filtered sequence

sub extractFastaToFile {
	(my $fastaFile, my $locus, my $outputFastaFile) = @_;

	open (my $inFasta, "samtools faidx $fastaFile $locus |");
	my $fastaHeader = <$inFasta>;
	chomp($fastaHeader);
	my $seq;
	my @seqLines;
	while(my $curLine = <$inFasta>) {
		chomp($curLine);
		push @seqLines, $curLine;
	}
	close($inFasta);
	$seq = join("", @seqLines);

	my $origSeq = $seq;
	### Now mask homopolymers and AT rich regions
	$seq = fuzzyFilterHomopolymers($seq,$homoPolymerFilterLength,0);  
	$seq = fuzzyFilterATRich($seq,$atRichRegionFilterLength,0, $atRichRegionFilterFlankLength); 
	$seq = fuzzyFilterDimers($seq, $dimerPolymerFilterLength,0);

	### and repeating common trimers
	$seq =~ s/([C|G|A]TT){4}/XXXXXXXXXXXX/g;
	$seq =~ s/([C|G|A]AA){4}/XXXXXXXXXXXX/g;
	$seq =~ s/([C|G|A]AT){4}/XXXXXXXXXXXX/g;

	#### and repeating tetramers
	$seq =~ s/(TCTA){4}/XXXXXXXXXXXXXXXX/g;
	### and ambigious sequences
	$seq =~ s/N/$filterCharacter/g;

	## and write to file
	open(my $outFasta, ">$outputFastaFile");
	print $outFasta "$fastaHeader\n$seq\n";
	close($outFasta);

	return ($seq);
}

##### Fuzzy filter homopolymers

### fuzziness is the number of mismatch positions allowed (either 0 or 1)
sub fuzzyFilterHomopolymers {
	my ($inSeq, $polymerLength, $fuzziness) = @_;
	my @inSeqArr = split //, $inSeq;
	my @polymers = ('A' x $polymerLength,
					'T' x $polymerLength,
					'C' x $polymerLength,
					'G' x $polymerLength);

	my $fuzzySearchString="(?=($polymers[1]";
	my @replacementArr = ($filterCharacter) x $polymerLength;

	for my $curPolymer (@polymers) {
		if($fuzziness == 1) {
			for my $curNuc (1..$polymerLength) {
				my $curSearch = $curPolymer;
				substr($curSearch,$curNuc-1,1) = ".";
				$fuzzySearchString .= "|$curSearch"
			}
		} else {
			$fuzzySearchString .= "|$curPolymer";
		}
	}
	$fuzzySearchString .= "))";
	
	my @polymerOccurences;
	$_ = $inSeq;

	while(/$fuzzySearchString/g) {
		push @polymerOccurences, pos();
	}
	foreach my $curPos (@polymerOccurences) {
		@inSeqArr[$curPos..($curPos+($polymerLength-1))] = @replacementArr;
	}

	return join("", @inSeqArr);
}

##### Fuzzy filter for repeating dimers sequences
## Fuzziness is 0 or 1 (number of mismatches accepted)
sub fuzzyFilterDimers {
	my ($inSeq, $polymerLength, $fuzziness) = @_;
	my @inSeqArr = split //, $inSeq;
	my @replacementArr = ($filterCharacter) x ($polymerLength * 2);
	my @dimerPolymers;

	for my $nuca ( ('A','T','C','G')) {
		for my $nucb ( ('A','T','C','G')) {
			if($nuca ne $nucb) {
				push @dimerPolymers, ("$nuca$nucb" x $polymerLength);
			}
		}
	}

	my $fuzzySearchString="(?=($dimerPolymers[1]";

	for my $curPolymer (@dimerPolymers) {
		if($fuzziness==1) {
			for my $curNuc (1..($polymerLength*2-1)) {
				my $curSearch = $curPolymer;
				substr($curSearch,$curNuc-1,1) = ".";
				$fuzzySearchString .= "|$curSearch"
			}
		} else {
				$fuzzySearchString .= "|$curPolymer"
		}
	}
	$fuzzySearchString .= "))";

	## Now collected all the places where there is a match (accepting overlapping regions)
	my @dimerOccurences;
	$_ = $inSeq;

	while(/$fuzzySearchString/g) {
		push @dimerOccurences, pos();
	}

	## Now mask Seq
	foreach my $curPos (@dimerOccurences) {
		@inSeqArr[$curPos..($curPos+($polymerLength*2-1))] = @replacementArr;
	}

	return join("", @inSeqArr);
}

########################################################################################
### Fuzzy filter AT rich regions
###

sub fuzzyFilterATRich {
	my ($inSeq, $ATrichLength, $fuzziness, $flanklength) = @_;
	my @replacementArr = ($filterCharacter) x ($ATrichLength - $flanklength*2);

	my $translatedInSeq = $inSeq;
	$translatedInSeq =~ tr/ATCGXN/001111/;

	my @inSeqArr = split //, $inSeq;
	my @inSeqTrArr = split //, $translatedInSeq;
	my $seqLength = (scalar @inSeqArr)-$ATrichLength-1;
	my @ATrichPos;

	## Look for AT rich positions
	foreach my $curPos (0..$seqLength) {
		if(sum(@inSeqTrArr[$curPos..($curPos+$ATrichLength-1)])<=$fuzziness) {
			push @ATrichPos, $curPos;
		}
	}
	## Now mask Seq
	foreach my $curPos (@ATrichPos) {
		@inSeqArr[($curPos+$flanklength)..($curPos+$ATrichLength-1-$flanklength)] = @replacementArr;
	}

	return join("", @inSeqArr);

	return($inSeq);
}


### Get the overall quality score from a MAF alignment file
sub getMAFQuality {
	my ($MAFFileName) = @_;

	open (my $m, $MAFFileName);
	my $maf = Bio::AlignIO->new(-fh => $m, -format => 'maf');
	my $quality =0;
	while(my $aln = $maf->next_aln()) {
		$quality = $quality + $aln->score;
	}
	close($m);
	return $quality;
}

#####################################################################
### Run the sequence alignment without terminal output
sub quietAlign {
	my ($toalign) = @_;
	######### Muscle alignment
	my $aligner = Bio::Tools::Run::Alignment::Muscle->new(('quiet' => 1, 'max_iter' => 2, 'diags' => 1));
	my $alignment = $aligner->align($toalign);

	return $alignment;
}


################### Load MAF file and return a FASTA array in reference coordinates
# alignmentLengthFilter is a number 0-1 indicating what is the minimum overlap (in percent) of the alignment to the reference species
#  to consider as a real alignment.
#

sub MAFtoFASTA {
	(my $mafFileName, my $seqLengthRef, my $targetSeqLength, my $inFASTARef,my $mapRef, my $dir, my $alignmentLengthFilter) = @_;
	
	my $refseqname;
	my $reflocus;
	my $refstart = -1;
	my $reflen;
	my @insertions;
	my @cleanAlignments;

	my $maffile = Bio::AlignIO->new(-file => $mafFileName,
					-format => "maf") || die ("");


	# First clean up the MAF file. If we have multiple alignments to the same place, pick just the best one
	my $overlappingSource;
	while(my $curAln = $maffile->next_aln) {
		#check to see if we overlap something
		my $source = $curAln->get_seq_by_pos(1);
		my $target = $curAln->get_seq_by_pos(2);
		$overlappingSource=0;
		for my $curAlignmentNum (0..(@cleanAlignments-1)) {
			my $scannedAln = $cleanAlignments[$curAlignmentNum];
			my $scanSource = $scannedAln->get_seq_by_pos(1);
			my $scanTarget = $scannedAln->get_seq_by_pos(2);
			if(($target->id() eq $scanTarget->id()) && 
			( overlap($scanSource->start, $scanSource->end, $source->start, $source->end) > $alignmentSeqOverlapToMerge || overlap($source->start, $source->end, $scanSource->start, $scanSource->end) > $alignmentSeqOverlapToMerge ) ) {
				## If the hits are not coming from the same region, pick the best one
				$overlappingSource=1;
				if($curAln->score > $scannedAln->score) {
					$cleanAlignments[$curAlignmentNum] = $curAln;
				}
			}
		}
		if(!$overlappingSource) {
			push @cleanAlignments, $curAln;
		}
	}

	for my $aln (@cleanAlignments) {
	   $reflocus="";
	   $refseqname="";
	   foreach my $alignseq ($aln->each_seq() ) {
	   	   my $locus = $alignseq->id();
	   	   my $species = geneToSpecies($locus);
		   my $genome = geneToGenome($locus);
	   	   my $newspseq = $alignseq->seq();
		   my $strand = $alignseq->strand();
		   ## Translate strand codes
		   if($strand == -1) {
		   		$strand = "-";
		   } else {
			$strand = "+";
		   }
	   	   
		   if($refseqname eq "") {
			 $refseqname = $species;
			 $reflocus=$locus;
		   }

		   if(not defined $inFASTARef->{$reflocus}{$species}) {
		       $inFASTARef->{$reflocus}{$species} = "N" x $seqLengthRef->{$reflocus};
		   }

		   if($species eq $refseqname) {
	   		 # Identify all insertions from the sequence to keep the seq in reference coordinates		 
		   	 @insertions = findAll($newspseq, "-");
		   }

   		   #now remove the insertions
   		   foreach ( @insertions ) {
   		   	   substr($newspseq, $_,1) = "Z";
   		   }
   		   
		   ### Replace all gaps with N because phyloP doesn't like gaps.
#		   $newspseq =~ s/-/N/g;

		   my $untrimmedSequence = $newspseq;
		   $newspseq =~ s/Z//g;
		   
		   if($refstart == -1) {
		   		$refstart = $alignseq->start()-1;
				$reflen = length($newspseq);
		   } else {

			
			#### Log the alignment, if it is at the right length
			if($verbose && $alignmentLengthFilter >0 &&  $reflen < $alignmentLengthFilter*$seqLengthRef->{$reflocus} && $reflen < $minAlignmentLengthToTestOverlap) {
				print "PROGRESS: Rejected alignment to $reflocus because length is too short ($reflen). CNS length: " . $seqLengthRef->{$reflocus} . "\n";
			} 
			if($alignmentLengthFilter==0 || $reflen >= $alignmentLengthFilter*$seqLengthRef->{$reflocus} ) {
				my $refRelative, my $targetRelative;
				$refRelative = $refstart;
				if($dir eq "U") {
					$targetRelative = $alignseq->start() -1 - $targetSeqLength;
				} else {
					$targetRelative = $alignseq->start() - 1;
				}
				if(not defined $mapRef->{$reflocus}{$species}) {
					$mapRef->{$reflocus}{$species} = [];
				}
				my $targetSequence = $newspseq;
				$targetSequence =~ s/N//g;

				push @{ $mapRef->{$reflocus}{$species} }, {
					"ReferenceLocus" => $reflocus,
					"ReferenceRelativePosition" => $refRelative,
					"ReferenceUpDown" => $dir,
					"Length" => $reflen,
					"TargetGenome" => $genome,
					"TargetStrand" => $strand,
					"TargetSpecies" => $species,
					"TargetLocus" => $locus,
					"TargetPosition" => $targetRelative,
					"TargetSequence" => $newspseq,
					"UntrimmedSequence" => $untrimmedSequence}; 
			}
		   		# Check if we are overriding sequences
		   		my $curspseq = substr($inFASTARef->{$reflocus}{$species}, $refstart, $reflen);
		   		if( $curspseq eq  "N" x length($curspseq)) {
			   		my $tmpseq = $inFASTARef->{$reflocus}{$species};
		   	   		substr($tmpseq, $refstart, $reflen) = $newspseq;
			   		$inFASTARef->{$reflocus}{$species} = $tmpseq;
		   		} else {
				# if there was something there, merge the sequences
				if(substr($inFASTARef->{$reflocus}{$species}, $refstart, $reflen) ne $newspseq) {
					
					my $curseq = substr($inFASTARef->{$reflocus}{$species}, $refstart, $reflen);
					my $refseq = substr($inFASTARef->{$reflocus}{$refseqname}, $refstart, $reflen);
					my $conseq;
					for my $curchr (0 .. $reflen) {
						my $selectedMergedNuc;
						# if one is a gap, pick the nucleotide
						if(substr($curseq, $curchr,1) eq "N") {
							$selectedMergedNuc = substr($newspseq,$curchr,1);
						} elsif (substr($newspseq, $curchr,1) eq "N") {
							$selectedMergedNuc = substr($curseq,$curchr,1);
						} else { #if we have a conflict - pick the one that is similar to the reference (### Pick the first one)
							if((substr($curseq,$curchr,1) eq substr($refseq,$curchr,1)) || (substr($curseq,$curchr,1) eq substr($refseq,$curchr,1))) {
								$selectedMergedNuc = substr($curseq,$curchr,1);
							} else {
								$selectedMergedNuc = substr($curseq,$curchr,1); # or if not, the default is the first one.
							}
						}
						$conseq .= $selectedMergedNuc;
					}
					my $tmpseq = $inFASTARef->{$reflocus}{$species};
					substr($tmpseq, $refstart, $reflen) = $conseq;
			   		$inFASTARef->{$reflocus}{$species} = $tmpseq;
				}
			}
		}
	   }
	   $refstart = -1;
	}
}

#####################################################################
##### Pick best ortholog

sub pickBestPutativeOrthologs {
	
	my (%orthologs) = @_;

	foreach my $curOrthSpecies (keys %orthologs) {
		# first, check if we have a consistent duplication. if not, pick the best alignment.
		# For consistent duplication it means that the number of genes is a multiple of the number of species.
		# if so, pick the best duplication group
		my @genomeNames;
		my @qScores;
		foreach my $curOrth (@{ $orthologs{$curOrthSpecies} }) {	
			my %derefCurOrth = %$curOrth; 
			push @genomeNames,  $derefCurOrth{'Genome'};		
			push @qScores, ($derefCurOrth{'UpQuality'} + $derefCurOrth{'DownQuality'}) ;
		}
		
		if( (scalar @{ $orthologs{$curOrthSpecies} }) / (scalar uniq ( @genomeNames )) > 1 ) {

			my @bestOrthologsGroup;
			my $bestQuality =0;
			my @genomesToTest = uniq ( @genomeNames );
			foreach my $curGenomeToTest ( @genomesToTest) {
				my @indexes = grep { @genomeNames[$_] eq $curGenomeToTest } 0 ..(scalar @genomeNames);
				
				my $meanQuality;
				if($orthologSelectionStrategy eq "bestmean") {
					$meanQuality = mean ( @qScores[@indexes] );
				} else {
					$meanQuality = sum ( @qScores[@indexes] );
				}
				if($meanQuality > $bestQuality) {
					$bestQuality = $meanQuality;
					@bestOrthologsGroup = @indexes;
				}
			}
		
			### Remove all temporary files
			foreach my $i (0..((scalar @qScores)-1)) {
				if( !($i ~~ @bestOrthologsGroup)) {
					if(!$keep_tmp) {
						unlink($orthologs{$curOrthSpecies}[$i]->{'upstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'downstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFUpFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFDownFileName'});
					}
				}
			}
			my %tmporth = %orthologs;
			$orthologs{$curOrthSpecies} = [ ];
			foreach my $i (@bestOrthologsGroup) {
				push( @ { $orthologs{$curOrthSpecies} },
					$tmporth{$curOrthSpecies}[$i]);
			}
			if($verbose) { print "PROGRESS: Picked CRE-ortholog for $curOrthSpecies:" . $orthologs{$curOrthSpecies}[0]->{'Genome'} . ".\t" . (scalar @{ $orthologs{$curOrthSpecies} }) . " Genes: ";
					       foreach my $i ( @{ $orthologs{$curOrthSpecies} }) { print $i->{'Name'} . ". "; }
					       print "\n";
			}

		} else {
			#### Only one possible gene. pick the best genome based on alignment quality scores.

			my $topQuality = max( @qScores);
			my $topQualityIdx = firstidx { $_ == $topQuality } @qScores;

			### Remove all temporary files
			foreach my $i (0..((scalar @qScores)-1)) {
				if($i != $topQualityIdx) {
					if(!$keep_tmp) {
						unlink($orthologs{$curOrthSpecies}[$i]->{'upstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'downstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFUpFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFDownFileName'});
					}
				}
			}
			
			## Now remove all the other genes
			$orthologs{$curOrthSpecies} = [ $orthologs{$curOrthSpecies}[$topQualityIdx] ];
			if($verbose) { print "PROGRESS: Picked CRE-ortholog for " . $orthologs{$curOrthSpecies}[0]->{'Genome'} . ".\t1 Gene: " . $orthologs{$curOrthSpecies}[0]->{'Name'} . ".\n"; }
		}
	}
	return %orthologs;
}

