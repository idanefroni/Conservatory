#!/usr/bin/perl

use POSIX;
use strict;
use Text::CSV;
use Data::Dumper qw(Dumper);
use List::Util qw(min max sum);
use List::MoreUtils qw(uniq firstidx);
use Statistics::Basic qw(:all nofill);
use Bio::AlignIO;
use Bio::Align::DNAStatistics;
use Bio::Tools::Run::Alignment::Muscle;
use Bio::Tools::Run::Phylo::PAML::Codeml;
use Bio::Align::Utilities;
use Bio::TreeIO;
use Cwd;
use Cwd 'abs_path';
use Getopt::Long;
use experimental 'smartmatch';
$|=1;

###############################################################################
######### Setup

my $conservatoryDir=abs_path(".");

my $EMPTY_FILE = 0; # The size of an empty MAF file, containing no alignments
my $CLASSIFICATION_CLASSES_NUM=6;  ## The number of phylogeny classification categories in the genome_database file. Currently default is 6 (starts from 0).

my $curDir;
my $locus;
my $locusFullName;
my $referenceGenome;
my $referenceGenomeSpecies;
my $referenceGenomeFamily;

#### Sequence Filtering and parameters
my $homoPolymerFilterLength = 8;
my $homoPolymerFuzzyFilterLength = 12;
my $atRichRegionFilterLength = 10;
my $dimerPolymerFilterLength = 5;
my $filterCharacter = 'X';

##### Alignment parameters
my $minIdentityFamily= 70;
my $minIdentityGlobal= 70;
my $minQuality = 1000;

### PhyloP parameters and CNS filtering parameters
my $minPhyloPscore=1.7;
my $minCNSLength=8;
my $CNSMergeLength=15;   # What is the maximum distance between conserved nucleotides to merge into a single CNS
						  # To make sense, must greater than the filter (to bridge filtered gaps)

#### CNS coverage and splitting parameters
my $minCNSCoverage=0.15; ### The minimum coverage of the CNS to be acceptable for a deep alignment
my $minCNSCoverageAfterSplit=0.5; ### The minimum coverage of CNS to assign to a sub-CNS after splitting
my $minSpeciesToSplitCNS=5;
my $maxSpeciesToInitiateCNSSplit = 150; ## Do not split CNS if it is supported by atleast this number of species
									 ## To avoid spliting of very highly conserved CNSs

#### Alignment filtering parameters
my @minSpeciesPerConservationLevel= (150,100,100,90,5,5); ## Must have atleast these many alignments to support level assignment
my @minSpeciesAtConservationLevel= (1,1,1,3,5,5); ## Musty have atleast these many species from each level to support level assignment

my $minSpeciesPerConservationLevelString="";
my $minORFLength="auto";
my $minHSPthresholdFamily=2000;
my $minHSPthresholdGlobal=1600;
my $orthologSelectionStrategy = "bestmean";

###### Other parameters
my $keep_tmp = 0;
my $verbose = 0;
my $force=1;   #### There is an option to use the family alignment if already exists. This does not currently work!
my $dumpBam = 0;
my $skipKaKs=0;
my $skipMissingGenomes=0;
my $justFamilyAlignment = 0;

my $help = 0;

########### Reg Seq lengths
my $upstreamLength;
my $downstreamLength;

my %upstreamLengthReference;
my %downstreamLengthReference;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"locus=s" => \$locus,
			"reference=s" => \$referenceGenome,
			"min-identity-family=i" => \$minIdentityFamily,
			"min-identity-global=i" => \$minIdentityGlobal,
			"min-align-threshold-family=i" => \$minHSPthresholdFamily,
			"min-align-threshold-global=i" => \$minHSPthresholdGlobal,			
			"min-phylop-score=f" => \$minPhyloPscore,
			"min-deep-cns-coverage" => \$minCNSCoverage,
			"min-species-per-conservation-level" => \$minSpeciesPerConservationLevelString,
			"min-orf-length=i" => \$minORFLength,
			"just-family-alignment" => \$justFamilyAlignment,
			"keep-tmp" => \$keep_tmp,
			"verbose" => \$verbose,
			"bam-dump" =>\$dumpBam,
			"skip-kaks" => \$skipKaKs,
			"skip-missing-genomes" => \$skipMissingGenomes,
			"help" => \$help) or die ("Error in command line arguments\n");

if($verbose) { print "Conservatory version 2.0.1\n\n"; }

if($minCNSCoverage <0 || $minCNSCoverage>1) {
	print "\n\nBad parameters: min-deep-cns-coverage must be between 0 and 1.\n\n";
	$help = 1;
}

#### Redefine the conservation level filters
if($minSpeciesPerConservationLevelString ne "") {
    ## TODO
}

if( $locus eq "" or $referenceGenome eq "" or $help or !($orthologSelectionStrategy eq "bestmean" or $orthologSelectionStrategy eq "bestsum" ) ) {
	if($locus eq "" or $referenceGenome eq "") {
		print "\n\nMissing parameter: must supply both reference genome and locus.\n\n";
	}
	if (!($orthologSelectionStrategy eq "bestmean" or $orthologSelectionStrategy eq "bestsum")) {
		print "\n\nBad parameter: ortholog-selection-strategy can be either bestsum or bestmean.\n\n";
	}

   print "buildConservation --reference <familyName> --locus <Locus>\n\n\n";
   print "\t--reference\tReference genome name (REQUIRED). Genomes must be processed with processGenome --global for the reference genome before running buildConservation.\n";
   print "\t--locus\t\t\tLocus in the reference genome for the family (REQUIRED).\n";
   print "\t--conservatoryDirectory\t\tPath of the main conservatory directory.\n";
   print "\n\t\tAlignment options\n\n";
   print "\t--min-identity-family\t\tMinimum identity for alignments within the family. Default is 70.\n";
   print "\t--min-identity-globa\t\tMinimum identity for alignments of CNS for genomes outside the family. Default is 60.\n";
   print "\t--min-align-threshold-family\t\tMimimum alignment score threshold for within family alignments. Default is 2000.\n";
   print "\t--min-align-threshold-global\t\tMimimum alignment score threshold for global alignments. Default is 1600.\n";
   print "\t--min-phylop-score\t\tMinimum phyloP score to consider as significant CNS (default: 1.5).\n";
   print "\t--min-deep-cns-coverage\t\tMimimum alignment coverage for deep CNS (Expressed as ratio of CNS length: 0-1). Default is 0.2.\n";
   print "\t--min-species-per-conservation-level\t\tSpecies number filter for level conservation. Defines the mimimum number of species a CNS has to be found it to allow a certain conservation level. A string of 6 comma delimited values. Default is 150,100,100,50,5,5.\n";   
   print "\t--min-orf-length\t\tMinimum length (in bp) of ORF to identify in CNS. Deafult is \"auto\" which is automatically calculated based on expected random ORF occurance in data.\n";
   print "\t--bam-dump\t\tGenerate bam files for the alignments.\n";
   print "\t--skip-kaks\t\tSkip KaKs calculation (run faster)\n";
   print "\t--skip-missing-genomes\t\tIf genome information can't be found, skip and continue analysis (DEFAULT: Terminate with error message),\n";
   print "\t--keep-tmp\t\tDo not delete all the temporary files produced in the TMP directory.\n";
 
   print "\n\t\tGeneral options\n\n";
   print "\t--verbose\t\tOutput extra messages.\n";
   print "\t--help\t\t\tPrints this message.\n\n";
   
   exit();
}

### Set up directory and file access
my $genomedbFile = $conservatoryDir . "/genome_database.csv";

my $outputDir = "$conservatoryDir/alignments/$referenceGenome/";
my $outputCNSDir = "$conservatoryDir/CNS/$referenceGenome/";
my $tmpDir = "$conservatoryDir/alignments/$referenceGenome/tmp";
my $treeFileName = "$conservatoryDir/genomes/$referenceGenome.tree";
my $modelFileName = "$conservatoryDir/genomes/$referenceGenome.mod";
my $genomeDir ="$conservatoryDir/genomes";
my $finalFASTAUpFileName = "$outputDir/$locus.up.fasta";
my $finalFASTADownFileName = "$outputDir/$locus.down.fasta";
my $finalCNSFileName = "$outputCNSDir/$locus.cns.csv";
my $tmpCNSFileName = "$tmpDir/$locus.cns.csv";
my $finalMapFileName = "$outputCNSDir/$locus.map.csv";

### Alignment, orthologs and CNSs
my %fastaUpstreamAlignment;
my %fastaDownstreamAlignment;
my %speciesDatabase;
my %regulatoryRegionLengthDatabase;
my %speciesClassification;

my %mapAlignmentFamily;
my %orthologs;
  
my $lastzParametersFamily = "--gap=200,100 --nochain --noytrim --seed=match4 --gapped --strand=both --step=1 --ambiguous=iupac --identity=$minIdentityFamily --ydrop=1000 --hspthreshold=$minHSPthresholdFamily --gappedthresh=$minHSPthresholdFamily";
my $lastzParametersGlobal = "--gap=200,100 --nochain --noytrim --seed=match4 --gapped --strand=both --step=1 --ambiguous=iupac --identity=$minIdentityGlobal --ydrop=1000 --hspthreshold=$minHSPthresholdGlobal --gappedthresh=$minHSPthresholdGlobal";

####### First, sanity checks. Check to see if directory structure is OK and if programs are installed
####### 
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;
die "ERROR: Conservatory directory structure at ($conservatoryDir) is corrupt\n" unless (-e "$conservatoryDir/genomes" && -e "$conservatoryDir/genomes/blastdb/" && -e "$conservatoryDir/scripts" && -e "$conservatoryDir/alignments");

my $t_lastz = `sh -c 'command -v lastz'`;
die "ERROR: Cannot find lastz in path. Please make sure it is installed.\n" unless ($t_lastz ne ""); 

my $t_samtools = `sh -c 'command -v samtools'`;
die "ERROR: Cannot find samtools in path. Please make sure it is installed.\n" unless ($t_samtools ne "");  

my $t_phyloP = `sh -c 'command -v phyloP'`;
die "ERROR: Cannot find phyloP in path. Please make sure phast is installed.\n" unless ($t_phyloP ne "");  

my $t_wig2bed = `sh -c 'command -v wig2bed'`;
die "ERROR: Cannot find wig2bed in path. Please make sure bedops is installed.\n" unless ($t_wig2bed ne "");  
my $t_muscle = `sh -c 'command -v muscle'`;
die "ERROR: Cannot find muscle in path. Please make sure muscle v3.8.1551 is installed.\n" unless ($t_muscle ne "");  

die "ERROR: Cannot find fastMLexecutable at $conservatoryDir/scripts/fastml.\n" unless (-x "$conservatoryDir/scripts/fastml");

###############################################
if($verbose) { print "START: Begin conservatory analysis for $locus.\n"; }

###############################################
##### Now set things up
##### Find out what is our reference genome family and length parameters
open (my $genomeDatabase, "<", $genomedbFile);
while((my $curgenomeline = <$genomeDatabase>)) {
	if(substr($curgenomeline,0,1) ne "#")  {
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$speciesDatabase{$curgenomeFamily}{$curgenomeSpecies}=0;
		$regulatoryRegionLengthDatabase{$curgenomeName}{'upstreamLength'} = $upstreamLength * 1000;
		$regulatoryRegionLengthDatabase{$curgenomeName}{'downstreamLength'} = $downstreamLength * 1000;
		$speciesClassification{$curgenomeSpecies} = $classification;
		
		if($curgenomeName eq $referenceGenome) {
			$referenceGenomeFamily = $curgenomeFamily;
			$referenceGenomeSpecies = $curgenomeSpecies;
			$locusFullName = "$curgenomeSpecies-$curgenomeName-$locus";

			$upstreamLengthReference{$locusFullName} = $upstreamLength  * 1000;
			$downstreamLengthReference{$locusFullName} = $downstreamLength * 1000;
		}
	}
}
seek ($genomeDatabase,0,SEEK_SET);
die "ERROR: Cannot find reference genome ($referenceGenome) in the genome database file.\n" unless $referenceGenomeFamily ne "";
die "ERROR: Cannot find tree file $treeFileName for reference genome $referenceGenome.\n" unless (-e $treeFileName);
die "ERROR: Cannot find model file $modelFileName for reference genome $referenceGenome.\n" unless (-e $modelFileName);

### Read tree to memory
my $treeReader = new Bio::TreeIO(-file   => $treeFileName,
                            -format => "newick");
my $tree = $treeReader->next_tree;

### make place for the alignment and CNS
if (! -e $outputDir) { mkdir($outputDir); }
if (! -e $tmpDir) { mkdir($tmpDir); }
if (! -e $outputCNSDir) { mkdir($outputCNSDir); }	

### Extract the absolute coordinates of the locus
my $refFootprintFileName = "$conservatoryDir/genomes/$referenceGenomeFamily/$referenceGenome.footprint.gff3";
my ($refGeneStart, $refGeneEnd, $refGeneChr, $refGeneDir) = ("","","","");

open (my $refFootprintFile, "<", $refFootprintFileName);
while ((my $line = <$refFootprintFile>) && $refGeneChr eq "" ){
	chomp($line);
	my @array = split /\t/, $line;
	my %fields = split /[;=]/, $array[8];
	
	if($fields{'Name'} eq $locusFullName) {
		$refGeneChr = $array[0];
		$refGeneStart = $array[3];	
		$refGeneEnd = $array[4];
		$refGeneDir= $array[6];
	}
}
close($refFootprintFile);
die "ERROR: Cannot find locus $locusFullName in reference genome $referenceGenome.\n" unless ($refGeneChr ne "");

if($verbose) { print "PROGRESS: Extracted genome coordinates $locus:$refGeneChr:$refGeneStart:$refGeneEnd. Upstream sequence $upstreamLengthReference{$locusFullName} bp. Downstream sequence $downstreamLengthReference{$locusFullName} bp.\n"; }

	
#remember where we are
$curDir = getcwd;
chdir $tmpDir;

####### Set up the reference fasta files
my $upstreamRefFastaName = "$tmpDir/$referenceGenome.$locus.up.fasta";
my $downstreamRefFastaName = "$tmpDir/$referenceGenome.$locus.down.fasta";

#### Perform family alignments

$fastaUpstreamAlignment{$locusFullName}{$referenceGenomeSpecies} = extractFastaToFile("$genomeDir/$referenceGenomeFamily/$referenceGenome" . ".upstream.fasta.gz", $locusFullName, $upstreamRefFastaName);
$fastaDownstreamAlignment{$locusFullName}{$referenceGenomeSpecies} = extractFastaToFile("$genomeDir/$referenceGenomeFamily/$referenceGenome" . ".downstream.fasta.gz", $locusFullName, $downstreamRefFastaName);
if($verbose) { print localtime() . ": Done extracting reference sequences.\n";}

# set up CRE-orthology hashes
##############################################################################
# First pass. Determine CNS for family
  
while(<$genomeDatabase>) {
	chomp;
	my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx) = split /,/;

	if(substr($curgenomeName,0,1) ne "#" && $curgenomeFamily eq $referenceGenomeFamily) { #if this is not a comment and if it within the family 
 
		### get ortholog sequences
		my $orthologFileName = "$genomeDir/$curgenomeFamily/$referenceGenome.$curgenomeName.orthologs.csv";
		my $orthologFileFound = open (my $orthologFile, "<", $orthologFileName);
		
		if(!$orthologFileFound && !$skipMissingGenomes) { die "ERROR: Can't open ortholog file $orthologFileName. Did you run processGenomes for this reference genome?\n"; }
		if($orthologFileFound && -e "$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz" && -e "$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz") {
			while(my $orth_line = <$orthologFile>) {
				chomp($orth_line);
				(my $curPutativeOrtholog, my $curRefLocus, my $score) = split /,/,$orth_line;
				if($curRefLocus eq $locusFullName && $curPutativeOrtholog ne $curRefLocus) {
					my $upstreamFastaName ="$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.up.fasta";
					my $downstreamFastaName = "$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.down.fasta";
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz", $curPutativeOrtholog, $upstreamFastaName);
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz", $curPutativeOrtholog, $downstreamFastaName);

					my $MAFUpFileName = "$locus.$curPutativeOrtholog.up.maf";
					system("lastz --format=maf $lastzParametersFamily $upstreamRefFastaName $upstreamFastaName > $MAFUpFileName");
					my $upQuality = getMAFQuality($MAFUpFileName);
					my $MAFDownFileName = "$locus.$curPutativeOrtholog.down.maf";
					system("lastz --format=maf $lastzParametersFamily $downstreamRefFastaName $downstreamFastaName > $MAFDownFileName");
					my $downQuality = getMAFQuality($MAFDownFileName);

					#############################################################
					if($upQuality+$downQuality > $minQuality) {				
						if($verbose && $curgenomeName ne $referenceGenome) { print "PROGRESS: Found possible CRE-ortholog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: " . ($upQuality+$downQuality) . ".\n"; }
						if($verbose && $curgenomeName eq $referenceGenome) { print "PROGRESS: Found possible CRE-paralog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: " . ($upQuality+$downQuality) . ".\n"; }
					
						if(not defined $orthologs{$curgenomeSpecies}) {
							$orthologs{$curgenomeSpecies} = [ {
								'Name' => $curPutativeOrtholog,
								'Genome' => $curgenomeName,
								'Family' => $curgenomeFamily,
								'upstreamLength' => $upstreamLength *1000,
								'downstreamLength' => $downstreamLength *1000,
								'upstreamFileName' => $upstreamFastaName,
								'downstreamFileName' => $downstreamFastaName,
								'MAFUpFileName' => $MAFUpFileName,
								'MAFDownFileName' => $MAFDownFileName,
								'UpQuality' => $upQuality,
							'DownQuality' => $downQuality} ];		
						} else {
							push( @{ $orthologs{$curgenomeSpecies} },
								{
									'Name' => $curPutativeOrtholog,
									'Genome' => $curgenomeName,
									'Family' => $curgenomeFamily,
									'upstreamLength' => $upstreamLength *1000,
									'downstreamLength' => $downstreamLength *1000,
									'upstreamFileName' => $upstreamFastaName,
									'downstreamFileName' => $downstreamFastaName,
									'MAFUpFileName' => $MAFUpFileName,
									'MAFDownFileName' => $MAFDownFileName,
									'UpQuality' => $upQuality,
								'DownQuality' => $downQuality});
							}
					} else {
						if($verbose && $curgenomeName ne $referenceGenome) { print "PROGRESS: Rejected CRE-ortholog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: $upQuality.\n"; }
						if($verbose && $curgenomeName eq $referenceGenome) { print "PROGRESS: Rejected CRE-paralog ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: $upQuality.\n"; }
						unlink($MAFDownFileName);
						unlink($MAFUpFileName);
						unlink($upstreamFastaName);
						unlink($downstreamFastaName);
					}
				}
			}
			close($orthologFile);
		}
	}
}
close ($genomeDatabase);	
  	
if(!$keep_tmp) {
	unlink($upstreamRefFastaName);
	unlink($downstreamRefFastaName);
}

#####################################################################################################
##### Now we have assembled the list of putative CRE orthologs. Select the best genome for each species

%orthologs = pickBestPutativeOrthologs(%orthologs);

####################################################################################################################################
##### At this point, we have selected our "CRE orthologs" (%orthologs) and have all the filtered upstream and downstream sequences in fasta files 
##### Perform alignments to the reference genome
my @species = keys %orthologs;
my $numOfSpecies = scalar @species;

if ($verbose) { print "PROGRESS: Done with CRE-ortholog selection. Collected $numOfSpecies CRE-orthologs.\n"; }

if ($numOfSpecies >= 0) {
	#### Now all alignments were performed, assemble MAF files to a single alignment. 
	### First, move everything to an array. Dump a copy to the CRE-ortholog file
	if($verbose) { print "PROGRESS: Multiple sequence assembly"; }
	
	my $finalCREorthologFileName = "$outputDir/$locus.CREorthologs.txt";
	open(my $finalCREorthologFile, ">$finalCREorthologFileName");
	
	my @orthologsToProcess;
	foreach my $speciesToAlign (@species) {
		foreach my $curOrtholog (@{ $orthologs{$speciesToAlign} }) {
			if($curOrtholog->{'UpQuality'} > $EMPTY_FILE || $curOrtholog->{'DownQuality'} > $EMPTY_FILE) {
				push @orthologsToProcess, $curOrtholog;
					print $finalCREorthologFile  $curOrtholog->{'Genome'} . "\t" . $curOrtholog->{'Name'} . "\t" . $curOrtholog->{'UpQuality'} . "\t" . $curOrtholog->{'DownQuality'} ."\n"; 
				}
			}
		}

		if((scalar @orthologsToProcess) > 0) {
			my @orthologsToProcessSorted = reverse sort { $a->{'UpQuality'} <=> $b->{'UpQuality'} } @orthologsToProcess;
	
			### Load all MAF, collapse species-specific paralogs and convert to FASTA.
	
			foreach my $curOrthologToMultipleAlignment (@orthologsToProcessSorted) {
			
				MAFtoFASTA($curOrthologToMultipleAlignment->{'MAFUpFileName'}, \%upstreamLengthReference, $curOrthologToMultipleAlignment->{'upstreamLength'}, \%fastaUpstreamAlignment, \%mapAlignmentFamily, "U");
				MAFtoFASTA($curOrthologToMultipleAlignment->{'MAFDownFileName'}, \%downstreamLengthReference,$curOrthologToMultipleAlignment->{'downstreamLength'}, \%fastaDownstreamAlignment, \%mapAlignmentFamily, "D");
				
				if(!$keep_tmp) {
					unlink($curOrthologToMultipleAlignment->{'MAFUpFileName'});
					unlink($curOrthologToMultipleAlignment->{'MAFDownFileName'});
					unlink($curOrthologToMultipleAlignment->{'upstreamFileName'});
					unlink($curOrthologToMultipleAlignment->{'downstreamFileName'});
				}
			}
			open (my $finalFASTAUpFile, ">$finalFASTAUpFileName");
			open (my $finalFASTADownFile, ">$finalFASTADownFileName");

			# and Dump fasta alignment
			print $finalFASTAUpFile ">$referenceGenome\n" . $fastaUpstreamAlignment{$locusFullName}{$referenceGenome} . "\n";
			print $finalFASTADownFile ">$referenceGenome\n" . $fastaDownstreamAlignment{$locusFullName}{$referenceGenome} . "\n";
			
			for my $curspecies (keys %{ $fastaUpstreamAlignment{$locusFullName} } ) {
				if($curspecies ne $referenceGenome) {
					print $finalFASTAUpFile ">$curspecies\n" . $fastaUpstreamAlignment{$locusFullName}{$curspecies} . "\n";
				}
			}
			for my $curspecies (keys %{ $fastaDownstreamAlignment{$locusFullName} }) {
				if($curspecies ne $referenceGenome) {
					print $finalFASTADownFile ">$curspecies\n" . $fastaDownstreamAlignment{$locusFullName}{$curspecies} . "\n";
				}
			}	
			close($finalFASTAUpFile);
			close($finalFASTADownFile);
		}
		if($verbose) { print "\n"; }
} else {
	if($verbose) { print "PROGRESS: No CRE-orthologs for $locus.\n"; }
	die;
} 
if($verbose) { if(-e "$outputDir/$locus.up.fasta") { print "PROGRESS: Done alignment for $locus.\n"; } }

if($justFamilyAlignment) {
	die "END: --justFamilyAlignment is selected. Finish performing family alignments\n";
}

##########################################################################################################
### Alignments for all CRE-orthologs are ready. Now process with phyloP to identify family-CNS

if (! -e $outputCNSDir) { mkdir($outputCNSDir); }

if($verbose) { print "PROGRESS: Begin family conservation analysis for $locus. Minimum phyloP score: $minPhyloPscore. \n"; }

my $coordinateTranslateAwkUp;
my $coordinateTranslateStrUp;
my $coordinateTranslateAwkDown;
my $coordinateTranslateStrDown;

if($refGeneDir eq "+") {
	$coordinateTranslateAwkUp = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneStart-$upstreamLengthReference{$locusFullName}-1+\$2,$refGeneStart-$upstreamLengthReference{$locusFullName}-1+\$3,\$5);}}'";
	$coordinateTranslateStrUp = " \"$refGeneChr\", $refGeneStart- $upstreamLengthReference{$locusFullName}-1+\$2, $refGeneStart- $upstreamLengthReference{$locusFullName}-1+\$3";
	$coordinateTranslateAwkDown = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneEnd+\$2,$refGeneEnd+\$3,\$5);}}'"; 
	$coordinateTranslateStrDown = " \"$refGeneChr\", $refGeneEnd+\$2, $refGeneEnd+\$3";		
} else { 
	$coordinateTranslateAwkUp = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneEnd+ $upstreamLengthReference{$locusFullName}-\$3,$refGeneEnd+ $upstreamLengthReference{$locusFullName}-\$2,\$5);}}'";
	$coordinateTranslateStrUp = " \"$refGeneChr\", $refGeneEnd+$upstreamLengthReference{$locusFullName}-\$3, $refGeneEnd+$upstreamLengthReference{$locusFullName}-\$2";
	$coordinateTranslateAwkDown = "awk '{ if(\$5>$minPhyloPscore) {print(\"$refGeneChr\",$refGeneStart-\$3,$refGeneStart-\$2,\$5);}}'";
	$coordinateTranslateStrDown = "\"$refGeneChr\",$refGeneStart-\$3,$refGeneStart-\$2";
}
	
#### Run phyloP 
my $phyloPParameters = "--seed 123 --wig-scores --no-prune --method LRT --mode CON";
my $alternativephyloPParameters = "--seed 123 --wig-scores --no-prune --method SCORE --mode CON";
my $CNSFound=0;

if(-s $finalFASTAUpFileName > $EMPTY_FILE) {
	system("phyloP $phyloPParameters $modelFileName $finalFASTAUpFileName | wig2bed | sort -k1,1 -k2,2n > $tmpDir/$locus.up.bed");

	if((-s "$tmpDir/$locus.up.bed") <= $EMPTY_FILE) {
		if($verbose) { print "PROGRESS: phyloP outputfile is empty...\n"; }
		### There is a bug in phyloP (t=nan) for some reason. If failed, try with a different method
		my $testPhylopbug = system("phyloP $phyloPParameters $modelFileName $finalFASTAUpFileName > /dev/null");
		if($verbose) { print("PROGRESS: bug check: $testPhylopbug.\n"); }
		if($testPhylopbug!=0) {
			if($verbose) { print("PROGRESS: phyloP failed (internal bug?). Retrying with alternative parameters...\n"); }
			system("phyloP $alternativephyloPParameters $modelFileName $finalFASTAUpFileName | wig2bed | sort -k1,1 -k2,2n > $tmpDir/$locus.up.bed");
		}
	}

	if((-s "$tmpDir/$locus.up.bed") > $EMPTY_FILE) { 
		system("awk '{ if(\$5>$minPhyloPscore) {print;}}' $tmpDir/$locus.up.bed > $tmpDir/$locus.up.fil.bed");
		if(-s "$tmpDir/$locus.up.fil.bed" > $EMPTY_FILE) {
			$CNSFound=1;
			if($verbose) { print "PROGRESS: Found possible family upstream CNS.\n"; }
			system("bedtools merge -d $CNSMergeLength -c 5 -o mean -i $tmpDir/$locus.up.fil.bed | awk 'BEGIN{OFS=\",\"}{ if( (\$3 - \$2)>=$minCNSLength) print(\"$locus\", \$2-$upstreamLengthReference{$locusFullName}, \$3-$upstreamLengthReference{$locusFullName}, \$4,\"UP\",$coordinateTranslateStrUp); }' > $tmpCNSFileName");
		} else {
			if($verbose) { print "PROGRESS: No family upstream CNS.\n"; }
		}
		if(!$keep_tmp) {unlink("$tmpDir/$locus.up.fil.bed"); }
	}
}

if(-s $finalFASTADownFileName > $EMPTY_FILE) {
	system("phyloP $phyloPParameters $modelFileName $finalFASTADownFileName | wig2bed | sort -k1,1 -k2,2n > $tmpDir/$locus.down.bed");
	if(-s "$tmpDir/$locus.down.bed"> $EMPTY_FILE) { 
		system("awk '{ if(\$5>$minPhyloPscore) {print;}}' $tmpDir/$locus.down.bed > $tmpDir/$locus.down.fil.bed");
		if(-s "$tmpDir/$locus.down.fil.bed" > $EMPTY_FILE) {
			$CNSFound=1;
			if($verbose) { print "PROGRESS: Found possible family downstream CNS.\n"; }
			system("bedtools merge -d $CNSMergeLength -c 5 -o mean -i $tmpDir/$locus.down.fil.bed | awk 'BEGIN{OFS=\",\"}{ if( (\$3 - \$2)>=$minCNSLength) print(\"$locus\", \$2+1, \$3+1, \$4 ,\"DOWN\",$coordinateTranslateStrDown); }' >> $tmpCNSFileName");
		} else {
			if($verbose) { print "PROGRESS: No family downstream CNS.\n"; }
		}
		if(!$keep_tmp) {unlink("$tmpDir/$locus.down.fil.bed"); }
	}
}
	
if( (-e $tmpCNSFileName) && ((-s $tmpCNSFileName) > $EMPTY_FILE )) {
	### Now convert coordinates and dump a BEDGRAPH file for merging
	if(-e "$tmpDir/$locus.up.bed") {
		system("$coordinateTranslateAwkUp $tmpDir/$locus.up.bed > $tmpDir/$locus.phylop.bed");
	}
	if(-e "$tmpDir/$locus.down.bed") {
		system("$coordinateTranslateAwkDown $tmpDir/$locus.down.bed >> $tmpDir/$locus.phylop.bed");
	}
	if( (-e "$tmpDir/$locus.phylop.bed") && ( (-s "$tmpDir/$locus.phylop.bed") > $EMPTY_FILE) ) {
		system("cp $tmpDir/$locus.phylop.bed $outputCNSDir");
	}
} else {
	$CNSFound =0;
}

if(!$keep_tmp) { 
	unlink("$tmpDir/$locus.up.bed");
	unlink("$tmpDir/$locus.down.bed");
	unlink("$tmpDir/$locus.phylop.bed");
}

if($verbose) { print "PROGRESS: End conservation analysis for $locus.\n"; }

if(!$CNSFound) {
	unlink($tmpCNSFileName);
	if($verbose) { print ("END: No CNS found for $locus.\n"); } 
	exit();
}

###############################################################################################################################
### Prepare the reconstructed ancesteral sequence of the CNS
### filter CNS and prepare for CNS alignments with all genomes

if($verbose) { print "PROGRESS: Begin ancesteral sequence reconstruction for $locus.\n"; }

### Replace 'N' with missing data in alignments
foreach my $curSpecies (keys %{ $fastaUpstreamAlignment{$locusFullName} }) {
	$fastaUpstreamAlignment{$locusFullName}{$curSpecies} =~ s/N/-/g;
}

foreach my $curSpecies (keys %{ $fastaDownstreamAlignment{$locusFullName} }) {
	$fastaDownstreamAlignment{$locusFullName}{$curSpecies} =~ s/N/-/g;
}

###### Assemble ancesteral family CNS for locus

my $CNSNum=0;
my $totalCNSLength=0;
my %CNSforLocus;
my %cnsReferenceLength;

my $ancesteralLocusCNSFileName = "$tmpDir/$locus.ancesteral.cns.fasta";
open (my $ancesteralLocusCNSFasta, ">$ancesteralLocusCNSFileName");	
open (my $CNSFile, $tmpCNSFileName) || die ("INTERNAL ERROR ($locusFullName).\n");


while(my $CNSLine = <$CNSFile>) {
	chomp($CNSLine);
	my ($cnsLocus,$cnsRelStart,$cnsRelEnd,$pval,$upOrDown,$chromosome,$absStart,$absEnd) = split /,/,$CNSLine;
	
	if(($cnsRelEnd - $cnsRelStart)>= $minCNSLength) {
		
		my $curCNSLength = ($cnsRelEnd - $cnsRelStart);	
		my $shortestAlignment = $curCNSLength;
		my $CNSName = "$locus.$cnsRelStart";
		$CNSforLocus{$CNSName} = {
				'Name' => $CNSName,
				'Start' => $cnsRelStart,
				'End' => $cnsRelEnd,
				'Locus' => $cnsLocus,
				'Chromosome' => $chromosome,
				'absStart' => $absStart,
				'absEnd' => $absEnd,
				'Strand' => $refGeneDir,
				'NumberOfSpecies' => 0,
				'ConservationLevel' => 'Family'};
				
		my %cnsSeqs;
				
		$cnsReferenceLength{$CNSName} = $cnsRelEnd - $cnsRelStart;
		
		my $tmpCNSFastaFileName = "$tmpDir/$CNSName.cns.fasta";
		open (my $tmpCNSFile, ">$tmpCNSFastaFileName");

		my $cnsSeq;
		my $referenceCNSSeq;
		my $numOfSpeciesWithCNS=0;
		if($cnsRelStart <= 0 ) { ## If this is upstream seqeunce
			for my $curSpecies (keys %{ $speciesDatabase{$referenceGenomeFamily} }) {
				
				if(defined $fastaUpstreamAlignment{$locusFullName}{$curSpecies}) {
					$cnsSeq=substr($fastaUpstreamAlignment{$locusFullName}{$curSpecies}, $upstreamLengthReference{$locusFullName}+$cnsRelStart, $cnsRelEnd-$cnsRelStart);
					$cnsSeqs{$curSpecies}=$cnsSeq;
					$numOfSpeciesWithCNS++;
				} else {		
					$cnsSeq = ("-" x ($cnsRelEnd-$cnsRelStart));
				}
				
				print $tmpCNSFile ">$curSpecies\n$cnsSeq\n";
			}
		} else {	
			for my $curSpecies (keys %{ $speciesDatabase{$referenceGenomeFamily} }) {
				if(defined $fastaDownstreamAlignment{$locusFullName}{$curSpecies}) {
					$cnsSeq = substr($fastaDownstreamAlignment{$locusFullName}{$curSpecies}, $cnsRelStart, $cnsRelEnd-$cnsRelStart);
					$cnsSeqs{$curSpecies}=$cnsSeq;
					$numOfSpeciesWithCNS++;
				} else {					
					$cnsSeq = ("-" x ($cnsRelEnd-$cnsRelStart));
				}				
				print $tmpCNSFile ">$curSpecies\n$cnsSeq\n";
			}	
		}
		close ($tmpCNSFile);
				
		#### Now invoke FASTML to reconstruct ancestral sequence
		my $ancesteralCNSFileName = "$tmpDir/$locus.$cnsRelStart.ancesteral.fasta";
		system("$conservatoryDir/scripts/fastml -s $tmpCNSFastaFileName -t $treeFileName -qf -b -e /dev/null -x /dev/null -y /dev/null -k /dev/null -d /dev/null -e /dev/null -j $ancesteralCNSFileName >/dev/null");
		if(!$keep_tmp) { unlink("$tmpCNSFastaFileName"); }
		unlink("log.txt");
		if($verbose) {
			print("PROGRESS: Reconstructed $locus.$cnsRelStart. Length: " . ($cnsRelEnd-$cnsRelStart) . "\n")
		}
		my $ancesteralCNS;
		open(my $ancesteralCNSFasta, $ancesteralCNSFileName) || die ("INTERNAL ERROR ($locusFullName).\n");
		while((my $seqName = <$ancesteralCNSFasta>) && $ancesteralCNS eq "") {
			my $seq = <$ancesteralCNSFasta>;
			chomp($seqName);
			chomp($seq);
			if(substr($seqName,1) eq "N1") { $ancesteralCNS = $seq;}
		}
		close($ancesteralCNSFasta);
		unlink($ancesteralCNSFileName);

		###### Mask ancesteral sequence for homopolymers
		my $ancesteralCNSMasked = $ancesteralCNS;

		## First, lastz does not handle ambigious characters very well (basically assuming N)
		# replace W with A. Not ideal, but better than alternative. Also, too many A's will be masked.
		$ancesteralCNSMasked =~ s/W/A/g;

		$ancesteralCNSMasked = fuzzyFilterHomopolymers($ancesteralCNSMasked,$homoPolymerFilterLength,0);
		$ancesteralCNSMasked = fuzzyFilterDimers($ancesteralCNSMasked, $dimerPolymerFilterLength,0);

		$ancesteralCNSMasked = fuzzyFilterHomopolymers($ancesteralCNSMasked,$homoPolymerFuzzyFilterLength,1);


		$CNSforLocus{$CNSName}{'ancesteralSequence'} = $ancesteralCNS;
		$CNSforLocus{$CNSName}{'referenceSequence'} = $cnsSeqs{$referenceGenomeSpecies};

		print $ancesteralLocusCNSFasta ">$CNSName\n$ancesteralCNSMasked\n";
		$totalCNSLength += $curCNSLength;
		$CNSNum++;
		

		##### Check for ORF in reconstructed CNS
		my ($ancesteralORFLength, $ancesteralORF, $ancesteralORFStand) = getLongestORF($ancesteralCNS);
		my $randomORFLength;
		if($minORFLength eq "auto") {
			$randomORFLength = getRandomORFLength($ancesteralCNS);
		} else {
			$randomORFLength = $minORFLength;
		}
		my $ancesteralCNSORF = Bio::LocatableSeq->new(-seq => $ancesteralORF,
						    	  					  -id => "Reconstructed",
						    	  					  -start => 1,
						    	  					  -end => $ancesteralORFLength);	
		
		if($ancesteralORFLength > $randomORFLength) {	### If there is a potential ORF, mark it and calc KaKs rate
			if($verbose) { print "PROGRESS: $CNSName: Detected ORF ($ancesteralORFLength/$randomORFLength,$ancesteralORFStand):$ancesteralORF.\n"; }
			$CNSforLocus{$CNSName}{'ORF'}= $ancesteralORFLength;
			$CNSforLocus{$CNSName}{'ORFDir'}= $ancesteralORFStand;			
			
			### Determine KaKs
			### First, assemble all ORFs
			if(!$skipKaKs) {
				my %cnsORFs;
				my @cnsPeptides;
				$cnsORFs{'Reconstructed'} = $ancesteralCNSORF;
				my $peptide = dropAsterixFromProtein($ancesteralCNSORF->translate);
				push @cnsPeptides, $peptide;

				foreach my $curCNSSpecies (keys %cnsSeqs) {
					$cnsSeqs{$curCNSSpecies} =~ s/-//g;
					$cnsSeqs{$curCNSSpecies} =~ s/X/N/g;
					if(length($cnsSeqs{$curCNSSpecies})>0) {
						my ($curLongestORFLength, $curLongestORF, $curLongestORFStand) = getLongestORF($cnsSeqs{$curCNSSpecies},$ancesteralORFStand);
						my $curCNSORF = Bio::LocatableSeq->new(-seq => $curLongestORF,
												    	   	-id => $curCNSSpecies,
												    	   	-start => 1,
												    	   	-end => $curLongestORFLength);
						$cnsORFs{$curCNSSpecies} = $curCNSORF;
						$peptide = dropAsterixFromProtein($curCNSORF->translate);
						push @cnsPeptides, $peptide;
					}
				}
			
				my $stats = Bio::Align::DNAStatistics->new();
				my $cnsAlignmentPep = quietAlign(\@cnsPeptides);
				### Filter low identity alignments
				my @filteredCNSPeptides;		

				my @seqCharAncesteral = split //, $cnsAlignmentPep->get_seq_by_id('Reconstructed')->seq();

				foreach my $seq ($cnsAlignmentPep->each_seq) {
					if($seq->id() ne "Reconstructed") {
						my $pairwiseAln = $cnsAlignmentPep->select_noncont_by_name('Reconstructed', $seq->id());
						my $nogappairwiseAln = $pairwiseAln->remove_gaps();

						if($nogappairwiseAln->length > 4 && $pairwiseAln->percentage_identity > 60)  { ### If too divergent, do not include sequence
							my $nogapSeq = $seq->seq();
							$nogapSeq =~ s/-//g;
							$seq->seq($nogapSeq);
							push @filteredCNSPeptides, $seq;
						}
					}
				}
			
				if(@filteredCNSPeptides >1) {
			
					my $filteredCNSAlignmentPep = quietAlign(\@filteredCNSPeptides);
					my $cnsDNAAlignment = Bio::Align::Utilities::aa_to_dna_aln($filteredCNSAlignmentPep, \%cnsORFs);
					### See that we have something to align, and its not too divergent or not divergent enough
					my $nogapalignment = $cnsDNAAlignment->remove_gaps();
					if($nogapalignment->length > 0) {
						## Calculate KsKa
						if($verbose) { printf "PROGRESS: $CNSName: Calculating KaKs..."; }

						my $kaks_factory = Bio::Tools::Run::Phylo::PAML::Codeml->new(
							-verbose => 0,
							-tree => $tree,
							-branchlengths => 1,
							-params => { 'runmode' => -2,
                      				'seqtype' => 1});

                		$kaks_factory->alignment($cnsDNAAlignment);
                		my ($rc, $parser) = $kaks_factory->run();
                		$kaks_factory->cleanup();
			
                		if($rc>0) {
                			my $results = $parser->next_result;
                			my $MLmatrix = $results->get_MLmatrix();
                			my @outseq = $results->get_seqs();
                			my $ancesteralPos= -1;
                			for(my $i=0; $i< @outseq; $i++) {
	                			if($outseq[$i]->display_id eq "Reconstructed") {
                					$ancesteralPos = $i;
                				}
                			}
                			my $totalOmega=0;
                			my $totaldN=0;
                			my $totaldS=0;
                			for(my $i =0; $i< @outseq; $i++) {
	                			if($outseq[$i]->display_id() ne "Reconstructed") {
                					$totalOmega = $totalOmega + $MLmatrix->[$ancesteralPos]->[$i]->{'omega'};
									$totaldN = $totaldN + $MLmatrix->[$ancesteralPos]->[$i]->{'dN'};
									$totaldS = $totaldS + $MLmatrix->[$ancesteralPos]->[$i]->{'dS'};
                				}
                			}
							my $meanOmega = $totalOmega / (@outseq - 1);
							my $meandS = $totaldS / (@outseq - 1);
							my $meandN = $totaldN / (@outseq - 1);
							### See if we have enough substitutions for omega to make sense
							### dS > 0.01
							if($meandS > 0.01) {
	                			$CNSforLocus{$CNSName}{'omega'} = $meanOmega;
 							} else {
		          				$CNSforLocus{$CNSName}{'omega'} = -1;   ## dS is too low
							}

                			if($verbose) { printf("... Omega: %.2f (dS: %.2f;dN: %.2f)\n", $CNSforLocus{$CNSName}{'omega'}, $meandS, $meandN); }	
                		} else {
							if($verbose) { print "..cannot determine(" . $kaks_factory->error_string() .")\n";}
                			$CNSforLocus{$CNSName}{'omega'} = -99;  ## Error
                		}
					} else {
                		$CNSforLocus{$CNSName}{'omega'} = -2; ### Cannot find consistent ORF
					}
            	} else {
            		$CNSforLocus{$CNSName}{'omega'} = -2; ### Cannot find consistent ORF
            	} 
			} else {
				$CNSforLocus{$CNSName}{'omega'} = -4; ### No KaKs value calculated
			}
		} else {
				$CNSforLocus{$CNSName}{'ORF'}=0;
				$CNSforLocus{$CNSName}{'omega'} = -3;  ### There is no ORF
		}
	}
	
}
close($ancesteralLocusCNSFasta);
close($CNSFile);
if(!$keep_tmp) { unlink("$tmpCNSFileName"); }

if($verbose) { print "PROGRESS: End ancesteral sequence reconstruction for $locus. $CNSNum CNSs. Total Length $totalCNSLength.\n"; }

#################################################################
##### Now search for deep CNS (outside the family)
#####

my %deepCNSFasta;
my %mapAlignmentDeepCNS;

open (my $genomeDatabase, "<", $genomedbFile);

while(<$genomeDatabase>) {
	chomp;
	my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx) = split /,/;

	if(substr($curgenomeName,0,1) ne "#" && $curgenomeFamily ne $referenceGenomeFamily) { #if this is not a comment and outside the family
 
		### get ortholog sequences
		my $orthologFileName = "$genomeDir/$curgenomeFamily/$referenceGenome.$curgenomeName.orthologs.csv";
		my $orthologFileFound = open (my $orthologFile, "<", $orthologFileName);
		
		if(!$orthologFileFound && !$skipMissingGenomes) { die "ERROR: Can't open ortholog file $orthologFileName. Did you run processGenomes for this reference genome?\n"; }
		
		if($orthologFileFound && -e "$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz" && -e "$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz") {
			while(my $orth_line = <$orthologFile>) {
				chomp($orth_line);
				(my $curPutativeOrtholog, my $curRefLocus, my $score) = split /,/,$orth_line;
				if($curRefLocus eq $locusFullName && $curPutativeOrtholog ne $curRefLocus) {
					my $upstreamFastaName ="$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.up.fasta";
					my $downstreamFastaName = "$tmpDir/$locus.$curgenomeName.$curPutativeOrtholog.down.fasta";
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.upstream.fasta.gz", $curPutativeOrtholog, $upstreamFastaName);
					extractFastaToFile("$genomeDir/$curgenomeFamily/$curgenomeName.downstream.fasta.gz", $curPutativeOrtholog, $downstreamFastaName);

					my $MAFUpFileName = "$locus.$curPutativeOrtholog.up.maf";
					my $MAFDownFileName = "$locus.$curPutativeOrtholog.down.maf";
					system("lastz --format=maf $lastzParametersGlobal $ancesteralLocusCNSFileName" . "[multiple] $upstreamFastaName > $MAFUpFileName");
					my $upQuality = getMAFQuality($MAFUpFileName);
					system("lastz --format=maf $lastzParametersGlobal $ancesteralLocusCNSFileName" . "[multiple] $downstreamFastaName > $MAFDownFileName");
					my $downQuality = getMAFQuality($MAFDownFileName);
						
					#############################################################
					if($upQuality+$downQuality > $minQuality) {
						if($verbose) {
								print "PROGRESS: Found deep CNS hit ($curgenomeFamily:$curgenomeSpecies:$curgenomeName:" . fullNameToShortName($curPutativeOrtholog) . "). Quality: " . ($upQuality+$downQuality) . ".\n";
						}
						### Log alignment to fasta, but only if long enough (covers more than minCNSCoverage of the CNS)
						MAFtoFASTA($MAFUpFileName,  \%cnsReferenceLength, $regulatoryRegionLengthDatabase{$curgenomeName}{'upstreamLength'} , \%deepCNSFasta, \%mapAlignmentDeepCNS, "U",$minCNSCoverage);
						MAFtoFASTA($MAFDownFileName,  \%cnsReferenceLength, $regulatoryRegionLengthDatabase{$curgenomeName}{'downstreamLength'} , \%deepCNSFasta, \%mapAlignmentDeepCNS, "D",$minCNSCoverage);
					}

				if(!$keep_tmp) {
					unlink($upstreamFastaName);
					unlink($downstreamFastaName);
					unlink($MAFUpFileName);
					unlink($MAFDownFileName);
				}					
		}
	 }
	  close($orthologFile);
	}
  }
}
close ($genomeDatabase);
  
if(!$keep_tmp) {
	unlink($ancesteralLocusCNSFileName);
}
  
############################################################################################################
# Family CNS are not all deeply conserved. See if we can identify deeply conserved regions within the CNS
#  then split the CNS accordingly

# First, determine what are the breakpoints
foreach my $curCNS (keys %mapAlignmentDeepCNS) {
	my $CNSLength = $cnsReferenceLength{$curCNS};
	my @CNShitsSpecies =  keys %{ $mapAlignmentDeepCNS{$curCNS} };
	my @CNShits;


	for my $curSp (@CNShitsSpecies) {
		push @CNShits, @{ $mapAlignmentDeepCNS{$curCNS}{$curSp} };
	}

	my $CNSBreakpointsRef = getCNSbreakpoints($CNSLength, \@CNShits );
	my @CNSBreakpoints = @$CNSBreakpointsRef;

	### If we have breakpoints, break the CNS, polish and reassign all hits
	if(@CNSBreakpoints >2) {
		if($verbose) { print "PROGRESS: Breaking CNS $curCNS. Length: $CNSLength. Breakpoints: " . join(",", @CNSBreakpoints) . "\n"; }
		my $polishedAlignmentsRef = polishCNSAlignments(\@CNSBreakpoints, \@CNShits);
		my @polishedAlignments = @$polishedAlignmentsRef;

		for my $curBreakpoint (0.. ((scalar @CNSBreakpoints) - 2)) {
			### Create a new sub-CNS
			my $newSubCNSName = "$curCNS.$CNSBreakpoints[$curBreakpoint]";

			## Build the CNS
			my ($newAbsStart, $newAbsEnd);
			if($CNSforLocus{$curCNS}{'Strand'} eq "+" ) {
				$newAbsStart = $CNSforLocus{$curCNS}{'absStart'} + $CNSBreakpoints[$curBreakpoint];
				$newAbsEnd = $CNSforLocus{$curCNS}{'absStart'} + $CNSBreakpoints[$curBreakpoint+1]-1;
			} else {
				$newAbsStart = $CNSforLocus{$curCNS}{'absEnd'} - $CNSBreakpoints[$curBreakpoint+1];
				$newAbsEnd = $CNSforLocus{$curCNS}{'absEnd'} - $CNSBreakpoints[$curBreakpoint]-1;
			}

			$CNSforLocus{$newSubCNSName} = {
				'Name' => $newSubCNSName,
				'Start' => $CNSforLocus{$curCNS}{'Start'} + $CNSBreakpoints[$curBreakpoint],
				'End' => $CNSforLocus{$curCNS}{'Start'} + $CNSBreakpoints[$curBreakpoint+1]-1,
				'PositionInCompositeCNS' => $CNSBreakpoints[$curBreakpoint],				
				'Locus' => $CNSforLocus{$curCNS}{'Locus'},
				'Chromosome' => $CNSforLocus{$curCNS}{'Chromosome'},
				'absStart' => $newAbsStart,
				'absEnd' => $newAbsEnd,
				'Strand' => $CNSforLocus{$curCNS}{'Strand'},
				'NumberOfSpecies' => 0,
				'ConservationLevel' => $CNSforLocus{$curCNS}{'ConservationLevel'},
				'ORF' => $CNSforLocus{$curCNS}{'ORF'},
				'ORFDir' => $CNSforLocus{$curCNS}{'ORFDir'},
				'omega' => $CNSforLocus{$curCNS}{'omega'},
				'ancesteralSequence' => substr($CNSforLocus{$curCNS}{'ancesteralSequence'}, $CNSBreakpoints[$curBreakpoint], $CNSBreakpoints[$curBreakpoint+1] - $CNSBreakpoints[$curBreakpoint]),
				'referenceSequence' => substr($CNSforLocus{$curCNS}{'referenceSequence'}, $CNSBreakpoints[$curBreakpoint], $CNSBreakpoints[$curBreakpoint+1] - $CNSBreakpoints[$curBreakpoint])
			};
			$cnsReferenceLength{$newSubCNSName} = $CNSBreakpoints[$curBreakpoint+1] - $CNSBreakpoints[$curBreakpoint] ;

			my $numberOfHitsReassigned=0;
			## Reassign deep alignments
			foreach my $curHit (@polishedAlignments) {
				### If there is an overlap, assign the deep CNS to the new subCNS.

				if(overlap($curHit->{'ReferenceRelativePosition'}, $curHit->{'ReferenceRelativePosition'} + $curHit->{'Length'},
						   $CNSforLocus{$newSubCNSName}{'PositionInCompositeCNS'}, $CNSforLocus{$newSubCNSName}{'PositionInCompositeCNS'} + $cnsReferenceLength{$newSubCNSName})>$minCNSCoverageAfterSplit) {

					if(not defined $mapAlignmentDeepCNS{$newSubCNSName}{ $curHit->{'TargetSpecies'} }) {
						$mapAlignmentDeepCNS{$newSubCNSName}{ $curHit->{'TargetSpecies'} } = [];
					}

					push @{ $mapAlignmentDeepCNS{$newSubCNSName}{ $curHit->{'TargetSpecies'} } }, {
							"ReferenceLocus" => $newSubCNSName,
							"ReferenceRelativePosition" => max( 0, $curHit->{'ReferenceRelativePosition'} - $CNSforLocus{$newSubCNSName}{'PositionInCompositeCNS'}) ,
							"ReferenceUpDown" => $curHit->{'ReferenceUpDown'},
							"Length" => min($curHit->{'Length'}, $cnsReferenceLength{$newSubCNSName}),
							"TargetSpecies" => $curHit->{'TargetSpecies'},
							"TargetLocus" => $curHit->{'TargetLocus'},
							"TargetSequence" => $curHit->{'TargetSequence'},
							"TargetRelativePosition" => $curHit->{'TargetRelativePosition'} }; 
					$numberOfHitsReassigned++;
				}
			}
			if($verbose) { print "PROGRESS: Sub CNS $newSubCNSName (Length:$cnsReferenceLength{$newSubCNSName}) has $numberOfHitsReassigned alignments.\n"; }
		}
		### Finally, delete the original CNS
		delete $mapAlignmentDeepCNS{$curCNS};
		delete $cnsReferenceLength{$curCNS};
		delete $CNSforLocus{$curCNS};
	}
}

#####################################################################
## Filter CNS for unlikely and sporious alignments
## Then classify the conservation level of the CNS 

### Filter CNSs that switch position (up to downstream)

my $spToDelete;
foreach my $curCNS (keys %mapAlignmentDeepCNS) {
	foreach my $curSpeciesAlignment (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
		$spToDelete = "";
		foreach my $curAlignment ( @{ $mapAlignmentDeepCNS{$curCNS}{$curSpeciesAlignment} } ) {
			if(($CNSforLocus{$curCNS}{'Start'}<0) && ($curAlignment->{'TargetRelativePosition'} >0)) {
				$spToDelete = $curSpeciesAlignment;
			}
			if(($CNSforLocus{$curCNS}{'Start'}>0) && ($curAlignment->{'TargetRelativePosition'} <0)) {
				$spToDelete = $curSpeciesAlignment;
			}
			if($spToDelete ne "") {
				if($verbose) { print "PROGRESS: Deleting alignment of $curSpeciesAlignment to $curCNS because of mismatched positions. Target position: " . $curAlignment->{'TargetRelativePosition'} . ".\n"; }
			}
		}
		if($spToDelete ne "") {
			delete $mapAlignmentDeepCNS{$curCNS}{$curSpeciesAlignment};
		}
	}
}

##### Filter CNS that are too distant without sufficient support

foreach my $curCNS (keys %mapAlignmentDeepCNS) {
  my @CNSConservationLevel= ( (0) x $CLASSIFICATION_CLASSES_NUM );	 
  my $numberOfSpecies = keys %{ $mapAlignmentDeepCNS{$curCNS} };

  #### Now calculate conservation levels
  my @referenceClassification = split /-/ , $speciesClassification{$referenceGenomeSpecies};
  foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
  	  my @classification = split /-/ , $speciesClassification{$curSpecies};
    	foreach my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {	
    	 	if($referenceClassification[$curClassificationLevel] ne $classification[$curClassificationLevel]) {
    	 	 	$CNSConservationLevel[$curClassificationLevel]++;
    	 	}
    	}
  }
  if($verbose) { print "PROGRESS: Testing CNS $curCNS. $numberOfSpecies species have the CNS. Conservation levels are (" . join(",",@CNSConservationLevel) .").\n"; }
  	  
  # check for possible misalignments by making sure we are not skipping levels.
  	  
  foreach my $levelToCheck ( 1..($CLASSIFICATION_CLASSES_NUM-1)) {
   	  if(($CNSConservationLevel[$levelToCheck] == $CNSConservationLevel[$levelToCheck+1] && $CNSConservationLevel[$levelToCheck]==1)
	  	  || $numberOfSpecies < $minSpeciesPerConservationLevel[$levelToCheck]
		  || $CNSConservationLevel[$levelToCheck] < $minSpeciesAtConservationLevel[$levelToCheck]) {
   	  	  if($verbose && $CNSConservationLevel[$levelToCheck]>0) { print "PROGRESS: Found possible sporious alignment for $curCNS at level " . ($CLASSIFICATION_CLASSES_NUM-$levelToCheck) . ".\n"; }

  	  	  if($verbose && ($numberOfSpecies < $minSpeciesPerConservationLevel[$levelToCheck] && $CNSConservationLevel[$levelToCheck]>0)) {
			print "PROGRESS: Number of species too low to support alignments at level " . ($CLASSIFICATION_CLASSES_NUM-$levelToCheck) . ".\n";
		}
  	  	  ### Remove the misalignment
		  foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
		  	  my @classification = split /-/ , $speciesClassification{$curSpecies};
		  	  if($classification[$levelToCheck] ne $referenceClassification[$levelToCheck]) {
  	  	  	  	if($verbose) { print "PROGRESS: Removing alignment of $curSpecies for $curCNS.\n"; }
				delete ($mapAlignmentDeepCNS{$curCNS}{$curSpecies});
				$numberOfSpecies--;
			  }
		  }
  	  }
  }
  ### Recalculate conservation levels after filtering
  @CNSConservationLevel= ( (0) x $CLASSIFICATION_CLASSES_NUM );	  

  foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {
  	  my @classification = split /-/ , $speciesClassification{$curSpecies};
    	foreach my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {	
    		if($referenceClassification[$curClassificationLevel] ne $classification[$curClassificationLevel]) {
    			$CNSConservationLevel[$curClassificationLevel]++;  
    	 	 }
   	  }
  }
	
  # Now mark the "Deepness" level of each CNS
  $CNSforLocus{$curCNS}{'ConservationLevel'}="Family";
  foreach my $curLevel (0..$CLASSIFICATION_CLASSES_NUM) {
  	  if($CNSforLocus{$curCNS}{'ConservationLevel'} eq "Family" && $CNSConservationLevel[$curLevel]>0) {
  	  	  $CNSforLocus{$curCNS}{'ConservationLevel'}="Level" . ($CLASSIFICATION_CLASSES_NUM-$curLevel);
  	  }
  }
  $CNSforLocus{$curCNS}{'NumberOfSpecies'}=$numberOfSpecies;
}
  
if($verbose) { print "PROGRESS: End analysis for $referenceGenome:$locus. Writing output files...\n";	}
  
  
###########################################################
#### Now we are done. Export CNS table and position maps  
  
open(my $finalCNSFile, ">$finalCNSFileName");
open (my $finalMapFile, ">$finalMapFileName");
foreach my $curCNS (keys %CNSforLocus) {
	print $finalCNSFile "$referenceGenome,$curCNS,$CNSforLocus{$curCNS}{'Chromosome'},$CNSforLocus{$curCNS}{'Strand'},$CNSforLocus{$curCNS}{'absStart'},$CNSforLocus{$curCNS}{'absEnd'},$CNSforLocus{$curCNS}{'Locus'},$CNSforLocus{$curCNS}{'Start'},$CNSforLocus{$curCNS}{'End'},$CNSforLocus{$curCNS}{'ConservationLevel'},$CNSforLocus{$curCNS}{'NumberOfSpecies'},$CNSforLocus{$curCNS}{'ORF'},$CNSforLocus{$curCNS}{'ORFDir'},$CNSforLocus{$curCNS}{'omega'},$CNSforLocus{$curCNS}{'ancesteralSequence'}\n";
  	print $finalMapFile "$curCNS,$referenceGenomeSpecies,$locusFullName,$CNSforLocus{$curCNS}{'Start'},0," . ($CNSforLocus{$curCNS}{'End'} - $CNSforLocus{$curCNS}{'Start'}) . "," . $CNSforLocus{$curCNS}{'referenceSequence'} . "\n";
} 
close($finalCNSFile);

## First output the family alignments
foreach my $curSpecies (keys %{ $mapAlignmentFamily{$locusFullName} }) {
	foreach my $curHit ( @{ $mapAlignmentFamily{$locusFullName}{$curSpecies} } ) {
		## Find the CNS that overlaps this alignment
		my ($start,$end);
		if($curHit->{'ReferenceUpDown'} eq "U") {
			$start = $curHit->{'ReferenceRelativePosition'} - $upstreamLengthReference{$locusFullName};
		} else {
			$start = $curHit->{'ReferenceRelativePosition'};
		}
		$end = $start + $curHit->{'Length'};
		
		foreach my $curCNS (keys %CNSforLocus) {
			### Check for overlap. translate coordinates from relative to locus to
			###  relative to CNS and output alignment line

			if (overlap($start, $end, $CNSforLocus{$curCNS}{'Start'}, $CNSforLocus{$curCNS}{'End'})) {
				### This is the family alignment - so the alignments are for the whole region, before identification of phyloP conservation
				### Trim the alignment to the conserved region

				my $startInAlignment = $CNSforLocus{$curCNS}{'Start'} - $start;
				my $endInAlignment =  min($CNSforLocus{$curCNS}{'End'},$end) - $start;
				my $newStart = max( $start, $CNSforLocus{$curCNS}{'Start'} );
				my $newEnd = min($CNSforLocus{$curCNS}{'End'},$end);
				my $startInCNS = max(0, $start - $CNSforLocus{$curCNS}{'Start'});

				$curHit->{'Length'} = $newEnd - $newStart;
				$curHit->{'Start'} = $newStart;
				$curHit->{'End'} = $newEnd;
				my $cnsHitSeq = substr($curHit->{'TargetSequence'}, $startInAlignment, $curHit->{'Length'});
				# Change N back to gaps
				$cnsHitSeq =~ s/N/-/g;
				print $finalMapFile "$curCNS,$curSpecies,$curHit->{'TargetLocus'},$curHit->{'TargetRelativePosition'},$startInCNS,$curHit->{'Length'},$cnsHitSeq\n";
			}
		}
	}
}
  
### Then the deep CNS alignments
foreach my $curCNS (keys %CNSforLocus) {
	foreach my $curSpecies (keys %{ $mapAlignmentDeepCNS{$curCNS} }) {	  	   	  	  
		foreach my $curHit ( @{ $mapAlignmentDeepCNS{$curCNS}{$curSpecies} } ) {
			print $finalMapFile "$curCNS,$curSpecies,$curHit->{'TargetLocus'},$curHit->{'TargetRelativePosition'},$curHit->{'ReferenceRelativePosition'},$curHit->{'Length'},$curHit->{'TargetSequence'}\n";
		}
    }
}
 	
close($finalMapFile);

#### Go back to the original directory, and we are done!
chdir $curDir;	

if($verbose) { print "DONE: End $referenceGenome:$locus.\n";	}

###############################################################################################################################


###### utility functions #######################################################

## Returns the mean value of an array of integers
sub mean {
    return sum(@_)/@_;
}

####################################################################################################################################
#### Extract sequence for locus from a compressed fasta file, filter for low-information sequence and output to a seperate fasta file
####    and return the filtered sequence

sub extractFastaToFile {
	(my $fastaFile, my $locus, my $outputFastaFile) = @_;

	open (my $inFasta, "samtools faidx $fastaFile $locus |");
	my $fastaHeader = <$inFasta>;
	chomp($fastaHeader);
	my $seq;
	my @seqLines;
	while(my $curLine = <$inFasta>) {
		chomp($curLine);
		push @seqLines, $curLine;
	}
	close($inFasta);
	$seq = join("", @seqLines);

	my $origSeq = $seq;
	### Now mask homopolymers and AT rich regions
	$seq = fuzzyFilterHomopolymers($seq,$homoPolymerFilterLength,0);  

	$seq = fuzzyFilterATRich($seq,$atRichRegionFilterLength,0);   
	$seq = fuzzyFilterDimers($seq, $dimerPolymerFilterLength,0);
	### and repeating trimers
	$seq =~ s/([C|G|A]TT){4}/XXXXXXXXXXXX/g;
	#### and repeating tetramers
	$seq =~ s/(TCTA){4}/XXXXXXXXXXXXXXXX/g;
	### and ambigious sequences
	$seq =~ s/N/$filterCharacter/g;

	## and write to file
	open(my $outFasta, ">$outputFastaFile");
	print $outFasta "$fastaHeader\n$seq\n";
	close($outFasta);

	return ($seq);
}

##### Fuzzy filter homopolymers

### fuzziness is the number of mismatch positions allowed (either 0 or 1)
sub fuzzyFilterHomopolymers {
	my ($inSeq, $polymerLength, $fuzziness) = @_;
	my @inSeqArr = split //, $inSeq;
	my @polymers = ('A' x $polymerLength,
					'T' x $polymerLength,
					'C' x $polymerLength,
					'G' x $polymerLength);

	my $fuzzySearchString="(?=($polymers[1]";
	my @replacementArr = ($filterCharacter) x $polymerLength;

	for my $curPolymer (@polymers) {
		if($fuzziness == 1) {
			for my $curNuc (1..$polymerLength) {
				my $curSearch = $curPolymer;
				substr($curSearch,$curNuc-1,1) = ".";
				$fuzzySearchString .= "|$curSearch"
			}
		} else {
			$fuzzySearchString .= "|$curPolymer";
		}
	}
	$fuzzySearchString .= "))";
	
	my @polymerOccurences;
	$_ = $inSeq;

	while(/$fuzzySearchString/g) {
		push @polymerOccurences, pos();
	}
	foreach my $curPos (@polymerOccurences) {
		@inSeqArr[$curPos..($curPos+($polymerLength-1))] = @replacementArr;
	}

	return join("", @inSeqArr);
}

##### Fuzzy filter for repeating dimers sequences
## Fuzziness is 0 or 1 (number of mismatches accepted)
sub fuzzyFilterDimers {
	my ($inSeq, $polymerLength, $fuzziness) = @_;
	my @inSeqArr = split //, $inSeq;
	my @replacementArr = ($filterCharacter) x ($polymerLength * 2);
	my @dimerPolymers;

	for my $nuca ( ('A','T','C','G')) {
		for my $nucb ( ('A','T','C','G')) {
			if($nuca ne $nucb) {
				push @dimerPolymers, ("$nuca$nucb" x $polymerLength);
			}
		}
	}

	my $fuzzySearchString="(?=($dimerPolymers[1]";

	for my $curPolymer (@dimerPolymers) {
		if($fuzziness==1) {
			for my $curNuc (1..($polymerLength*2-1)) {
				my $curSearch = $curPolymer;
				substr($curSearch,$curNuc-1,1) = ".";
				$fuzzySearchString .= "|$curSearch"
			}
		} else {
				$fuzzySearchString .= "|$curPolymer"
		}
	}
	$fuzzySearchString .= "))";

	## Now collected all the places where there is a match (accepting overlapping regions)
	my @dimerOccurences;
	$_ = $inSeq;

	while(/$fuzzySearchString/g) {
		push @dimerOccurences, pos();
	}

	## Now mask Seq
	foreach my $curPos (@dimerOccurences) {
		@inSeqArr[$curPos..($curPos+($polymerLength*2-1))] = @replacementArr;
	}

	return join("", @inSeqArr);
}

########################################################################################
### Fuzzy filter AT rich regions
###

sub fuzzyFilterATRich {
	my ($inSeq, $ATrichLength, $fuzziness) = @_;
	my @replacementArr = ($filterCharacter) x $ATrichLength;

	my $translatedInSeq = $inSeq;
	$translatedInSeq =~ tr/ATCGXN/001111/;

	my @inSeqArr = split //, $inSeq;
	my @inSeqTrArr = split //, $translatedInSeq;
	my $seqLength = (scalar @inSeqArr)-$ATrichLength-1;
	my @ATrichPos;

	## Look for AT rich positions
	foreach my $curPos (0..$seqLength) {
		if(sum(@inSeqTrArr[$curPos..($curPos+$ATrichLength)])<=$fuzziness) {
			push @ATrichPos, $curPos;	
		}
	}
	## Now mask Seq
	foreach my $curPos (@ATrichPos) {
		@inSeqArr[$curPos..($curPos+$ATrichLength-1)] = @replacementArr;
	}

	return join("", @inSeqArr);

	return($inSeq);
}


### Get the overall quality score from a MAF alignment file
sub getMAFQuality {
	my ($MAFFileName) = @_;

	open (my $m, $MAFFileName);
	my $maf = Bio::AlignIO->new(-fh => $m, -format => 'maf');
	my $quality =0;
	while(my $aln = $maf->next_aln()) {
		$quality = $quality + $aln->score;
	}
	close($m);
	return $quality;
}

#####################################################################
### Run the sequence alignment without terminal output
sub quietAlign {
	my ($toalign) = @_;
	######## T-coffee alignment	
#	my $aligner = Bio::Tools::Run::Alignment::TCoffee->new(('quiet' => 1,  'dp_mode' => 'fasta_pair_wise'));
#	$aligner->io->_io_cleanup();
#	my ($infilename,$type) = $aligner->_setinput($toalign);
#	my $param_string = $aligner->_setparams(); # . " >/dev/null";
#	my $alignment = $aligner->_run('align', [$infilename,$type], $param_string);
	######### Muscle alignment
	my $aligner = Bio::Tools::Run::Alignment::Muscle->new(('quiet' => 1, 'max_iter' => 2, 'diags' => 1));
	my $alignment = $aligner->align($toalign);

	return $alignment;
}

########################################################################################
#### Removes the asterix that some programs use to mark stop and other programs hate

sub dropAsterixFromProtein {
	my ($seqObj) = @_;
	my $seq = $seqObj->seq();
	$seq =~ s/\*//g;
	$seqObj->seq($seq);
	return $seqObj;
}
##################################################################################
# Returns the species name from the name of a gene

sub geneToSpecies {
	(my $geneName) = @_;
	$geneName =~ s/-.*$//;
	return $geneName;
}

###################################################################################
# Returns just the locus name from the name of a gene
sub fullNameToShortName {
	(my $geneName) = @_;
	$geneName =~ s/^.[^-]*-[^-]*-//;
	return $geneName;
}

###
sub findAll {
	my ($seq, $substring) = @_;
	my @occurences;
	my $offset=0;
	
	my $result = index($seq, $substring, $offset);

	while( $result != -1) {
		push (@occurences, $result);
		$offset = $result + 1;
		$result = index($seq, $substring, $offset);
	}
	return @occurences;
}

#############################################################
### Returns the length of a sequence without the gaps

sub lengthWithoutGaps {
	my $seq = $_[0];
	return length($seq =~ s/-//rg);
}

#############################################################################3
### Compute overlap between two fragments. 
### Parameters:
### overlap(startOne, endOne, StartTwo, endTwo, mode)
### mode can be "ABS", in which case returns the absolute overlap in bp
### else, returns relative overlap (0-1).
###

sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo, $mode) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		#### return the percent overlap
		if($endOne < $endTwo) {
			if($startOne >= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endOne -$startTwo);
				} else {
					return ($endOne -$startTwo) /($endOne - $startOne);
				}
			} 
		} else {
			if($startOne <= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);					
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endTwo -$startOne);
				} else {
					return ($endTwo -$startOne) /($endOne - $startOne);
				}
			} 			
		}
	}
}

################### Load MAF file and return a FASTA array in reference coordinates
# alignmentLengthFilter is a number 0-1 indicating what is the minimum overlap (in percent) of the alignment to the reference species
#  to consider as a real alignment.
#

sub MAFtoFASTA {
	(my $mafFileName, my $seqLengthRef, my $targetSeqLength, my $inFASTARef,my $mapRef, my $dir, my $alignmentLengthFilter) = @_;
	
	my $refseqname;
	my $reflocus;
	my $refstart = -1;
	my $reflen;
	my @insertions;

	my $maffile = Bio::AlignIO->new(-file => $mafFileName,
					-format => "maf") || die ("");

	while(my $aln = $maffile->next_aln) {
	   $reflocus="";
	   $refseqname="";
	   foreach my $alignseq ($aln->each_seq() ) {
	   	   my $locus = $alignseq->id();
	   	   my $species = geneToSpecies($locus);
	   	   my $newspseq = $alignseq->seq();
	   	   
		   if($refseqname eq "") {
			 $refseqname = $species;
			 $reflocus=$locus;
		   }

		   if(not defined $inFASTARef->{$reflocus}{$species}) {
		       $inFASTARef->{$reflocus}{$species} = "N" x $seqLengthRef->{$reflocus};
		   }


		   if($species eq $refseqname) {
	   		 # Identify all insertions from the sequence to keep the seq in reference coordinates		 
		   	 @insertions = findAll($newspseq, "-");
		   }

   		   #now remove the insertions
   		   foreach ( @insertions ) {
   		   	   substr($newspseq, $_,1) = "Z";
   		   }
   		   
		   ### Replace all gaps with N because phyloP doesn't like gaps.
			
		   $newspseq =~ s/Z//g;
		   $newspseq =~ s/-/N/g;
		   
		   if($refstart == -1) {
			$refstart = $alignseq->start()-1;
			$reflen = length($newspseq);
		   } else {

			
			#### Log the alignment, if it is at the right length
			if($verbose && $alignmentLengthFilter >0 &&  $reflen < $alignmentLengthFilter*$seqLengthRef->{$reflocus}) {
				print "PROGRESS: Rejected alignment to $reflocus because length is too short ($reflen). CNS length: " . $seqLengthRef->{$reflocus} . "\n";
			} 
			if($alignmentLengthFilter==0 || $reflen >= $alignmentLengthFilter*$seqLengthRef->{$reflocus} ) {
				my $refRelative, my $targetRelative;
				$refRelative = $refstart;
				if($dir eq "U") {
					$targetRelative = $alignseq->start() -1 - $targetSeqLength;
				} else {
					$targetRelative = $alignseq->start() - 1;
				}
				if(not defined $mapRef->{$reflocus}{$species}) {
					$mapRef->{$reflocus}{$species} = [];
				}
				my $targetSequence = $newspseq;
				$targetSequence =~ s/N//g;

				push @{ $mapRef->{$reflocus}{$species} }, {
					"ReferenceLocus" => $reflocus,
					"ReferenceRelativePosition" => $refRelative,
					"ReferenceUpDown" => $dir,
					"Length" => $reflen,
					"TargetSpecies" => $species,
					"TargetLocus" => $locus,
					"TargetRelativePosition" => $targetRelative,
					"TargetSequence" => $newspseq }; 
  		   		}

		   		# Check if we are overriding sequences
		   		my $curspseq = substr($inFASTARef->{$reflocus}{$species}, $refstart, $reflen);
		   		if( $curspseq eq  "N" x length($curspseq)) {
			   		my $tmpseq = $inFASTARef->{$reflocus}{$species};
		   	   		substr($tmpseq, $refstart, $reflen) = $newspseq;
			   		$inFASTARef->{$reflocus}{$species} = $tmpseq;
		   		} else {
				# if there was something there, merge the sequences
				if(substr($inFASTARef->{$reflocus}{$species}, $refstart, $reflen) ne $newspseq) {
					
					my $curseq = substr($inFASTARef->{$reflocus}{$species}, $refstart, $reflen);
					my $refseq = substr($inFASTARef->{$reflocus}{$refseqname}, $refstart, $reflen);
					my $conseq;
					for my $curchr (0 .. $reflen) {
						my $selectedMergedNuc;
						# if one is a gap, pick the nucleotide
						if(substr($curseq, $curchr,1) eq "N") {
							$selectedMergedNuc = substr($newspseq,$curchr,1);
						} elsif (substr($newspseq, $curchr,1) eq "N") {
							$selectedMergedNuc = substr($curseq,$curchr,1);
						} else { #if we have a conflict - pick the one that is similar to the reference (### Pick the first one)
							if((substr($curseq,$curchr,1) eq substr($refseq,$curchr,1)) || (substr($curseq,$curchr,1) eq substr($refseq,$curchr,1))) {
#								$selectedMergedNuc = substr($refseq,$curchr,1);
								$selectedMergedNuc = substr($curseq,$curchr,1);
							} else {
								$selectedMergedNuc = substr($curseq,$curchr,1); # or if not, the default is the first one.
							}
						}
						$conseq .= $selectedMergedNuc;
					}
					my $tmpseq = $inFASTARef->{$reflocus}{$species};
					substr($tmpseq, $refstart, $reflen) = $conseq;
			   		$inFASTARef->{$reflocus}{$species} = $tmpseq;
				}
			}
		}
	   }
	   $refstart = -1;
	}
}

#####################################################################
##### Pick best ortholog

sub pickBestPutativeOrthologs {
	
	my (%orthologs) = @_;

	foreach my $curOrthSpecies (keys %orthologs) {
		# first, check if we have a consistent duplication. if not, pick the best alignment.
		# For consistent duplication it means that the number of genes is a multiple of the number of species.
		# if so, pick the best duplication group
		my @genomeNames;
		my @qScores;
		foreach my $curOrth (@{ $orthologs{$curOrthSpecies} }) {	
			my %derefCurOrth = %$curOrth; 
			push @genomeNames,  $derefCurOrth{'Genome'};		
			push @qScores, ($derefCurOrth{'UpQuality'} + $derefCurOrth{'DownQuality'}) ;
		}
		
		if( (scalar @{ $orthologs{$curOrthSpecies} }) / (scalar uniq ( @genomeNames )) > 1 ) {

			my @bestOrthologsGroup;
			my $bestQuality =0;
			my @genomesToTest = uniq ( @genomeNames );
			foreach my $curGenomeToTest ( @genomesToTest) {
				my @indexes = grep { @genomeNames[$_] eq $curGenomeToTest } 0 ..(scalar @genomeNames);
				
				my $meanQuality;
				if($orthologSelectionStrategy eq "bestmean") {
					$meanQuality = mean ( @qScores[@indexes] );
				} else {
					$meanQuality = sum ( @qScores[@indexes] );
				}
				if($meanQuality > $bestQuality) {
					$bestQuality = $meanQuality;
					@bestOrthologsGroup = @indexes;
				}
			}
		
			### Remove all temporary files
			foreach my $i (0..((scalar @qScores)-1)) {
				if( !($i ~~ @bestOrthologsGroup)) {
					if(!$keep_tmp) {
						unlink($orthologs{$curOrthSpecies}[$i]->{'upstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'downstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFUpFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFDownFileName'});
					}
				}
			}
			my %tmporth = %orthologs;
			$orthologs{$curOrthSpecies} = [ ];
			foreach my $i (@bestOrthologsGroup) {
				push( @ { $orthologs{$curOrthSpecies} },
					$tmporth{$curOrthSpecies}[$i]);
			}
			if($verbose) { print "PROGRESS: Picked CRE-ortholog for $curOrthSpecies:" . $orthologs{$curOrthSpecies}[0]->{'Genome'} . ".\t" . (scalar @{ $orthologs{$curOrthSpecies} }) . " Genes: ";
					       foreach my $i ( @{ $orthologs{$curOrthSpecies} }) { print $i->{'Name'} . ". "; }
					       print "\n";
			}

		} else {
			#### Only one possible gene. pick the best genome based on alignment quality scores.

			my $topQuality = max( @qScores);
			my $topQualityIdx = firstidx { $_ == $topQuality } @qScores;

			### Remove all temporary files
			foreach my $i (0..((scalar @qScores)-1)) {
				if($i != $topQualityIdx) {
					if(!$keep_tmp) {
						unlink($orthologs{$curOrthSpecies}[$i]->{'upstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'downstreamFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFUpFileName'});
						unlink($orthologs{$curOrthSpecies}[$i]->{'MAFDownFileName'});
					}
				}
			}
			
			## Now remove all the other genes
			$orthologs{$curOrthSpecies} = [ $orthologs{$curOrthSpecies}[$topQualityIdx] ];
			if($verbose) { print "PROGRESS: Picked CRE-ortholog for " . $orthologs{$curOrthSpecies}[0]->{'Genome'} . ".\t1 Gene: " . $orthologs{$curOrthSpecies}[0]->{'Name'} . ".\n"; }
		}
	}
	return %orthologs;
}


###################### ORF Processing functions
#### getLongestORF(DNSSequence, Strand) 
#####
#### Strand is optional (+ or -) to limit search to one strand. If not provided, ORFs are searched on both strands.
####

sub getLongestORF {
   my $seq = $_[0];
   my $strandToLookAt = $_[1];
   $seq =~ s/-//g;
   
   my $best=0;
   my ($bests,$beste,$beststrand)=(-1,-1,0);
   my $dna=Bio::Seq->new(-seq => $seq);
   my %strand;
   
   if ($strandToLookAt eq "+") {
   	   %strand=('+'=>$dna->seq);
   } elsif($strandToLookAt eq "-") {
  	   %strand=('-'=>$dna->revcom->seq);
   } else {
   	   %strand=('+'=>$dna->seq,
               '-'=>$dna->revcom->seq);
   }
   
   foreach my $direction (keys %strand) {
      my @starts=();
      my @ends=();
      for (my $frame=0;$frame< length($seq)-3;$frame++) {
         unless ($strand{$direction}=~m/^.{$frame}(taa|tga|tag)/i) {
            push @starts,$frame+1;
         }
      }
 
      while ($strand{$direction}=~m/(taa|tga|tag)/gi) {
         push @ends,pos($strand{$direction})-2;
      }
      push @ends,($dna->length+2,$dna->length+1,$dna->length);


      for my $s (@starts) {
         for my $e (@ends) {
            if ($e%3==$s%3 and $e>$s) {
               my $ORFlength = $e-$s;
               if($e > $dna->length) {
                  $ORFlength -= ($e - $dna->length -1);
                  ### If we have partial codon - remove it
                  $ORFlength -= ($ORFlength%3);
               }
               if ($ORFlength >$best) {
                  $best= $ORFlength;
                  ($bests,$beste,$beststrand)=($s,$e,$direction);
               }
               last
            } else {
               next
            }
         }
      }
   }
   my $bestORF;
   if($beststrand eq "+") {
   	   $bestORF = substr($dna->seq,$bests-1, $best)
   } else {
   	   $bestORF = substr($dna->revcom->seq,$bests-1, $best)
   }
   
   return (length($bestORF), $bestORF, $beststrand ); ## Returns the length of the longest ORF and its sequence	
}


##### determine the expected random ORF based on GC content of cns
### Based on Oliver and Marin, Journal of Molecular Evolution, 1996 43:216-223.
###
sub getRandomORFLength {
	my $LENGTH_FACTOR = 2;
	my $randomORFLength;
	
	my $sequence = $_[0];
	my $seqstr = $sequence;
	my $gcCNS = length($seqstr =~ s/[A|T|N]//rg);
	$seqstr = $sequence;
	my $atCNS = length($seqstr =~ s/[G|C|N]//rg);

	my $q= (1-$gcCNS/($gcCNS+$atCNS))/2;
	my $t= $q**2 - $q**3;
	if($t == 0) {
		$randomORFLength=1000;
	} else {
		$randomORFLength = ceil(1/$t)*3*$LENGTH_FACTOR+1;
	}
	return $randomORFLength;
}

############################################################################################################3
#### CNS processing functions

### Accepts an array of hits hashes and returns the breakpoints

sub getCNSbreakpoints {
	my ($CNSLength, $hitsRef) = @_;
	my @hits = @$hitsRef;
	my @CNSCoverage = (0) x $CNSLength;

	foreach my $curHit (@hits) {
		my $start = $curHit->{'ReferenceRelativePosition'};
		my $end = $start + $curHit->{'Length'};
		foreach my $pos ($start..$end) { $CNSCoverage[$pos]++; }
	}

	### Change point detection. Our data is generally well behaved with few outliers (if any)
	### we do a simple change detection algorithm. 
	#####  1. Calculate delta between points. 2. Find the stdev of the delta. 3. Identify places where delta is high (3xstdev),
	#####    Don't break if creating too small of a fragment (<$minCNSLength)

	#### Calculate the dX
	my @CNSdelta = (0) x $CNSLength;
	foreach my $pos (0..((scalar @CNSCoverage)-2)) {
		$CNSdelta[$pos+1] = $CNSCoverage[$pos+1] - $CNSCoverage[$pos];
	}
	my $deltaSD = stddev(@CNSdelta);

	## Now identify breakpoints.
	###
	my @breakpoints;
	my $lastBreakpointPos=0;

	foreach my $pos (0..(scalar @CNSdelta)) {
		### split CNS if larger than minCNSlength and high variability. But don't split CNS if its too short, has too many species
		## or if the split point is not well supported
		if((abs($CNSdelta[$pos]) > $deltaSD *3) && (abs($CNSdelta[$pos])> $minSpeciesToSplitCNS ) && 
		 ($pos - $lastBreakpointPos > $minCNSLength ) && ($CNSCoverage[$pos]< $maxSpeciesToInitiateCNSSplit && $CNSCoverage[$pos+1]< $maxSpeciesToInitiateCNSSplit)) {
			if($verbose) { print "PROGRESS: Splitting CNS at $pos (" . abs($CNSdelta[$pos]) . "," . $CNSCoverage[$pos] . ").\n"; }
			push @breakpoints, $pos;
			$lastBreakpointPos = $pos;
		}
	}
	# Add start and end points
	@breakpoints = (0, @breakpoints , $CNSLength);
	return \@breakpoints;
}

sub polishCNSAlignments {
	my ($breakpointRef, $alignmentMapRef) = @_;
	my @breakpoints = @$breakpointRef; 
	my @alignmentMap = @$alignmentMapRef;

	foreach my $curHit (@alignmentMap) {
		my $start =  $curHit->{'ReferenceRelativePosition'};
		my $end = $start + $curHit->{'Length'};
		### Find closest breakpoints
		my $minStart= abs($start - $breakpoints[0]);
		my $minEnd= abs($end - $breakpoints[0]);
		my $startBreakpoint=0;
		my $endBreakpoint=0;
		for my $curBreakpoint (0..(scalar @breakpoints) ) {
			if( abs($start - $breakpoints[$curBreakpoint]) < $minStart) {
				$minStart = abs($start - $breakpoints[$curBreakpoint]);
				$startBreakpoint= $curBreakpoint;
			}
			if( abs($end - $breakpoints[$curBreakpoint]) < $minEnd) {
				$minEnd = abs($end - $breakpoints[$curBreakpoint]);
				$endBreakpoint= $curBreakpoint;
			}
		}
		#print "Polishing: $start-$end to " . $breakpoints[$startBreakpoint] . "-" . $breakpoints[$endBreakpoint] . "\n";
		$curHit->{'ReferenceRelativePosition'} = $start;
		$curHit->{'Length'} = $end - $start;
	}
	return \@alignmentMap;
}
