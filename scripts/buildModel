#!/usr/bin/perl

use POSIX;
use strict;
use Text::CSV;
use List::Util qw(min max sum);
use List::MoreUtils qw(uniq firstidx);
use Bio::AlignIO;
use Bio::SeqIO;
use Cwd;
use Cwd 'abs_path';
use Getopt::Long;
use experimental 'smartmatch';
use Bio::Tools::Run::Alignment::Muscle;
use Bio::Align::Utilities;


################################################################################
######### Setup
$|=1;

my @fourLetterCodons = ("CT","GT","GC","AC","TC","CC","CG","GG");

my $conservatoryDir=abs_path(".");
my $referenceGenome="";
my $referenceGenomeFamily;
my $treeFileName;
my $maxSeq =1000;
my $numOfGenesUsed=0;
my $help=0;



GetOptions ("conservatory-directory=s" => \$conservatoryDir,
			"reference=s" => \$referenceGenome,
			"tree=s" => \$treeFileName,
			"help" => \$help) or die ("Error in command line arguments\n");

if($help || $referenceGenome eq "" || $treeFileName eq "") {
   print "\n\tbuildModel --reference <ReferenceGenome> \n\t\tbuildModel accepts a family (for which alignments have already been done) and a tree file\n\t\tand produces a model file for phyloP based on non-coding sequence data.\n\n";
   print "\t--conservatory-directory\tName of the conservatory directory. Default is current directory.\n";
   print "\t--reference\tName of the reference genome (REQUIRED).\n";
   print "\t--tree\t\tTree file for phyloFit (REQUIRED).\n";
   
   print "\t--help\t\tPrints this message.\n\n";
   
   exit();
}

my $genomedbFile = $conservatoryDir . "/genome_database.csv";
my $alignmentDir ="$conservatoryDir/alignments/$referenceGenome";

die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;
die "ERROR: Cannot find file tree filename ($treeFileName)\n" unless -e $treeFileName;
die "ERROR: Conservatory directory structure at ($conservatoryDir) is corrupt\n" unless (-e $alignmentDir && -e "$conservatoryDir/scripts");

########## read genome database to get species list
my %genomesInFamily;
my %speciesInFamily;
my %genomeToSpecies;
my %proteinNameTranslator;
my %geneNameTranslator;
my %FourVarPosSequence;

open (my $genomeDatabase, "<", $genomedbFile);
my $header = <$genomeDatabase>;
while((my $curgenomeline = <$genomeDatabase>)) {
	my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
	$genomesInFamily{$curgenomeFamily}{$curgenomeName}=1;
	$speciesInFamily{$curgenomeFamily}{$curgenomeSpecies}=1;
	
	if(defined $genomeToSpecies{$curgenomeName}) { die "ERROR: Genome name must be unique ($curgenomeName).\n"; }
	
	$genomeToSpecies{$curgenomeName}= $curgenomeSpecies;
	$proteinNameTranslator{$curgenomeName}= $proteinProcessingRegEx;
	$geneNameTranslator{$curgenomeName}= $geneProcessingRegEx;

	if($curgenomeName eq $referenceGenome) {
		$referenceGenomeFamily = $curgenomeFamily;
	}
}
close($genomeDatabase);
die "ERROR: Cannot find family for the reference genome ($referenceGenome) in the genome database file.\n" unless ($referenceGenomeFamily ne "");

print "INFO: START automatic phylogenetic model computation for $referenceGenome. Family: $referenceGenomeFamily.\n";
#### Now read the CDS and proteins files
my @speciesInReferenceFamily = keys %{ $speciesInFamily{$referenceGenomeFamily} };
my $numOfSpeciesInFamily = (scalar @speciesInReferenceFamily) -1;

my @genomesInReferenceFamily = keys %{ $genomesInFamily{$referenceGenomeFamily} };

my $genomesDir = "$conservatoryDir/genomes/$referenceGenomeFamily";

print "START: Reading proteins and CDS sequences.\n";
my %proteinSeqDB;
my %cdsSeqDB;
#@genomesInReferenceFamily = ();

foreach my $curGenome (@genomesInReferenceFamily) {
	print "PROGRESS: Reading $curGenome...\n";
	my $proteinTranslatorForGenome = $proteinNameTranslator{$curGenome};
	my $geneNameTranslatorForGenome = $geneNameTranslator{$curGenome};
	
	my $proteinSeqReader = Bio::SeqIO->new( -format => "fasta",
										   -file => "$genomesDir/$curGenome.proteins.fasta");
	while ( my $seq = $proteinSeqReader->next_seq() ) {
		### Convert seq name from protein to fullgenename
		my $locus = $seq->id();
		if($proteinTranslatorForGenome ne "") { eval '$locus =~ s/$proteinTranslatorForGenome//g;'; }
		$locus =~ s/ .*$//;
		my $fullGeneName = $genomeToSpecies{$curGenome} . "-$curGenome-$locus";
   		$proteinSeqDB{$fullGeneName} = $seq->seq();
	}
	my $cdsSeqReader = Bio::SeqIO->new( -format => "fasta",
						-file => "$genomesDir/$curGenome.cds.fasta");
	while ( my $seq = $cdsSeqReader->next_seq() ) {
		my $locus = $seq->id();
		if($geneNameTranslatorForGenome ne "") { eval '$locus =~ s/$geneNameTranslatorForGenome//g;'; }
		$locus =~ s/ .*$//;
		my $fullGeneName = $genomeToSpecies{$curGenome} . "-$curGenome-$locus";
   		$cdsSeqDB{$fullGeneName} = $seq->seq();
	}
}

#### Now look for all single orthologs
print "PROGRESS: Searching for one-to-one orthologs...";

my @singlehitOrthologs;
opendir my $alignmentDirReader, $alignmentDir;
my @CREorthologFiles = grep (/\.CREorthologs.txt/, readdir($alignmentDirReader) );

print " found " . scalar @CREorthologFiles . " candidates...";

foreach my $curCREOrth (@CREorthologFiles) {
	my %speciesInOrth;
	
	open( my $curCREOrthFile, "$alignmentDir/$curCREOrth") || die ("INTERNAL ERROR.\n");
	while(my $curLine = <$curCREOrthFile>) {
		my ($genome, $geneName) = split /\t/, $curLine;
		my $species = $geneName;
		$species =~ s/-.*$//;
		$speciesInOrth{$species}++;
	}
	close( $curCREOrthFile);
	if( (keys %speciesInOrth) == $numOfSpeciesInFamily && sum(values %speciesInOrth) < ($numOfSpeciesInFamily +5) ) {
		push @singlehitOrthologs, $curCREOrth;
	}
}

print " Found " . (scalar @singlehitOrthologs) . "\n";

if( (scalar @singlehitOrthologs) > $maxSeq) {
	@singlehitOrthologs = @singlehitOrthologs [ 1..$maxSeq ];

}

foreach my $CREOrthologsFileName (@singlehitOrthologs) {
	
	my @orthologProteins;
	my %orthologCDSs;
	my %orthologSpecies;
	my $error=0;
	
	open ( my $CREOrthologFile, "$alignmentDir/$CREOrthologsFileName") || die "Can't open $alignmentDir\$CREOrthologsFileName";
	
	while(my $curCREOrthologs = <$CREOrthologFile>) {
		
		my ($CRESpecies, $CREgenename) = split /\t/, $curCREOrthologs;
	#	print "Checking $CREgenename \n";
		if(! (defined $orthologSpecies{$CRESpecies})) {
			$orthologSpecies{$CRESpecies}=1;  #### Only one gene per species
			
			### Make sure we have the sequences in the database
			if((defined $proteinSeqDB{$CREgenename}) && (defined $cdsSeqDB{$CREgenename})) {
				
				my $proteinSeq = $proteinSeqDB{$CREgenename};
				### remove protein illegal embelishment
				$proteinSeq =~ s/\.//g;
				$proteinSeq =~ s/\*//g;				
				
				my $curProtein = Bio::LocatableSeq->new(-seq => $proteinSeq,
                        	                            -id => $CRESpecies,
                                                        -start => 1,
                                                       	-end => length($proteinSeq));
      
                my $curCDS = Bio::LocatableSeq->new(-seq => $cdsSeqDB{$CREgenename},
      	                	                        -id => $CRESpecies,
        	                                        -start => 1,
                	                                -end => length($cdsSeqDB{$CREgenename}));
                
                push @orthologProteins, $curProtein;
			    $orthologCDSs{$CRESpecies} =  $curCDS;
	#		    print "Adding $CREgenename \n";
			    
			} else {
				print "ERROR: Cannot find gene $CREgenename.\n";
				$error =1;
			}
		}
	}
	close($CREOrthologFile);
	
	if(! $error) {
		print "PROGRESS: $CREOrthologsFileName...\n";
		my $aligner = Bio::Tools::Run::Alignment::Muscle->new(('quiet' => 1));
		my $proteinAlignment = $aligner->align(\@orthologProteins);
	
		print ".Aligned...";
		my $cdsAlignment = Bio::Align::Utilities::aa_to_dna_aln($proteinAlignment, \%orthologCDSs);	
		print ".Translated...";
		$cdsAlignment = $cdsAlignment->remove_gaps();
		print $cdsAlignment->length() . "bp long...";
		if($cdsAlignment->length() >0) {

			my %fourPositionNucleotide;
			my @conservation = $cdsAlignment->consensus_conservation();
			my $consensus_sequence = $cdsAlignment->consensus_string(); 
			my $curPos=1;
			my @columnsToRemove;
			while($curPos < $cdsAlignment->length() ) {
				### If perfect conservation for position 1 and 2 of the codon;
				push @columnsToRemove, [($curPos)-1, ($curPos)];

				if(!( $conservation[$curPos] == 100 && $conservation[$curPos+1] ==100 && $conservation[$curPos+2] < 100 && substr($consensus_sequence,$curPos, 2) ~~ @fourLetterCodons)) {
					push @columnsToRemove, [($curPos + 1),($curPos + 1) ];
				}
				$curPos+=3;
			}
			my $just4posVar = $cdsAlignment->remove_columns(@columnsToRemove);	
			print "..identified " . $just4posVar->length() . " 4 var positions\n";
			if($just4posVar->length() >0) {
				foreach my $seq ($just4posVar->each_seq) {
					$FourVarPosSequence{ $genomeToSpecies{$seq->id()} } .= $seq->seq();
				}
			}
		}
	}
}

#print "INFO: Found $numOfAlignments alignments. Total alignment length: $numOfBp.\n";

####### Now dump fasta

my $tmpFastaFileName = "$alignmentDir/tmp/$referenceGenome.formodel.fasta";
open my $tmpFasta, ">$tmpFastaFileName";
foreach my $fastaSeq ( keys %FourVarPosSequence ) {
	print $tmpFasta ">$fastaSeq\n" . $FourVarPosSequence{$fastaSeq} . "\n";
}
close $tmpFasta;

print "INFO: Done prepping FASTA file.\n";
####### make Model
print "INFO: START computing model.\n";
system("phyloFit --tree $treeFileName --nrates 4 --subst-mod HKY85+GAP --out-root $referenceGenome $tmpFastaFileName");
#system("phyloFit --tree $treeFileName --nrates 4 --out-root $referenceGenome $tmpFastaFileName");
print "INFO: END computing model.\n";
#unlink($tmpFastaFileName);
#system("mv -f $referenceGenome.mod $conservatoryDir/genomes/$referenceGenome.mod");
print "INFO: DONE.\n";
