#!/usr/bin/perl

use POSIX;
use strict;
use Text::CSV;
use List::Util qw(min max sum);
use List::MoreUtils qw(uniq firstidx);
use Bio::AlignIO;
use Bio::SeqIO;
use Cwd;
use Cwd 'abs_path';
use Getopt::Long;
use experimental 'smartmatch';
use Bio::Tools::Run::Alignment::Muscle;
use Bio::Align::Utilities;


################################################################################
######### Setup
$|=1;

my @fourLetterCodons = ("CT","GT","GC","AC","TC","CC","CG","GG");

my $conservatoryDir=abs_path(".");
my $referenceGenomeList;

my $referenceGenomeFamily;
my %referenceGenomeSpecies;
my $treeFileName;
my $maxOrthogroups =1000;
my $numOfGenesUsed=0;
my $help=0;

my $keepTmp=0;



GetOptions ("conservatory-directory=s" => \$conservatoryDir,
			"reference=s" => \$referenceGenomeList,
			"tree=s" => \$treeFileName,
			"keep-tmp" => \$keepTmp,
			"help" => \$help) or die ("Error in command line arguments\n");

if($help || $referenceGenomeList eq "" || $treeFileName eq "") {
   print "\n\tbuildModel --reference <ReferenceGenome>,<referenceGenome> \n\t\tbuildModel accepts a list of comma-separated reference genomes from the same family (for which alignments have been done) and a tree file for the family\n\t\tand produces a model file for phyloP based on non-coding sequence data.\n\n";
   print "\t--conservatory-directory\tName of the conservatory directory. Default is current directory.\n";
   print "\t--reference\tComma delimited list of reference genomes (At least one is REQUIRED).\n";
   print "\t--tree\t\tFamily tree file for phyloFit (REQUIRED).\n";
   print "\t--keep-tmp\t\tDo not delete the temporary fasta file of the 3rd condon positions.\n";
   print "\t--help\t\tPrints this message.\n\n";
   
   exit();
}

my $genomedbFileName = $conservatoryDir . "/genome_database.csv";

die "ERROR: Cannot find file genome database file ($genomedbFileName)\n" unless -e $genomedbFileName;
die "ERROR: Cannot find file tree filename ($treeFileName)\n" unless -e $treeFileName;
die "ERROR: Conservatory directory structure at ($conservatoryDir) is corrupt\n" unless (-e "$conservatoryDir/scripts");

########## read genome database to get species list
my @referenceGenomes = split ',', $referenceGenomeList;

my %genomesInFamily;
my %speciesInFamily;
my %genomeToSpecies;
my %proteinNameTranslator;
my %geneNameTranslator;
my %FourVarPosSequence;
my %alignmentDirs;


open (my $genomeDatabase, "<", $genomedbFileName);
while((my $curgenomeline = <$genomeDatabase>)) {
	if(substr($curgenomeline,0,1) ne "#") { 
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$genomesInFamily{$curgenomeFamily}{$curgenomeName}=1;
		$speciesInFamily{$curgenomeFamily}{$curgenomeSpecies}=1;
	
		if(defined $genomeToSpecies{$curgenomeName}) { die "ERROR: Genome name must be unique ($curgenomeName).\n"; }
	
		$genomeToSpecies{$curgenomeName}= $curgenomeSpecies;
		$proteinNameTranslator{$curgenomeName}= $proteinProcessingRegEx;
		$geneNameTranslator{$curgenomeName}= $geneProcessingRegEx;

		if($curgenomeName ~~ @referenceGenomes) {
			if($referenceGenomeFamily eq "") { 
				$referenceGenomeFamily = $curgenomeFamily;
			}
			if($referenceGenomeFamily ne $curgenomeFamily) {
				die "ERROR: Reference genomes $referenceGenomeList are from different families ($referenceGenomeFamily,$curgenomeFamily). They must be from the same family.\n";
			}
			$referenceGenomeSpecies{$curgenomeName} = $curgenomeSpecies;
			$alignmentDirs{$curgenomeName} = "$conservatoryDir/alignments/$curgenomeName";
			die "ERROR: Conservatory directory structure at ($conservatoryDir) is corrupt. Cannot find alignment directory " . $alignmentDirs{$curgenomeName} . "\n" unless (-e $alignmentDirs{$curgenomeName});
		}
	}
}
close($genomeDatabase);

my $tmpFastaFileName = "$conservatoryDir/genomes/$referenceGenomeFamily.formodel.fasta";

die "ERROR: Cannot find family for the reference genomes ($referenceGenomeList) in the genome database file.\n" unless ($referenceGenomeFamily ne "");

if(scalar @referenceGenomes != scalar keys %referenceGenomeSpecies) {
	die "ERROR: Found only " . join(",", keys %referenceGenomeSpecies) . " reference genomes out of the list $referenceGenomeList.\n";
}
print "INFO: START automatic phylogenetic model computation for family: $referenceGenomeFamily using reference genomes:" . join(",", keys %referenceGenomeSpecies) . "\n";

#### Now read the CDS and proteins files

my @speciesInReferenceFamily = keys %{ $speciesInFamily{$referenceGenomeFamily} };
my $numOfSpeciesInFamily = (scalar @speciesInReferenceFamily);
my @genomesInReferenceFamily = keys %{ $genomesInFamily{$referenceGenomeFamily} };

my $genomesDir = "$conservatoryDir/genomes/$referenceGenomeFamily";

print "START: Reading proteins and CDS sequences for $referenceGenomeFamily.\n";
print "INFO: Family contains " . scalar @speciesInReferenceFamily . " species:" . join(",", sort @speciesInReferenceFamily) . "\n";
my %proteinSeqDB;
my %cdsSeqDB;

foreach my $curGenome (@genomesInReferenceFamily) {
	print "PROGRESS: Reading $curGenome...";
	my $proteinTranslatorForGenome = $proteinNameTranslator{$curGenome};
	my $geneNameTranslatorForGenome = $geneNameTranslator{$curGenome};
	
	my $proteinSeqReader = Bio::SeqIO->new( -format => "fasta",
										   -file => "$genomesDir/$curGenome.proteins.fasta");
	my $totalProteins=0;
	my $totalCDS=0;
	while ( my $seq = $proteinSeqReader->next_seq() ) {
		### Convert seq name from protein to fullgenename
		my $locus = $seq->id();
		if($proteinTranslatorForGenome ne "") { eval '$locus =~ s/$proteinTranslatorForGenome//g;'; }
		$locus =~ s/ .*$//;
		my $fullGeneName = $genomeToSpecies{$curGenome} . "-$curGenome-$locus";
		if(length($seq->seq()) > length($proteinSeqDB{$fullGeneName}) ) {  ##If more than one sequence (spliceform?) take longest one
			$proteinSeqDB{$fullGeneName} = $seq->seq();
		}
		$totalProteins++;
	}
	print "$totalProteins protein sequences found...";

	my $cdsSeqReader = Bio::SeqIO->new( -format => "fasta",
						-file => "$genomesDir/$curGenome.cds.fasta");
	while ( my $seq = $cdsSeqReader->next_seq() ) {
		my $locus = $seq->id();
		if($geneNameTranslatorForGenome ne "") { eval '$locus =~ s/$geneNameTranslatorForGenome//g;'; }
		$locus =~ s/ .*$//;
		my $fullGeneName = $genomeToSpecies{$curGenome} . "-$curGenome-$locus";
		
		if(defined $proteinSeqDB{$fullGeneName}) {  ## Only add the CDS if we have the protein, and only the longest one (unless we find a perfect match).
			if(length($seq->seq()) > length($cdsSeqDB{$fullGeneName}) && length($cdsSeqDB{$fullGeneName}) != length($proteinSeqDB{$fullGeneName})*3) {
				$cdsSeqDB{$fullGeneName} = $seq->seq();
				$totalCDS++;
			}
		} else {
			#print "ERROR: Found cds $fullGeneName with no protein for genome $curGenome.\n";
		}
			
	}
	print "$totalCDS CDS sequences found.\n";
}

#### Now look for all single orthologs
print "PROGRESS: Searching for one-to-one orthologs...\n";

my %oneToOneOrthologs;

foreach my $curReferenceGenome (keys %referenceGenomeSpecies) {
	opendir my $alignmentDirReader, $alignmentDirs{$curReferenceGenome}; 
	my @CREorthologFiles = grep (/\.CREorthologs.txt/, readdir($alignmentDirReader) );

	print "PROGRESS: Reference genome $curReferenceGenome. " . scalar @CREorthologFiles . " candidates.";

	foreach my $curCREOrth (@CREorthologFiles) {
		my %speciesInOrth;
		my %orthForSpecies;
		my %orthScoreForSpecies;

		open( my $curCREOrthFile, $alignmentDirs{$curReferenceGenome} . "/$curCREOrth") || die ("INTERNAL ERROR.\n");

		my $referenceGene = $curCREOrth;
		$referenceGene =~ s/.*\///;   # remove trailing directory structure
		$referenceGene =~ s/\..*$//;  # remove the suffix
		my $fullReferenceGeneName = $referenceGenomeSpecies{$curReferenceGenome} . "-" . $curReferenceGenome . "-" . $referenceGene;
		$oneToOneOrthologs{$curReferenceGenome}{$curCREOrth}{$referenceGenomeSpecies{$curReferenceGenome} } = $fullReferenceGeneName;
		$speciesInOrth{ $referenceGenomeSpecies{$curReferenceGenome} }=1;

		while(my $curLine = <$curCREOrthFile>) {
			my ($genome, $geneName, $upscore, $downscore) = split /\t/, $curLine;
#			my $orthScore = $upscore + $downscore;
			my $orthScore = $upscore;
			my $species = $geneName;
			$species =~ s/-.*$//;
			if($species ne $referenceGenomeSpecies{$curReferenceGenome} ) {
				$speciesInOrth{$species}++;
				if($orthScore > $orthScoreForSpecies{$species}) {
					$orthScoreForSpecies{$species} = $orthScore;
					$oneToOneOrthologs{$curReferenceGenome}{$curCREOrth}{$species} = $geneName;
				}
			}
		}
		close( $curCREOrthFile);
#		print "Found $curCREOrthFile: " . scalar (keys %speciesInOrth) . " species: " . join(",", sort keys %speciesInOrth) . "\n";
		## Only keep the genes that have orthologs in all species of the family
		if( ( (scalar (keys %speciesInOrth)) != $numOfSpeciesInFamily)) {

			delete $oneToOneOrthologs{$curReferenceGenome}{$curCREOrth};
		}
	}
	print "..." . (scalar (keys %{ $oneToOneOrthologs{$curReferenceGenome} } ) ) . " possible orthogroups.\n";
}

## Now combine the reference genome orthologs
my @orthogroupsToKeep;

if(scalar @referenceGenomes > 1) {
	print "PROGRESS: Combining orthogroup lists for " . join(",", @referenceGenomes) . "\n";
	foreach my $curOrthogroupToCheck (keys %{ $oneToOneOrthologs{ $referenceGenomes[0] }  }) {
		foreach my $curReferenceGenome ( @referenceGenomes) {
			if($curReferenceGenome ne $referenceGenomes[0]) {
				## Find the matching orthogroup
				my @matchingOrthogroupsPerGenome;
				foreach my $curParallelOrthogroupToCheck (keys %{ $oneToOneOrthologs{ $curReferenceGenome} } ) {
#					print "DEBUG: Checking $curOrthogroupToCheck ($referenceGenomes[0]):";
#					print  " In $curReferenceGenome:" .  $oneToOneOrthologs{$curReferenceGenome}{$curParallelOrthogroupToCheck}{ $referenceGenomeSpecies{ $referenceGenomes[0] } } . ". In $referenceGenomes[0] : " . $oneToOneOrthologs{$referenceGenomes[0]}{$curOrthogroupToCheck}{ $referenceGenomeSpecies{ $referenceGenomes[0] } } . "\n";
					if($oneToOneOrthologs{$curReferenceGenome}{$curParallelOrthogroupToCheck}{ $referenceGenomeSpecies{ $referenceGenomes[0] } } eq
					   $oneToOneOrthologs{$referenceGenomes[0]}{$curOrthogroupToCheck}{ $referenceGenomeSpecies{ $referenceGenomes[0] } } ) {
						print "Matching orthogroups: $curOrthogroupToCheck and $curParallelOrthogroupToCheck.";
						## Check to see if all orthologs match
						my (@orthogroupOne, @orthogroupTwo);
						foreach my $curSp ( keys %{ $oneToOneOrthologs{$referenceGenomes[0]}{$curOrthogroupToCheck} } ) {
							push @orthogroupOne, $oneToOneOrthologs{$referenceGenomes[0]}{$curOrthogroupToCheck}{$curSp};
						}
						foreach my $curSp ( keys %{ $oneToOneOrthologs{$curReferenceGenome}{$curParallelOrthogroupToCheck} } ) {
							push @orthogroupTwo, $oneToOneOrthologs{$referenceGenomes[0]}{$curOrthogroupToCheck}{$curSp};
						}
						@orthogroupOne = sort @orthogroupOne;
						@orthogroupTwo = sort @orthogroupTwo;
						if( @orthogroupOne == @orthogroupTwo) {
							my $match = 1;
							foreach  my $curSpNum (0..(@orthogroupOne)) {
								if($orthogroupOne[$curSpNum] ne $orthogroupTwo[$curSpNum]) {
									$match = 0;
#									print "DEBUG: Mismatch due to $orthogroupOne[$curSpNum] != $orthogroupTwo[$curSpNum].\n";
								}
							}
							if($match) {
								print "..orthogroups accepted.\n";
								push @orthogroupsToKeep, $curOrthogroupToCheck;
							} else {
								print "..orthogroup rejected due to mismatch in ortholog identity.\n";
							}
						} else {
							print "..orthogroup rejected due to mismatch in ortholog numbber.\n";
						}
					}
				} 
			}
		}
	}
} else {
	@orthogroupsToKeep = keys %{ $oneToOneOrthologs{$referenceGenomes[0]}};
}

if(scalar @orthogroupsToKeep > $maxOrthogroups) {
	@orthogroupsToKeep = @orthogroupsToKeep[0..$maxOrthogroups];
}

my @orthologProteins;
my %orthologCDSs;
foreach my $curCREOrtholog (@orthogroupsToKeep) {
	my $skipGene=0;
	
	@orthologProteins =  ();
	%orthologCDSs = {};

	### Build OrthologSeq DB
	for my $curSpecies (keys %{ $oneToOneOrthologs{$referenceGenomes[0]}{$curCREOrtholog} }) {
		my $proteinSeq = $proteinSeqDB{ $oneToOneOrthologs{$referenceGenomes[0]}{$curCREOrtholog}{$curSpecies} };
		my $cdsSeq = uc($cdsSeqDB{$oneToOneOrthologs{$referenceGenomes[0]}{$curCREOrtholog}{$curSpecies}});

		### remove protein illegal embelishment
		$proteinSeq =~ s/\.$//;
		$proteinSeq =~ s/\*$//;
		## remove the stop from the CDS, if found
		## Trim the CDS to triplets
		$cdsSeq = substr($cdsSeq,0, length($cdsSeq) - (length($cdsSeq) % 3));
		$cdsSeq =~ s/(TGA|TAA|TAG)$//;

		push (@orthologProteins, Bio::LocatableSeq->new(-seq => $proteinSeq,
        	                	                -id => $curSpecies,
                                                -start => 1,
                                                -end => length($proteinSeq)));
        
        $orthologCDSs{ $curSpecies } = Bio::LocatableSeq->new(-seq => $cdsSeq,
      	                	            -id => $curSpecies,
        	                            -start => 1,
                	                    -end => length($cdsSeq) );

		if(length($cdsSeq) != length($proteinSeq)*3) {
			print "WARNING: BAD CDS data for " . $oneToOneOrthologs{$referenceGenomes[0]}{$curCREOrtholog}{$referenceGenomeSpecies{$referenceGenomes[0]} } . ":" . $oneToOneOrthologs{$referenceGenomes[0]}{$curCREOrtholog}{$curSpecies} . ". (" . length($proteinSeq)*3 . ":" . length($cdsSeq). "). Skipping gene. \n";
			$skipGene = 1;
		}
	}

	if(!$skipGene) {
       	print "PROGRESS: $curCREOrtholog: " . $oneToOneOrthologs{$referenceGenomes[0]}{$curCREOrtholog}{$referenceGenomeSpecies{$referenceGenomes[0]} } . ". ";
       	my $aligner = Bio::Tools::Run::Alignment::Muscle->new(('quiet' => 1));
       	my $proteinAlignment = $aligner->align(\@orthologProteins);
		print "Alignment: Protein (" . $proteinAlignment->num_sequences . "," . $proteinAlignment->length . "," . $proteinAlignment->is_flush . ")";
   		my $cdsAlignment = Bio::Align::Utilities::aa_to_dna_aln($proteinAlignment, \%orthologCDSs);	
		print ";DNA (" . $cdsAlignment->num_sequences . "," . $cdsAlignment->length . "," . $cdsAlignment->is_flush . "). ";

		if($cdsAlignment->length() >0) {
	    	my %fourPositionNucleotide;
      		my @conservation = $cdsAlignment->consensus_conservation();
      		my $consensus_sequence = $cdsAlignment->consensus_string(); 
      		my $curPos=0;
       		my @columnsToRemove;
      		while($curPos < $cdsAlignment->length() ) {
      			if($conservation[$curPos] == 100 && $conservation[$curPos+1] ==100  && substr($consensus_sequence,$curPos, 2) ~~ @fourLetterCodons) {
   					### If perfect conservation for position 1 and 2 of the codon;
   					push @columnsToRemove, [($curPos), ($curPos +1) ];
   				} else {
       				push @columnsToRemove, [($curPos),($curPos + 2) ]
   				}
   				$curPos+=3;
   			}
   			my $just4posVar = $cdsAlignment->remove_columns(@columnsToRemove);	
   			print "Got " . $just4posVar->length() . " 3rd position bases.\n";
   			if($just4posVar->length() >0 && $just4posVar->num_sequences == $numOfSpeciesInFamily) {
    			foreach my $seq ($just4posVar->each_seq) {
   					$FourVarPosSequence{ $seq->id() } .= $seq->seq();
   				}
   			} 
 		}
	}
}


####### Now dump fasta
open my $tmpFasta, ">$tmpFastaFileName";
foreach my $fastaSeq ( keys %FourVarPosSequence ) {
   	print $tmpFasta ">$fastaSeq\n" . $FourVarPosSequence{$fastaSeq} . "\n";
}
close $tmpFasta;
print "INFO: Done prepping FASTA file.\n";

####### make Model
print "INFO: START computing model.\n";
system("phyloFit --tree $treeFileName --subst-mod HKY85+GAP --nrates=4 --EM --precision MED --out-root $referenceGenomeFamily $tmpFastaFileName");
#system("phyloFit --tree $treeFileName --nrates 4 --subst-mod HKY85+GAP --out-root $referenceGenome $tmpFastaFileName");
#system("phyloFit --tree $treeFileName --nrates 4 --out-root $referenceGenome $tmpFastaFileName");
print "INFO: END computing model.\n";
if(!$keepTmp) { unlink($tmpFastaFileName); }

system("mv -f $referenceGenomeFamily.mod $conservatoryDir/genomes/$referenceGenomeFamily.mod");
print "INFO: DONE.\n";
