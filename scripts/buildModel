#!/usr/bin/perl

use POSIX;
use strict;
use Text::CSV;
use List::Util qw(min max sum);
use List::MoreUtils qw(uniq firstidx);
use Bio::AlignIO;
use Bio::SeqIO;
use Cwd;
use Cwd 'abs_path';
use Getopt::Long;
use experimental 'smartmatch';
use Bio::Tools::Run::Alignment::Muscle;
use Bio::Align::Utilities;


################################################################################
######### Setup
$|=1;

my @fourLetterCodons = ("CT","GT","GC","AC","TC","CC","CG","GG");

my $conservatoryDir=abs_path(".");
my $referenceGenome="";
my $referenceGenomeFamily;
my $referenceGenomeSpecies;
my $treeFileName;
my $maxSeq =1000;
my $numOfGenesUsed=0;
my $help=0;
my $force=1;



GetOptions ("conservatory-directory=s" => \$conservatoryDir,
			"reference=s" => \$referenceGenome,
			"tree=s" => \$treeFileName,
			"help" => \$help) or die ("Error in command line arguments\n");

if($help || $referenceGenome eq "" || $treeFileName eq "") {
   print "\n\tbuildModel --reference <ReferenceGenome> \n\t\tbuildModel accepts a family (for which alignments have already been done) and a tree file\n\t\tand produces a model file for phyloP based on non-coding sequence data.\n\n";
   print "\t--conservatory-directory\tName of the conservatory directory. Default is current directory.\n";
   print "\t--reference\tName of the reference genome (REQUIRED).\n";
   print "\t--tree\t\tTree file for phyloFit (REQUIRED).\n";
   
   print "\t--help\t\tPrints this message.\n\n";
   
   exit();
}

my $genomedbFileName = $conservatoryDir . "/genome_database.csv";
my $alignmentDir ="$conservatoryDir/alignments/$referenceGenome";
my $tmpFastaFileName = "$alignmentDir/tmp/$referenceGenome.formodel.fasta";


die "ERROR: Cannot find file genome database file ($genomedbFileName)\n" unless -e $genomedbFileName;
die "ERROR: Cannot find file tree filename ($treeFileName)\n" unless -e $treeFileName;
die "ERROR: Conservatory directory structure at ($conservatoryDir) is corrupt\n" unless (-e $alignmentDir && -e "$conservatoryDir/scripts");

########## read genome database to get species list
my %genomesInFamily;
my %speciesInFamily;
my %genomeToSpecies;
my %proteinNameTranslator;
my %geneNameTranslator;
my %FourVarPosSequence;

open (my $genomeDatabase, "<", $genomedbFileName);
while((my $curgenomeline = <$genomeDatabase>)) {
	if(substr($curgenomeline,0,1) ne "#") { 
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$genomesInFamily{$curgenomeFamily}{$curgenomeName}=1;
		$speciesInFamily{$curgenomeFamily}{$curgenomeSpecies}=1;
	
		if(defined $genomeToSpecies{$curgenomeName}) { die "ERROR: Genome name must be unique ($curgenomeName).\n"; }
	
		$genomeToSpecies{$curgenomeName}= $curgenomeSpecies;
		$proteinNameTranslator{$curgenomeName}= $proteinProcessingRegEx;
		$geneNameTranslator{$curgenomeName}= $geneProcessingRegEx;

		if($curgenomeName eq $referenceGenome) {
			$referenceGenomeFamily = $curgenomeFamily;
			$referenceGenomeSpecies = $curgenomeSpecies;
		}
	}
}
close($genomeDatabase);
die "ERROR: Cannot find family for the reference genome ($referenceGenome) in the genome database file.\n" unless ($referenceGenomeFamily ne "");

print "INFO: START automatic phylogenetic model computation for $referenceGenome. Family: $referenceGenomeFamily.\n";
#### Now read the CDS and proteins files

if(!(-e $tmpFastaFileName) || $force) {
	my @speciesInReferenceFamily = keys %{ $speciesInFamily{$referenceGenomeFamily} };
	my $numOfSpeciesInFamily = (scalar @speciesInReferenceFamily);
	my @genomesInReferenceFamily = keys %{ $genomesInFamily{$referenceGenomeFamily} };

	my $genomesDir = "$conservatoryDir/genomes/$referenceGenomeFamily";

	print "START: Reading proteins and CDS sequences.\n";
	my %proteinSeqDB;
	my %cdsSeqDB;


	foreach my $curGenome (@genomesInReferenceFamily) {
		print "PROGRESS: Reading $curGenome...";
		my $proteinTranslatorForGenome = $proteinNameTranslator{$curGenome};
		my $geneNameTranslatorForGenome = $geneNameTranslator{$curGenome};
	
		my $proteinSeqReader = Bio::SeqIO->new( -format => "fasta",
										   -file => "$genomesDir/$curGenome.proteins.fasta");
		my $totalProteins=0;
		my $totalCDS=0;
		while ( my $seq = $proteinSeqReader->next_seq() ) {
			### Convert seq name from protein to fullgenename
			my $locus = $seq->id();
			if($proteinTranslatorForGenome ne "") { eval '$locus =~ s/$proteinTranslatorForGenome//g;'; }
			$locus =~ s/ .*$//;
			my $fullGeneName = $genomeToSpecies{$curGenome} . "-$curGenome-$locus";
			$proteinSeqDB{$fullGeneName} = $seq->seq();
			$totalProteins++;
		}
		print "$totalProteins protein sequences found...";

		my $cdsSeqReader = Bio::SeqIO->new( -format => "fasta",
							-file => "$genomesDir/$curGenome.cds.fasta");
		while ( my $seq = $cdsSeqReader->next_seq() ) {
			my $locus = $seq->id();
			if($geneNameTranslatorForGenome ne "") { eval '$locus =~ s/$geneNameTranslatorForGenome//g;'; }
			$locus =~ s/ .*$//;
			my $fullGeneName = $genomeToSpecies{$curGenome} . "-$curGenome-$locus";
		
			if(defined $proteinSeqDB{$fullGeneName} && !defined $cdsSeqDB{$fullGeneName} ) {  ## Only add the CDS if we have the protein, and only one of it.
				$cdsSeqDB{$fullGeneName} = $seq->seq();
				$totalCDS++;
   			
			} else {
				#print "ERROR: Found cds $fullGeneName with no protein for genome $curGenome.\n";
			}
			
		}
		print "$totalCDS CDS sequences found.\n";
	}

	#### Now look for all single orthologs
	print "PROGRESS: Searching for one-to-one orthologs...";

	my %oneToOneOrthologs;
	opendir my $alignmentDirReader, $alignmentDir; 
	my @CREorthologFiles = grep (/\.CREorthologs.txt/, readdir($alignmentDirReader) );

	print " found " . scalar @CREorthologFiles . " candidates...";

	foreach my $curCREOrth (@CREorthologFiles) {
		my %speciesInOrth;
		my %orthForSpecies;
		my %orthScoreForSpecies;
	
		open( my $curCREOrthFile, "$alignmentDir/$curCREOrth") || die ("INTERNAL ERROR.\n");

		my $referenceGene = $curCREOrth;
		$referenceGene =~ s/.*\///;   # remove trailing directory structure
		$referenceGene =~ s/\..*$//;  # remove the suffix
		my $fullReferenceGeneName = $referenceGenomeSpecies . "-" . $referenceGenome . "-" . $referenceGene;
		$oneToOneOrthologs{$curCREOrth}{$referenceGenomeSpecies} = $fullReferenceGeneName;

		while(my $curLine = <$curCREOrthFile>) {
			my ($genome, $geneName, $upscore, $downscore) = split /\t/, $curLine;
#			my $orthScore = $upscore + $downscore;
			my $orthScore = $upscore;
			my $species = $geneName;
			$species =~ s/-.*$//;
			if($species ne $referenceGenomeSpecies) {
				$speciesInOrth{$species}++;
				if($orthScore > $orthScoreForSpecies{$species}) {
					$orthScoreForSpecies{$species} = $orthScore;
					$oneToOneOrthologs{$curCREOrth}{$species} = $geneName;
				}
			}
		}
		close( $curCREOrthFile);

		## Only keep the genes that have orthologs in all species of the family
		if( ((keys %speciesInOrth) +1 != $numOfSpeciesInFamily)) {
			delete $oneToOneOrthologs{$curCREOrth};
		}
	}

	print " Found " . (scalar (keys %oneToOneOrthologs)) . "\n";
	
	my @orthologProteins;
	my %orthologCDSs;
	foreach my $curCREOrtholog (keys %oneToOneOrthologs) {
		
		@orthologProteins =  ();
		%orthologCDSs = {};

		### Build OrthologSeq DB
		for my $curSpecies (keys %{ $oneToOneOrthologs{$curCREOrtholog} }) {
			my $proteinSeq = $proteinSeqDB{ $oneToOneOrthologs{$curCREOrtholog}{$curSpecies} };
			### remove protein illegal embelishment
			$proteinSeq =~ s/\.//g;
			$proteinSeq =~ s/\*//g;				

			push (@orthologProteins, Bio::LocatableSeq->new(-seq => $proteinSeq,
        	                	                -id => $curSpecies,
                                                -start => 1,
                                                -end => length($proteinSeq)));
        
	        $orthologCDSs{ $curSpecies } = Bio::LocatableSeq->new(-seq => $cdsSeqDB{$oneToOneOrthologs{$curCREOrtholog}{$curSpecies}},
      	                	            -id => $curSpecies,
        	                            -start => 1,
                	                    -end => length($cdsSeqDB{$oneToOneOrthologs{$curCREOrtholog}{$curSpecies}}));
#			print "PROGRESS: Ortholog for $curSpecies is " . $oneToOneOrthologs{$curCREOrtholog}{$curSpecies} . "\n";
		}

        print "PROGRESS: $curCREOrtholog: " . $oneToOneOrthologs{$curCREOrtholog}{$referenceGenomeSpecies} . "...\n";
        my $aligner = Bio::Tools::Run::Alignment::Muscle->new(('quiet' => 1));
        my $proteinAlignment = $aligner->align(\@orthologProteins);
		print "Protein alignment for $curCREOrtholog:(" . $proteinAlignment->num_sequences . "," . $proteinAlignment->length . "," . $proteinAlignment->is_flush . ")\n";
#		foreach my $curAln ($proteinAlignment->each_seq) {
#			print ">" . $curAln->id . "\n" . $curAln->seq . "\n";
#		}
       	my $cdsAlignment = Bio::Align::Utilities::aa_to_dna_aln($proteinAlignment, \%orthologCDSs);	
		print "DNA alignment for $curCREOrtholog:(" . $cdsAlignment->num_sequences . "," . $cdsAlignment->length . "," . $cdsAlignment->is_flush . ")\n";
#		foreach my $curAln ($cdsAlignment->each_seq) {
#			print ">" . $curAln->id . "\n" . $curAln->seq . "\n";
#		}
#        	$cdsAlignment = $cdsAlignment->remove_gaps();
       	if($cdsAlignment->length() >0) {
       		my %fourPositionNucleotide;
       		my @conservation = $cdsAlignment->consensus_conservation();
       		my $consensus_sequence = $cdsAlignment->consensus_string(); 
       		my $curPos=0;
       		my @columnsToRemove;
       		while($curPos < $cdsAlignment->length() ) {
#       			if($conservation[$curPos] == 100 && $conservation[$curPos+1] ==100 && $conservation[$curPos+2] < 100 && substr($consensus_sequence,$curPos, 2) ~~ @fourLetterCodons) {
      			if($conservation[$curPos] == 100 && $conservation[$curPos+1] ==100  && substr($consensus_sequence,$curPos, 2) ~~ @fourLetterCodons) {
       				### If perfect conservation for position 1 and 2 of the codon;
       				push @columnsToRemove, [($curPos), ($curPos)+1];
#       				print "Found good codon at pos $curPos:" . substr($consensus_sequence,$curPos, 3) . ": Identity at #3: " . $conservation[$curPos+2] . ".\n";
       			} else {
       				push @columnsToRemove, [($curPos),($curPos + 2) ]
       			}
       			$curPos+=3;
       		}
       		my $just4posVar = $cdsAlignment->remove_columns(@columnsToRemove);	
       		print "Identified " . $just4posVar->length() . " 4 var positions\n";
       		if($just4posVar->length() >0) {
       			foreach my $seq ($just4posVar->each_seq) {
       				$FourVarPosSequence{ $seq->id() } .= $seq->seq();
       			}
       		}      		
    	}
   }
}

####### Now dump fasta
open my $tmpFasta, ">$tmpFastaFileName";
foreach my $fastaSeq ( keys %FourVarPosSequence ) {
   	print $tmpFasta ">$fastaSeq\n" . $FourVarPosSequence{$fastaSeq} . "\n";
}
close $tmpFasta;
print "INFO: Done prepping FASTA file.\n";


####### make Model
print "INFO: START computing model.\n";
system("phyloFit --tree $treeFileName --subst-mod HKY85+GAP --nrates=4 --EM --precision MED --out-root $referenceGenome $tmpFastaFileName");
#system("phyloFit --tree $treeFileName --nrates 4 --subst-mod HKY85+GAP --out-root $referenceGenome $tmpFastaFileName");
#system("phyloFit --tree $treeFileName --nrates 4 --out-root $referenceGenome $tmpFastaFileName");
print "INFO: END computing model.\n";
#unlink($tmpFastaFileName);
#system("mv -f $referenceGenome.mod $conservatoryDir/genomes/$referenceGenome.mod");
print "INFO: DONE.\n";
