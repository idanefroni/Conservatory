#!/usr/bin/perl

use POSIX;
use strict;
use Array::Utils qw(:all);
use Cwd 'abs_path';
use List::Util qw(min max);
use Bio::AlignIO;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;
use Getopt::Long;
$|=1;

my $conservatoryDir=abs_path(".");
my $CNSFileName="";
my $mapFileName="";
my $outputCNSFileName="";
my $outputMapFileName="";
my $outputMergedCNSFileName="";
my $superCNSPrefix = "Super";

my $verbose=0;
my $help=0;
my $minOverlappingSpeciesForMerge=4; ### How many overlapping hits to merge a CNS
my $minCNSOverlap = 0.25;
my $minSyntenyBiasToAssignCNS= 1.2; ### Number between 1 and 2 (how many more species need to support a contestant CNS to assign to just one of the genes)
my $removeOriginalCNS=0;
my $CLASSIFICATION_CLASSES_NUM=6;

my %CNSTable;
my %positionTable;
my %genomeToSpecies;
my %genomeToFamily;
my %speciesToFamily;
my %speciesClassification;

my $CNSMerged=0;
my $CNSMergedExtended=0;
my $CNSDeleted=0;
my $deepCNSMerged=0;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"in-cns=s" => \$CNSFileName,
			"in-map=s" => \$mapFileName,
			"out-cns=s" => \$outputCNSFileName,
			"out-map=s" => \$outputMapFileName,
			"out-merged=s" => \$outputMergedCNSFileName,
			"verbose" => \$verbose,
			"min-overlapping" => \$minOverlappingSpeciesForMerge,
			"remove-original-CNS" => \$removeOriginalCNS,
			"help" => \$help) or die ("Error in command line arguments\n");
			
			
if($help || $CNSFileName eq "" || $mapFileName eq "" || $outputCNSFileName eq "" || $outputMapFileName eq "" ) {
	print "Conservatory version 2.0.1\n\n";
	print "mergeCNSTables --in-cns <cnsFile> --in-map <cnsPositionMapFile> --out-cns <cnsFile> --out-map <cnsPositionMapFile>  [--out-merged <mergedDeepCNSfile>] [--min-overlapping <number>] [--remove-original-CNS].\n\n";
	
#	print "\t\tmerged.cns.table.csv\t\tMerged CNS file\n\t\tmerged.cns.position.table.csv\t\tMerged position file\n";
	exit();
}

if ($verbose) { print "START: Loading genome database.\n"; }
my $genomedbFile = $conservatoryDir . "/genome_database.csv";
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;

open (my $genomeDatabase, "<", $genomedbFile);
while((my $curgenomeline = <$genomeDatabase>)) {
	chomp($curgenomeline);
	if(substr($curgenomeline,0,1) ne "#")  {
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$genomeToSpecies{$curgenomeName}=  $curgenomeSpecies;
		$genomeToFamily{$curgenomeName} = $curgenomeFamily;
		$speciesToFamily{$curgenomeSpecies} = $curgenomeFamily;
		$speciesClassification{$curgenomeSpecies} = $classification;
	}
}

if ($verbose) { print "END: Loading genome database.\n"; }

if ($verbose) { print "START: Merging CNSs.\n"; }

if($verbose) { print "PROGRESS: Loading mappings...\n" };

########## Load position table to memory
open (my $CNSPositionFile, $mapFileName) ||  die "ERROR: Cannot find position file $mapFileName.\n";
while(<$CNSPositionFile>) {
	chomp;
	my ($CNSID, $targetSpecies, $targetLocus, $targetRelativePosition, $referenceRelativePosition, $length, $targetSequence) = split /,/;
	## Only if non-filtered CNS
	if(!defined $positionTable{$CNSID}) {
		$positionTable{$CNSID} = {
					'CNSID' => $CNSID,
					'Positions' => () };
	}

	push( @{ $positionTable{$CNSID}{'Positions'} } , {
				'TargetSpecies' => $targetSpecies,
				'TargetLocus' => $targetLocus,
				'TargetPosition' => $targetRelativePosition,
				'ReferenceRelativePos' => $referenceRelativePosition,
				'Length' => $length,
				'TargetSequence' => $targetSequence} );			
}
close($CNSPositionFile);


### Now start merging CNSs. First read and merge all CNSs in the family
if($verbose) { print "PROGRESS: Begin merge family CNS.\n" };

open (my $CNSInputFile,"sort -t',' -k1,1 -k3,3 -k5,5n $CNSFileName |") ||  die "ERROR: Cannot find CNS file $CNSFileName.\n";

my $lastCNS ="";
my %CNSTable;
while(<$CNSInputFile>) {
	chomp;
	my ($referenceGenome, $CNSID, $chromosome, $strand, $start, $end, $locus, $relStart, $relEnd, $level, $supportingSpecies, $orfLength, $orfDir, $omega, $ancesteralSeq) = split /,/;
	my $regulatorySeqPart;
	if($relStart<0) {
		$regulatorySeqPart = "Upstream";
	} else {
		$regulatorySeqPart = "Downstream";
	}
	$CNSTable{$CNSID} = {
				'ReferenceGenome' => $referenceGenome,
				'CNSID' => $CNSID,
				'Chromosome' => $chromosome,
				'Strand' => $strand,
				'Start' => $start,	
				'End' => $end,
				'Locus' => $locus,
				'RelStart' => $relStart,
				'RelEnd' => $relEnd,
				'Level' => $level,
				'SupportingSpecies' => $supportingSpecies,
				'ORFLength' => $orfLength,
				'ORFDir' => $orfDir,
				'Omega' => $omega,
				'AncesteralSeq' => $ancesteralSeq,
				'RegulatorySeqPart' => $regulatorySeqPart
	};
	
	if($lastCNS eq "") {
		$lastCNS = $CNSID;
	} else {
		### If this CNS overlap with last, pick one gene to associate it with (or merge)
		###
		my $CNSToDelete= "";
		if($CNSTable{$lastCNS}{'ReferenceGenome'} eq $referenceGenome && 
			$CNSTable{$lastCNS}{'Chromosome'} eq $chromosome &&
			overlap($CNSTable{$lastCNS}{'Start'},$CNSTable{$lastCNS}{'End'}, $start, $end)) {

				if($verbose) { print "Found overlapping CNS: $lastCNS and $CNSID.\n"; }

				## Prefer the CNS with the most conserved synteny (largest number of supporting species for CNS-Gene synteny)
				if($CNSTable{$lastCNS}{'SupportingSpecies'} > $CNSTable{$CNSID}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $CNSID;
					$CNSDeleted++;
				} elsif($CNSTable{$CNSID}{'SupportingSpecies'} > $CNSTable{$lastCNS}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $lastCNS;
					$CNSDeleted++;
				} else {   ### If not CNSs have the same number of supporting species, we have to decide:
						### If the genes are same orientation and the CNS is in the same part of the regulatory sequence (Up/downstream)
						###  then associate with the closest gene.
						if( ($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Upstream") &&
							($CNSTable{$lastCNS}{'Strand'} eq $strand)) {    #### If both upstream. delete the one further away
							if($relEnd > $CNSTable{$lastCNS}{'RelEnd'}) {
								$CNSToDelete = $lastCNS;
							}
							else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Downstream") &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {  ### If both downstream, delete the one further away
							if($relStart < $CNSTable{$lastCNS}{'RelStart'}) {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} ne $regulatorySeqPart)  &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {   ### If one is upsteam, one downstream on opposite strands, delete the downstream (we assume upstream more likely)
							if($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Downstream") {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif( $CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Merged" ) {   #### If CNS hits a CNS that was already merged, just delete it
						if($verbose) { print "$CNSID overlaps with $lastCNS, but $lastCNS was already merged. Deleting...\n"}
						$CNSToDelete = $CNSID;
						$CNSDeleted++;
					} else { ### If orientation is different then merge into one CNS.
						if($verbose) { print "PROGRESS: Merging family CNS $lastCNS and $CNSID...(" . $CNSTable{$lastCNS}{'RegulatorySeqPart'} . ":" . $CNSTable{$CNSID}{'RegulatorySeqPart'} .")\n"; }
						my $diffInCNSPos = $start-$CNSTable{$lastCNS}{'Start'};

						### Pick the longest one
						my $longestSeq;
						if( ($CNSTable{$CNSID}{'End'} - $CNSTable{$CNSID}{'Start'}) > ($CNSTable{$lastCNS}{'End'} - $CNSTable{$lastCNS}{'Start'}) ) {
							$longestSeq = $CNSTable{$CNSID}{'AncesteralSeq'};
						} else {
							$longestSeq = $CNSTable{$lastCNS}{'AncesteralSeq'};
						}
						## Update all the positions
						my @CNSMappings = @{ $positionTable{$CNSID}{'Positions'} };

						foreach my $mapping (@CNSMappings) {
							my @lastCNSMappings = @{ $positionTable{$lastCNS}{'Positions'} };
							$mapping->{'PosInCNS'} = $mapping->{'PosInCNS'} + $diffInCNSPos;
							my %newmapping = %$mapping;
							push( @{ $positionTable{$lastCNS}{'Positions'} } , \%newmapping);
							if($verbose) { print "Updating $CNSID to $lastCNS: " . $newmapping{'TargetSpecies'} . "," . $newmapping{'TargetLocus'} . "\n"; }
						}

						### Merge CNS rel position
						$CNSTable{$lastCNS}{'RegulatorySeqPart'}="Merged";
						$CNSTable{$lastCNS}{'AncesteralSeq'} = $longestSeq;

						# and remove the old CNS
						$CNSToDelete = $CNSID;
						$CNSMerged++;
				}
			}
		} else {
			$lastCNS = $CNSID;
		}

		if($CNSToDelete ne "") {
			if($verbose) { print "PROGRESS: Deleting $CNSToDelete.\n"; }
			delete $positionTable{$CNSToDelete};
			delete $CNSTable{$CNSToDelete};
			if($CNSToDelete eq $lastCNS) { $lastCNS=$CNSID; }
		}
	}
}

close($CNSInputFile);


###### Now go to the deeper merge - merge across different references
if($verbose) { print "PROGRESS: Begin merging deep CNS.\n" };

### First, build a map of hits indexed by gene
my %positionLocusMap;

foreach my $curCNS (keys %positionTable) {
	foreach my $curHit (@{ $positionTable{$curCNS}{'Positions'} }) {
		if(!defined $positionLocusMap{ $curHit->{'TargetLocus'} }) {
			$positionLocusMap{ $curHit->{'TargetLocus'} } = {
					'Positions' => () };
		 }
		 push( @{ $positionLocusMap{ $curHit->{'TargetLocus'} }{'Positions'} } , {
				'TargetSpecies' => $curHit->{'TargetSpecies'},
				'TargetLocus' => $curHit->{'TargetLocus'},
				'CNSID' => $curCNS,
				'TargetPosition' => $curHit->{'TargetPosition'} ,
				'ReferenceRelativePos' => $curHit->{'ReferenceRelativePos'},
				'Length' => $curHit->{'Length'},
				'TargetSequence' => $curHit->{'TargetSequence'} } );			
		}	
}

if($verbose) { print "PROGRESS: Built CNS map.\n" };
### Now Identify CNS to merge
my %CNSToMerge;
my %CNSToMergeHitMap;

### Scan all the hits to the locus. See if an alignment is hitting Two CNSs. If so, merge them.

foreach my $curLocus (keys %positionLocusMap) {
	if($verbose) { print "PROGRESS: Testing deep CNS for $curLocus.\n"; }
	my $curPos=0;
	
	foreach my $firstHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
		foreach my $secondHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
			# && ($firstHit->{'TargetSpecies'} eq $secondHit->{'TargetSpecies'})
			if(($firstHit->{'CNSID'} ne $secondHit->{'CNSID'}) && ($CNSTable{ $firstHit->{'CNSID'} } {'ReferenceGenome'} ne $CNSTable{ $secondHit->{'CNSID'} }{'ReferenceGenome'}) && ($CNSTable{ $firstHit->{'CNSID'} } {'RegulatorySeqPart'} eq $CNSTable{ $secondHit->{'CNSID'} }{'RegulatorySeqPart'}) ) {
				if(overlap($firstHit->{'TargetPosition'}, $firstHit->{'TargetPosition'}+$firstHit->{'Length'}, $secondHit->{'TargetPosition'}, $secondHit->{'TargetPosition'}+$secondHit->{'Length'}) > $minCNSOverlap ) {
					### We should merge the CNS
					my $first;
					my $second;

					if(defined $CNSToMerge{ $firstHit->{'CNSID'} }) {
						$first = $firstHit->{'CNSID'};
						$second = $secondHit->{'CNSID'};
					} else {
						$first = $secondHit->{'CNSID'};
						$second = $firstHit->{'CNSID'};
					}

					if(!defined $CNSToMerge{ $first }{ $second }  ) { 
						$CNSToMerge{ $first } { $second }=1;
					} else {
						### make sure we keep the CNS association unidirectional and unique

						$CNSToMerge{ $first }{ $second }++;
				
						if($CNSToMerge{ $first }{ $second } == $minOverlappingSpeciesForMerge) {
							if($verbose) { print "PROGRESS: Merge deep CNS $first and $second because of $curLocus of (" . $firstHit->{'TargetSpecies'} . ").\n"; }
							$CNSMerged++;
							$deepCNSMerged++;
						}
					}
				}
			}
		}
	}
}

if($verbose) { print "PROGRESS: Found " . $deepCNSMerged . " CNS to merge.\n"; }
### Now merge merged CNS
if($verbose) { print "PROGRESS: Collating merged CNSs\n";}
my $CNSMergedInCurrentPass;
my $superGroupMerged=0;
my %CNSToCollate;

do {
	$CNSMergedInCurrentPass=0;
	%CNSToCollate=();
	foreach my $curCNS (keys %CNSToMerge) {
		my @curCNScontent = keys %{ $CNSToMerge{$curCNS} };
		push @curCNScontent, $curCNS;
		foreach my $CNSToScan (keys %CNSToMerge) {
			if($curCNS ne $CNSToScan) {
				my @CNSToScanContent = keys %{ $CNSToMerge{$CNSToScan} };
				push (@CNSToScanContent, $CNSToScan);
				my @CNSintersect = intersect(@curCNScontent, @CNSToScanContent);

				if ((scalar @CNSintersect) > 0 ) {  #### If we have a shared CNS between the two
					if(!defined $CNSToCollate{$CNSToScan}) {
						$CNSToCollate{$curCNS} = $CNSToScan;
					} 
					$CNSMergedInCurrentPass++;
				}
			}
		}
	}
	if($CNSMergedInCurrentPass>0) {  ### Do the merging
		foreach my $curCNSToCollate (keys %CNSToCollate) {
			foreach my $curCNSMemberToCopy (keys %{ $CNSToMerge{ $CNSToCollate{$curCNSToCollate} } }) {
				$CNSToMerge{$curCNSToCollate}{ $curCNSMemberToCopy } = $minOverlappingSpeciesForMerge;
			}
			$CNSToMerge{$curCNSToCollate}{ $CNSToCollate{$curCNSToCollate} } = $minOverlappingSpeciesForMerge;

			delete $CNSToMerge{ $CNSToCollate{$curCNSToCollate} };
		}
	}
} while($CNSMergedInCurrentPass >0);

if($verbose) { print "PROGRESS: Forming deep CNS groups.\n"; }

my %CNSGroups;

foreach my $curCNS (keys %CNSToMerge) {
	# filter low support alignments
	foreach my $cnsB (keys %{ $CNSToMerge{$curCNS } }) {
		if($CNSToMerge{$curCNS}{$cnsB}< $minOverlappingSpeciesForMerge) {
			delete $CNSToMerge{$curCNS}{$cnsB};
		}
	}

	my @otherCNSs = keys %{ $CNSToMerge{$curCNS} };

	if( @otherCNSs >0) {
		my $CNSGroupName = "$superCNSPrefix.$curCNS";

		$CNSTable{$CNSGroupName} = {
				'ReferenceGenome' => "SuperCNS",
				'CNSID' => $CNSGroupName,
				'Chromosome' => "",
				'Strand' => "",
				'Start' => "",	
				'End' => "",
				'Locus' => "",
				'RelStart' => "",
				'RelEnd' => "",
				'Level' => $CNSTable{$curCNS}{'Level'},
				'SupportingSpecies' => 0,
				'ORFLength' => "",
				'ORFDir' => "",
				'Omega' => "",
				'AncesteralSeq' => "",
				'RegulatorySeqPart' => ""};
		my @CNSsToJoin = ($curCNS, keys %{ $CNSToMerge{$curCNS} });
	
		$CNSGroups{$CNSGroupName} = \@CNSsToJoin;

		$positionTable{$CNSGroupName}{'Positions'} = ();

		my $remappedPositions=0;

		foreach my $curCNSToJoin ( @CNSsToJoin ) {
			foreach my $mapping ( @{ $positionTable{$curCNSToJoin}{'Positions'} }  ) {
			
				### Check to see if it is not there yet
				my $needToRemap=1;
				foreach my $curMapPos ( @{ $positionTable{$CNSGroupName}{'Positions'} }) {
					if($curMapPos->{'TargetLocus'} eq $mapping->{'TargetLocus'} &&
				   	   $curMapPos->{'TargetPosition'} eq $mapping->{'TargetPosition'}) {
						$needToRemap=0;
					}
				}

				if($needToRemap) {
					push ( @{ $positionTable{$CNSGroupName}{'Positions'} } , 	{
						'TargetSpecies' => $mapping->{'TargetSpecies'},
						'TargetLocus' => $mapping->{'TargetLocus'},
						'TargetPosition' => $mapping->{'TargetPosition'},
						'ReferenceRelativePos' => $mapping->{'ReferenceRelativePos'},
						'Length' => $mapping->{'Length'},
						'TargetSequence' => $mapping->{'TargetSequence'}
					});
					$remappedPositions++;
				}
			}
		}
		if($verbose) { print "PROGRESS: Created $CNSGroupName ($remappedPositions):" . join(",", @CNSsToJoin) . "\n"; }
	}
}

if($removeOriginalCNS) {
	foreach my $curCNS (keys %CNSToMerge) {
		foreach my $targetCNS (keys %{ $CNSToMerge{$curCNS} }) {
			if(!($targetCNS =~ /^$superCNSPrefix/)) { delete $CNSTable{$targetCNS}; }
		}
		if(!($curCNS =~ /^$superCNSPrefix/)) { delete $CNSTable{$curCNS}; }
	}
						
}

if($verbose) { print "PROGRESS: Remapping CNSs.\n";}

foreach my $curCNS (keys %CNSTable) {
	## Count supporting species
	my %speciesForCNS;
	foreach my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
		$speciesForCNS{ $mapping->{'TargetSpecies'} } =1;
	}
	$CNSTable{$curCNS}{'SupportingSpecies'} = scalar keys %speciesForCNS;

	my @CNSConservationLevels;

	foreach my $curSpecies (keys %speciesForCNS) {
  	  my @classification = split '-' , $speciesClassification{$curSpecies};
    	foreach my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {
			$CNSConservationLevels[$curClassificationLevel]{$classification[$curClassificationLevel]}=1;
    	}
   }
  my $maxConservationLevel= $CLASSIFICATION_CLASSES_NUM;
  foreach my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {
	if((scalar keys %{ $CNSConservationLevels[$curClassificationLevel] })>1 && $maxConservationLevel > $curClassificationLevel) {
		$maxConservationLevel=$curClassificationLevel;
	}
  }

  my @speciesForCNSArray = keys %speciesForCNS;
  my $conservationLevelName;
  if($maxConservationLevel == $CLASSIFICATION_CLASSES_NUM) {  ### If it's only in the family, mark the family
	 $conservationLevelName = $speciesToFamily{ $speciesForCNSArray[0] };
  } else {
	my @classificationLevels = split '-', $speciesClassification{ $speciesForCNSArray[0]};
	$conservationLevelName = $classificationLevels[ $maxConservationLevel-1];
  }

  $CNSTable{$curCNS}{'Level'} = $conservationLevelName;
}

if($verbose) { print "PROGRESS: Done. Output files.\n"; }

########### Output files
### New CNS files
open (my $outputCNSFile, ">$outputCNSFileName") || die ("INTERNAL ERROR.\n");
open (my $outputMapFile, ">$outputMapFileName") || die ("INTERNAL ERROR.\n");

foreach my $curCNS (sort keys %CNSTable) {
	print $outputCNSFile join(",",
				$CNSTable{$curCNS}{'ReferenceGenome'},
				$CNSTable{$curCNS}{'CNSID'},
				$CNSTable{$curCNS}{'Chromosome'},
				$CNSTable{$curCNS}{'Strand'},
				$CNSTable{$curCNS}{'Start'},	
				$CNSTable{$curCNS}{'End'},
				$CNSTable{$curCNS}{'Locus'},
				$CNSTable{$curCNS}{'RelStart'},
				$CNSTable{$curCNS}{'RelEnd'},
				$CNSTable{$curCNS}{'Level'},
				$CNSTable{$curCNS}{'SupportingSpecies'},
				$CNSTable{$curCNS}{'ORFLength'},
				$CNSTable{$curCNS}{'ORFDir'},
				$CNSTable{$curCNS}{'Omega'},
				$CNSTable{$curCNS}{'AncesteralSeq'}) ."\n";
	
	foreach my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
		print $outputMapFile join(",",
				$curCNS,
				$mapping->{'TargetSpecies'},
				$mapping->{'TargetLocus'},
				$mapping->{'TargetPosition'},
				$mapping->{'ReferenceRelativePos'},
				$mapping->{'Length'},
				$mapping->{'TargetSequence'}) ."\n";		
	}
}

close($outputCNSFile);

close($outputMapFile);

##########
if($outputMergedCNSFileName ne "") {
	open (my $outputMergedCNSFile, ">$outputMergedCNSFileName") || die ("INTERNAL ERROR.\n");
	foreach my $groupCNS (sort keys %CNSGroups) {
		foreach my $subCNS (@{ $CNSGroups{$groupCNS} } ) {
			print $outputMergedCNSFile "$groupCNS,$subCNS\n";
		}
	}
	close ($outputMergedCNSFile);
}

print "END: Deleted $CNSDeleted duplicated CNSs; Merged $CNSMerged CNSs, of $deepCNSMerged were deep CNSs. Assembled $superGroupMerged CNS groups.\n";



#############################################################################3
### Compute overlap between two fragments. 
### Parameters:
### overlap(startOne, endOne, StartTwo, endTwo, mode)
### mode can be "ABS", in which case returns the absolute overlap in bp
### else, returns relative overlap (0-1).
###

sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo, $mode) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		#### return the percent overlap
		if($endOne < $endTwo) {
			if($startOne >= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endOne -$startTwo);
				} else {
					return ($endOne -$startTwo) /($endOne - $startOne);
				}
			} 
		} else {
			if($startOne <= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);					
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endTwo -$startOne);
				} else {
					return ($endTwo -$startOne) /($endOne - $startOne);
				}
			} 			
		}
	}
}
