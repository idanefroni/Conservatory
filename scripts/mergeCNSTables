#!/usr/bin/perl
no warnings;

use POSIX;
use strict;
use Array::Utils qw(:all);
use Cwd 'abs_path';
use List::Util qw(min max uniq);
use Set::Scalar;
use Bio::Root::Root;
use Bio::SeqIO;
use Bio::AlignIO;
use Bio::TreeIO;
use Bio::Seq;
use Bio::LocatableSeq;
use Algorithm::NeedlemanWunsch;
use Bio::SimpleAlign;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;
use Getopt::Long;
$|=1;

### Filenames
my $conservatoryDir=abs_path(".");
my $tmpDir= "/dev/shm/";
my $CNSFileName="";
my $mapFileName="";
my $outputCNSFileName="";
my $outputMapFileName="";
my $outputMergedCNSFileName="";

my $conservatoryTreeFileName;

### Merging parameters
my $superCNSPrefix = "Super";
my $minOverlappingSpeciesForMerge=1; ### How many overlapping hits to merge a CNS
my $minCNSOverlap = 0.1;
my $minSyntenyBiasToAssignCNS= 1.1; ### Number between 1 and 2 (how many more species need to support a two-gene CNS assignment to just one of the genes, based on synteny)
my $minSupportingSpeciesToKeepMultipleCNS = 80;
my $removeOriginalCNS=0;

my $minCNSIdentityToMerge=70;

## Filtering parameters
my $CLASSIFICATION_CLASSES_NUM=6;
my $minSpeciesForClassification=6; 	### Minimum absolute number of species to support a classification

my %CNSTable;
my %positionTable;
my %genomeToSpecies;
my %genomeToFamily;
my %speciesToFamily;
my %speciesClassification;

my $CNSMerged=0;
my $CNSDeletedButMappingKept=0;
my $CNSDeleted=0;
my $deepCNSMerged=0;
my $skipConcensus=0;

my $verbose=0;
my $help=0;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"in-cns=s" => \$CNSFileName,
			"in-map=s" => \$mapFileName,
			"out-cns=s" => \$outputCNSFileName,
			"out-map=s" => \$outputMapFileName,
			"out-merged=s" => \$outputMergedCNSFileName,
			"verbose" => \$verbose,
			"min-overlapping" => \$minOverlappingSpeciesForMerge,
			"min-keep-multiple" => \$minSupportingSpeciesToKeepMultipleCNS,
			"remove-original-CNS" => \$removeOriginalCNS,
			"skip-concensus" => \$skipConcensus,
			"help" => \$help) or die ("Error in command line arguments\n");
			
			
if($help || $CNSFileName eq "" || $mapFileName eq "" || $outputCNSFileName eq "" || $outputMapFileName eq "" ) {
	print "Conservatory version 2.0.1\n\n";
	print "mergeCNSTables --in-cns <cnsFile> --in-map <cnsPositionMapFile> --out-cns <cnsFile> --out-map <cnsPositionMapFile>  [--out-merged <mergedDeepCNSfile>] [--min-overlapping <number>] [--min-keep-multiple number] [--remove-original-CNS] [--do-not-filter] [--skip-concensus].\n\n";
	
	exit();
}

if ($verbose) { print "START: Loading genome database.\n"; }
my $genomedbFile = $conservatoryDir . "/genome_database.csv";
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;

$conservatoryTreeFileName = $conservatoryDir . "/genomes/Conservatory.tree";
if(! -e $conservatoryTreeFileName) { print "WARNING: Cannot find conservatory tree ($conservatoryTreeFileName).\n"; $conservatoryTreeFileName=""; }

open (my $genomeDatabase, "<", $genomedbFile);
while((my $curgenomeline = <$genomeDatabase>)) {
	chomp($curgenomeline);
	if(substr($curgenomeline,0,1) ne "#")  {
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$genomeToSpecies{$curgenomeName}=  $curgenomeSpecies;
		$genomeToFamily{$curgenomeName} = $curgenomeFamily;
		$speciesToFamily{$curgenomeSpecies} = $curgenomeFamily;
		$speciesClassification{$curgenomeSpecies} = $classification;
	}
}

if ($verbose) { print "END: Loading genome database.\n"; }

my $positionLineCount = (qx(wc -l $mapFileName))[0];
chomp ($positionLineCount);
my $curPos=1;

########## Load position table to memory
open (my $CNSPositionFile, $mapFileName) ||  die "ERROR: Cannot find position file $mapFileName.\n";
while(<$CNSPositionFile>) {
	if($verbose) { print "PROGRESS: Loading mappings..." . $curPos++ . "/$positionLineCount\r" };
	chomp;
	my ($CNSID, $targetSpecies, $targetLocus, $targetRelativePosition, $referenceRelativePosition, $length, $targetSequence) = split /,/;
	
	### Filter for only embryophyta hits
	my @classification = split /-/, $speciesClassification{ $targetSpecies }; 

	## Only if non-filtered CNS
	if(!defined $positionTable{$CNSID}) {
		$positionTable{$CNSID} = {
					'CNSID' => $CNSID,
					'Positions' => () };
	}

	push( @{ $positionTable{$CNSID}{'Positions'} } , {
				'TargetSpecies' => $targetSpecies,
				'TargetLocus' => $targetLocus,
				'TargetPosition' => $targetRelativePosition,
				'ReferenceRelativePos' => $referenceRelativePosition,
				'Length' => $length,
				'TargetSequence' => $targetSequence} );		
}
close($CNSPositionFile);
if($verbose) { print "\n"; };

### Now start merging CNSs. First read and merge all CNSs in the family

open (my $CNSInputFile,"sort -t',' -k1,1 -k3,3 -k5,5n $CNSFileName |") ||  die "ERROR: Cannot find CNS file $CNSFileName.\n";
$curPos=1;
my $CNSLineCount= (qx(wc -l $CNSFileName))[0];
chomp($CNSLineCount);
my $lastCNS ="";
my %CNSTable;
while(<$CNSInputFile>) {
	if($verbose) { print "PROGRESS: Merging family CNS... " . $curPos++ . "/$CNSLineCount. Merged $CNSMerged.\r" };
	chomp;
	my ($referenceGenome, $CNSID, $chromosome, $strand, $start, $end, $locus, $relStart, $relEnd, $level, $supportingSpecies, $orfLength, $orfDir, $omega, $ancesteralSeq) = split /,/;

	if(!defined $positionTable{$CNSID} ) { next; }
	
	my $regulatorySeqPart;
	if($relStart<0) {
		$regulatorySeqPart = "Upstream";
	} else {
		$regulatorySeqPart = "Downstream";
	}
	$CNSTable{$CNSID} = {
				'ReferenceGenome' => $referenceGenome,
				'CNSID' => $CNSID,
				'Chromosome' => $chromosome,
				'Strand' => $strand,
				'Start' => $start,	
				'End' => $end,
				'Locus' => $locus,
				'RelStart' => $relStart,
				'RelEnd' => $relEnd,
				'Level' => $level,
				'SupportingSpecies' => $supportingSpecies,
				'ORFLength' => $orfLength,
				'ORFDir' => $orfDir,
				'Omega' => $omega,
				'AncesteralSeq' => $ancesteralSeq,
				'RegulatorySeqPart' => $regulatorySeqPart
	};
	
	if($lastCNS eq "") {
		$lastCNS = $CNSID;
	} else {
		### If this CNS overlap with last, pick one gene to associate it with (or merge)
		###
		my $CNSToDelete= "";
		if($CNSTable{$lastCNS}{'ReferenceGenome'} eq $referenceGenome && 
			$CNSTable{$lastCNS}{'Chromosome'} eq $chromosome && 
			overlap($CNSTable{$lastCNS}{'Start'},$CNSTable{$lastCNS}{'End'}, $start, $end)) {

				## Prefer the CNS with the most conserved synteny (largest number of supporting species for CNS-Gene synteny)
				if($CNSTable{$lastCNS}{'SupportingSpecies'} > $CNSTable{$CNSID}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $CNSID;
					$CNSDeleted++;
				} elsif($CNSTable{$CNSID}{'SupportingSpecies'} > $CNSTable{$lastCNS}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $lastCNS;
					$CNSDeleted++;
				} else {   ### If both CNSs have the same number of supporting species, we have to decide:
						### If the genes are same orientation and the CNS is in the same part of the regulatory sequence (Up/downstream)
						###  then associate with the closest gene.
						if( ($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Upstream") &&
							($CNSTable{$lastCNS}{'Strand'} eq $strand)) {    #### If both upstream. delete the one further away
							if($relEnd > $CNSTable{$lastCNS}{'RelEnd'}) {
								$CNSToDelete = $lastCNS;
							}
							else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Downstream") &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {  ### If both downstream, delete the one further away
							if($relStart < $CNSTable{$lastCNS}{'RelStart'}) {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} ne $regulatorySeqPart)  &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {   ### If one is upsteam, one downstream on opposite strands, delete the downstream (we assume upstream more likely)
							if($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Downstream") {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif( $CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Merged" ) {   #### If CNS hits a CNS that was already merged, just delete it
						$CNSToDelete = $CNSID;
						$CNSDeleted++;
					} else { ### If orientation is different then merge into one CNS.
						my $diffInCNSPos = $start-$CNSTable{$lastCNS}{'Start'};

						### Pick the longest one
						my $longestSeq;
						my $longestSeqCNS;
						if( ($CNSTable{$CNSID}{'End'} - $CNSTable{$CNSID}{'Start'}) > ($CNSTable{$lastCNS}{'End'} - $CNSTable{$lastCNS}{'Start'}) ) {
							$longestSeq = $CNSTable{$CNSID}{'AncesteralSeq'};
							$longestSeqCNS = $CNSID;
						} else {
							$longestSeq = $CNSTable{$lastCNS}{'AncesteralSeq'};
							$longestSeqCNS = $lastCNS;
						}
						## Update all the positions

						### If there is a mismatch of the stands between the merged CNS, reverse complement the mismatched one
						if($CNSTable{$CNSID}{'Strand'} ne $CNSTable{$lastCNS}{'Strand'} && $longestSeqCNS eq $CNSID) {
						#	print "We should switch this one $CNSID and $lastCNS.\n";
							my @lastCNSMappings = @{ $positionTable{$lastCNS}{'Positions'} };
							$positionTable{$lastCNS}{'Positions'} = ();

							foreach my $mapping (@lastCNSMappings) {
								my $seq = $mapping->{'TargetSequence'};
								$seq = reverse $seq;
                                $seq =~ tr/ACGT/TGCA/;
								$mapping->{'TargetSequence'} = $seq;
								my %newmapping = %$mapping;
								push( @{ $positionTable{$lastCNS}{'Positions'} }, \%newmapping);
							}
						}
						
						my @CNSMappings = @{ $positionTable{$CNSID}{'Positions'} };

						foreach my $mapping (@CNSMappings) {

							$mapping->{'PosInCNS'} = $mapping->{'PosInCNS'} + $diffInCNSPos;
							# If we changed the direction, we should reverse the sequence
							if($CNSTable{$CNSID}{'Strand'} ne $CNSTable{$lastCNS}{'Strand'} && $longestSeqCNS eq $lastCNS) {
								my $seq = $mapping->{'TargetSequence'};
								$seq = reverse $seq;
                                $seq =~ tr/ACGT/TGCA/;
								$mapping->{'TargetSequence'} = $seq;
							}
							my %newmapping = %$mapping;
							push( @{ $positionTable{$lastCNS}{'Positions'} } , \%newmapping);
						}

						### Merge CNS rel position
						$CNSTable{$lastCNS}{'RegulatorySeqPart'}="Merged";
						$CNSTable{$lastCNS}{'AncesteralSeq'} = $longestSeq;

						# and remove the old CNS
						$CNSToDelete = $CNSID;
						$CNSMerged++;
				}
			}
		} else {
			$lastCNS = $CNSID;
		}

		if($CNSToDelete ne "") {
			### Now delete the CNS. 
			### One exception. If this is a deeply conserved CNS, maintain a link to the other genes.
			if($CNSTable{$CNSToDelete}{'SupportingSpecies'} > $minSupportingSpeciesToKeepMultipleCNS) {
				$CNSDeletedButMappingKept++;
				my $CNSToCopyTo = $lastCNS;
				if($CNSToDelete eq $lastCNS) { $CNSToCopyTo = $CNSID; }
			
				my @CNSMappingsToCopy = @{ $positionTable{$CNSToDelete}{'Positions'} };
				my @CNSMappingsInTargetCNS = @{ $positionTable{$CNSToCopyTo}{'Positions'} };

				foreach my $mapping (@CNSMappingsToCopy) {
					my %newmapping = %$mapping;
					my $mappingAlreadyExists=0;
					## Search to see that we don't already if we already have that mapping
					foreach my $mappingInCNS (@CNSMappingsInTargetCNS) {
						if($newmapping{'TargetLocus'} eq $mappingInCNS->{'TargetLocus'} && $newmapping{'TargetPosition'} eq $mappingInCNS->{'TargetPosition'}) {
							$mappingAlreadyExists=1;
							next;
						}
					}
					if($mappingAlreadyExists) {
						push( @{ $positionTable{$CNSToCopyTo}{'Positions'} } , \%newmapping );
					}
				}
			}

			delete $positionTable{$CNSToDelete};
			delete $CNSTable{$CNSToDelete};
			if($CNSToDelete eq $lastCNS) { $lastCNS=$CNSID; }
		}
	}
}

close($CNSInputFile);
if($verbose) { print "\n"; }

#######################################################################################
###### Now go to the deeper merge - merge across different references

### First, build a map of hits indexed by gene

my %positionLocusMap;
my $totalToScreen = scalar (keys %positionTable);
$curPos=1;

foreach my $curCNS (keys %positionTable) {
	if($verbose) { print "PROGRESS: Building CNS Map..." . $curPos++. "/$totalToScreen\r"; };
	foreach my $curHit (@{ $positionTable{$curCNS}{'Positions'} }) {
		if(!defined $positionLocusMap{ $curHit->{'TargetLocus'} }) {
			$positionLocusMap{ $curHit->{'TargetLocus'} } = {
					'Positions' => () };
		 }
		 push( @{ $positionLocusMap{ $curHit->{'TargetLocus'} }{'Positions'} } , {
				'TargetSpecies' => $curHit->{'TargetSpecies'},
				'TargetLocus' => $curHit->{'TargetLocus'},
				'CNSID' => $curCNS,
				'TargetPosition' => $curHit->{'TargetPosition'} ,
				'ReferenceRelativePos' => $curHit->{'ReferenceRelativePos'},
				'Length' => $curHit->{'Length'},
				'TargetSequence' => $curHit->{'TargetSequence'} } );			
		}	
}

if($verbose) { print "\n" };
### Now Identify CNS to merge
my %CNSToMergeMap;
my %CNSToMergeHitMap;

### Scan all the hits to the locus. See if an alignment is hitting Two CNSs. If so, merge them.
$totalToScreen = scalar (keys %positionLocusMap);
$curPos=1;

foreach my $curLocus (keys %positionLocusMap) {
	
	if($verbose) { print "PROGRESS: Identifying deep CNS to merge..." . ($curPos++) . "/$totalToScreen.\r"; }
	
	foreach my $firstHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
		foreach my $secondHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {

			if(($firstHit->{'CNSID'} ne $secondHit->{'CNSID'}) && ($CNSTable{ $firstHit->{'CNSID'} }{'ReferenceGenome'} ne $CNSTable{ $secondHit->{'CNSID'} }{'ReferenceGenome'}) &&
			   ($CNSTable{ $firstHit->{'CNSID'} }{'RegulatorySeqPart'} eq $CNSTable{ $secondHit->{'CNSID'} }{'RegulatorySeqPart'}) ) {

				if(overlap($firstHit->{'TargetPosition'}, $firstHit->{'TargetPosition'}+$firstHit->{'Length'}, $secondHit->{'TargetPosition'}, $secondHit->{'TargetPosition'}+$secondHit->{'Length'}) > $minCNSOverlap ) {

					## Record the merging species
					if(!defined $CNSToMergeMap{ $firstHit->{'CNSID'} }{ $secondHit->{'CNSID'} }{ $firstHit->{'TargetSpecies'} } ) {
						$CNSToMergeMap{ $firstHit->{'CNSID'} }{ $secondHit->{'CNSID'} }{ $firstHit->{'TargetSpecies'} } = 1;
						$CNSToMergeMap{ $secondHit->{'CNSID'} }{ $firstHit->{'CNSID'} }{ $firstHit->{'TargetSpecies'} } = 1;
					}
				}
			}
		}
	}
}
if($verbose) {print "\n";}

my $deletedForLowSupport=0;

### Filter CNS merge events with too few hits

foreach my $curCNSA (keys %CNSToMergeMap) {
	foreach my $curCNSB (keys %{ $CNSToMergeMap{$curCNSA} }) {
		if( scalar keys %{ $CNSToMergeMap{$curCNSA}{$curCNSB} } < $minOverlappingSpeciesForMerge) {
			delete $CNSToMergeMap{$curCNSA}{$curCNSB};
			delete $CNSToMergeMap{$curCNSB}{$curCNSA};
			if((scalar keys %{ $CNSToMergeMap{$curCNSA} }) ==0) { delete $CNSToMergeMap{$curCNSA}; }
			if((scalar keys %{ $CNSToMergeMap{$curCNSB} }) ==0) { delete $CNSToMergeMap{$curCNSB}; }
			$deletedForLowSupport++;
		}
	}
}

if($verbose) { print "PROGRESS: Removed $deletedForLowSupport CNS merge events for low support.\n"; }

### Release memory
undef (%positionLocusMap);

### Convert Merge table to number of supporting species. Filter out CNS hits that have low identity scores following alignment to avoid merger of CNS that have diverged too far
$totalToScreen = scalar keys %CNSToMergeMap;
$curPos=1;
my $deletedForLowIdentity=0;

#### Filter CNS merge events with low sequence similarity (too divergent)

for my $curCNSA (keys %CNSToMergeMap ) {
	if($verbose) { print "PROGRESS: Calculating overlapping CNS hits and filtering..." . $curPos++ . "/$totalToScreen. Removed $deletedForLowIdentity low quality CNS merge events.\r"; }
	for my $curCNSB (keys %{ $CNSToMergeMap{$curCNSA}}) {

		## Check to see if we have enough similarity between the ancesteral CNSs

		sub score_sub {
			  if (!@_) {  return -0.5;  }  ## gap penalty
  				## mismatch scores -1, match +1
  				return ($_[0] eq $_[1]) ? 1 : -1;
		}
		my $nw = Algorithm::NeedlemanWunsch->new(\&score_sub);
		$nw->gap_open_penalty(-5);
		$nw->gap_extend_penalty(-0.25);

		my $seq1Arr = [split//, $CNSTable{$curCNSA}{'AncesteralSeq'}];
		my $seq2Arr = [split//, $CNSTable{$curCNSB}{'AncesteralSeq'}];
		my (@align1, @align2);

		$nw->align($seq1Arr,$seq2Arr,
		   {
   				align   => sub {unshift @align1, $seq1Arr->[shift]; unshift @align2, $seq2Arr->[shift];},
   				shift_a => sub {unshift @align1, $seq1Arr->[shift]; unshift @align2,            '-'},
   				shift_b => sub {unshift @align1,               '-'; unshift @align2, $seq2Arr->[shift]},
  			});
		my $pairwise = Bio::SimpleAlign->new();
		$pairwise->add_seq(Bio::LocatableSeq->new( -seq => join("",@align1), -id=> "seq1", -start=>0, -end=> scalar @align1));
		$pairwise->add_seq(Bio::LocatableSeq->new( -seq => join("",@align2), -id=> "seq2", -start=>0, -end=> scalar @align2));
		if($pairwise->percentage_identity() < $minCNSIdentityToMerge) {
			delete $CNSToMergeMap{$curCNSA}{$curCNSB};
			delete $CNSToMergeMap{$curCNSB}{$curCNSA};
			$deletedForLowIdentity++;
		}
	}
	if((scalar (keys %{ $CNSToMergeMap{$curCNSA} })) ==0) { delete $CNSToMergeMap{$curCNSA}; }	
}
if($verbose) { print "\n";}

### Collate CNSs into group. The first one is the anchor CNS and is the key for the superGroup hash

my %superGroups;
my %alreadyProcessedCNSs;

my $CNSCollated;
$totalToScreen = scalar (keys %CNSToMergeMap);
$curPos=1;

for my $curCNSToCollate (keys %CNSToMergeMap) {
	if($verbose) { print "PROGRESS: Collating CNS..." . $curPos++ . "/$totalToScreen. Found $CNSCollated that can be collated.\r"; }

	if(!defined $alreadyProcessedCNSs{$curCNSToCollate}) {
		my $collated = collateCNS($curCNSToCollate, \%CNSToMergeMap);
		$alreadyProcessedCNSs{$curCNSToCollate} = 1;
		$superGroups{$curCNSToCollate}{$curCNSToCollate} = 1;
		foreach my $curKeyToCopy ( keys %{ $collated->{'CollatedCNSs'} } ) { $alreadyProcessedCNSs{$curKeyToCopy} =1; $superGroups{$curCNSToCollate}{$curKeyToCopy}=1; }
		$CNSCollated++;
	}
}

if($verbose) { print("\n"); }

### Now merge merged CNS
my $superGroupMerged=0;

$totalToScreen = scalar (keys %superGroups);
$curPos=1;
my %CNSGroups;

foreach my $anchorCNS (keys %superGroups) {
	my $deepCNSNotice = "PROGRESS: Forming deep CNS groups...". $curPos++ . "/$totalToScreen.";
	if($verbose) { print $deepCNSNotice . "\r"; }

	print "\nProcessing super group $anchorCNS with CNSs : " . join("," , keys %{ $superGroups{$anchorCNS} }) . "\n";
	my %CNSsInGroup = %{ $superGroups{$anchorCNS} };

	$deepCNSMerged = $deepCNSMerged + (scalar keys %CNSsInGroup);
	$CNSMerged = $CNSMerged + (scalar keys %CNSsInGroup);

	my @positionConcats;

	for my $curCNS (keys %CNSsInGroup) {
		my @positions = @{ $positionTable{$curCNS}{'Positions'} };
		for my $curPos (@positions) {
			push @positionConcats, $curPos;
		}
	}
	### Merge overlapping position
	my @mergedPositions = mergeOverlappingTargetsForCNS(\@positionConcats);

	## Now assemble sequences

	#### build FASTA file for alignment
	my $tmpOutputSuperCNSFastaFileName = $tmpDir . "/tmp_$anchorCNS.fasta";
	my $tmpOutputSuperCNSFastaAlignedFileName = $tmpDir . "/tmp_$anchorCNS.aligned.fasta";
	open(my $tmpOutputSuperCNSFastaFile, ">" , $tmpOutputSuperCNSFastaFileName);

	foreach my $curPos (@mergedPositions) {
		print $tmpOutputSuperCNSFastaFile ">" . $curPos->{'TargetLocus'} . ":" . $curPos->{'TargetPosition'} . "\n" . $curPos->{'TargetSequence'} . "\n";
	}

	close($tmpOutputSuperCNSFastaFile);
	exit();
	## Now align using MAFFT
	system("mafft --quiet --thread 16 --maxiterate 1000 $tmpOutputSuperCNSFastaFileName > $tmpOutputSuperCNSFastaAlignedFileName ");

	my $alignedCNSFile = Bio::AlignIO->new(-file => $tmpOutputSuperCNSFastaAlignedFileName,
										-format => "fasta");
	my $superCNSAlignment = $alignedCNSFile->next_aln;

	### Set up the super CNS
	my $CNSGroupName = "$superCNSPrefix.$anchorCNS";

	$CNSTable{$CNSGroupName} = {
			'ReferenceGenome' => "SuperCNS",
			'CNSID' => $CNSGroupName,
			'Chromosome' => "",
			'Strand' => "",
			'Start' => 0,	
			'End' => length($superCNSAlignment->consensus_string),
			'Locus' => "",
			'RelStart' => "",
			'RelEnd' => "",
			'Level' => "",
			'SupportingSpecies' => 0,
			'ORFLength' => "",
			'ORFDir' => "",
			'Omega' => "",
			'AncesteralSeq' =>"",
			'RegulatorySeqPart' => ""};
	$positionTable{$CNSGroupName}{'Positions'} = ();

	### Map the alignments to the super CNS
	foreach my $curCNSposition ($superCNSAlignment->each_seq) {
		my ($targetLocus,$targetPosition) = split /:/, $curCNSposition->id;
		my ($targetSpecies) = split /-/, $targetLocus;
		my $sequence = uc($curCNSposition->seq);
		my ($leadingDashes) = $sequence =~ /^(-+)/;
		my $positionInCNS = length($leadingDashes);  ## The start position in the CNS is the number of leading dashes
		if($positionInCNS eq "") { $positionInCNS = 0; }

		### now, clear leading and trailing dashes		
		$sequence =~ s/^(-+)//;
		$sequence =~ s/(-+)$//;

		push ( @{ $positionTable{$CNSGroupName}{'Positions'} } , {
			'TargetSpecies' => $targetSpecies,
			'TargetLocus' => $targetLocus,
			'TargetPosition' => $targetPosition,
			'ReferenceRelativePos' => $positionInCNS,
			'Length' => length($sequence),
			'TargetSequence' => $sequence } );
	}

	$CNSGroups{$CNSGroupName} = 1;
	if($removeOriginalCNS) {
		foreach my $curCNS (keys %CNSsInGroup) {
			delete $CNSTable{$curCNS};
			delete $positionTable{$curCNS};
			delete $CNSToMergeMap{$curCNS};
		}
	}
	unlink($tmpOutputSuperCNSFastaFileName);
	unlink($tmpOutputSuperCNSFastaAlignedFileName);	
} 

if($verbose) { print "\n";}

## Merge overlapping position hits segments
$totalToScreen = scalar (keys %CNSTable);
$curPos=1;
my $overlappingPositionMerged=0;

#### Now split the merged CNSs


### Reconstruct sequences of Super CNS and determine conservation level
### First, load super tree
my $conservatoryTreeio = Bio::TreeIO->new(-file => $conservatoryTreeFileName, -format => 'newick');
my $conservatoryTree = $conservatoryTreeio->next_tree;

### Annotated Internal nodes
my $curNodeNumber=1;
my @nodes = $conservatoryTree->get_nodes();
foreach my $curNode (@nodes) {
	if($curNode->id eq "") { 
		$curNode->id("N$curNodeNumber");
		$curNodeNumber++;
	}
}

#my $conservatoryTreeOutput = Bio::TreeIO->new(-file => ">tmpTree.tree", -format => 'newick');
#$conservatoryTreeOutput->write_tree($conservatoryTree);

my %speciesInTree = map { ($_)->id => 1} $conservatoryTree->get_leaf_nodes;
my $totalToScreen = scalar (keys %CNSTable);
$curPos=1;

foreach my $curCNS (keys %CNSTable) {

	if($verbose) { print "PROGRESS: Reconstructing sequences and conservation analysis..." . $curPos++ . "/$totalToScreen\r"; }

	### Count supporting species and pick the longest alignment from each species
	my %speciesSequencesForCNS;
	foreach my $curPosInCNS (@{ $positionTable{$curCNS}{'Positions'}}) {
		if(defined $speciesInTree{ $curPosInCNS->{'TargetSpecies'} } &&  $curPosInCNS->{'Length'} > length($speciesSequencesForCNS{ $curPosInCNS->{'TargetSpecies'} }) ) {
			$speciesSequencesForCNS{ $curPosInCNS->{'TargetSpecies'} } = $curPosInCNS->{'TargetSequence'};
		}
	}

	$CNSTable{$curCNS}{'SupportingSpecies'} = scalar (keys %speciesSequencesForCNS);
	## If this is a grouped CNS, we need to reconstruct the ancesteral sequence
	if(defined $CNSGroups{$curCNS}) {

		## To do so, first build a species fasta file
		my $tmpOutputFastaFileName = $tmpDir . "/tmp_sp_$curCNS.fasta";
		my $tmpOutputFastaAlignedFileName = $tmpDir . "/tmp_sp_$curCNS.align.fasta";
		open(my $tmpOutputFastaFile , ">" , $tmpOutputFastaFileName);

		### Generate fasta file for sequence reconstruction using tree
		foreach my $curSpecies (keys %speciesInTree) {
			if(defined $speciesInTree{$curSpecies}) {
				if(defined $speciesSequencesForCNS{$curSpecies}) {
					print $tmpOutputFastaFile ">$curSpecies\n" . $speciesSequencesForCNS{$curSpecies} . "\n";
				} else {
					print $tmpOutputFastaFile ">$curSpecies\n" . ('-' x 50). "\n";
				}
			}
		}
		close($tmpOutputFastaFile);
		## Now align using MAFFT
		system("mafft --quiet --thread 16 --maxiterate 1000 $tmpOutputFastaFileName > $tmpOutputFastaAlignedFileName");
		## and perform reconstruction
		my $tmpOutputAncesteralSequenceFileName = $tmpDir . "/tmp_as_$curCNS.fasta";
		system("$conservatoryDir/scripts/fastml -b -qf -mh -s $tmpOutputFastaAlignedFileName -t $conservatoryTreeFileName -y /dev/null/a -d /dev/null/a -x /dev/null/a -k /dev/null/a -d /dev/null/a -e /dev/null/a -j $tmpOutputAncesteralSequenceFileName > /dev/null");

		### Read concensus sequence
		my $inReconstructionFasta = Bio::SeqIO->new(-file => $tmpOutputAncesteralSequenceFileName, -format => "fasta", -alphabet => "dna");
		my $reconstructedSequence;
		while(my $seq = $inReconstructionFasta->next_seq) {
			if($seq->id eq "N1") { $reconstructedSequence = $seq->seq; }
		}
		$CNSTable{$curCNS}{'AncesteralSeq'} = $reconstructedSequence;
		unlink($tmpOutputAncesteralSequenceFileName);
		unlink($tmpOutputFastaFileName);
		unlink($tmpOutputFastaAlignedFileName);
	}

	### Identify the deepest node in the tree - the point of CNS origination
	
	my @sharedLeaves = keys %speciesSequencesForCNS;
	my $deepestNode = findDeepestCommonNode($conservatoryTree, \@sharedLeaves);
  	$CNSTable{$curCNS}{'Level'} = $deepestNode;
}

if($verbose) { print "\n"; }

if($verbose) { print "\nPROGRESS: Done. Output files.\n"; }

########### Output files
### New CNS files
open (my $outputCNSFile, ">$outputCNSFileName") || die ("INTERNAL ERROR.\n");
open (my $outputMapFile, ">$outputMapFileName") || die ("INTERNAL ERROR.\n");

foreach my $curCNS (sort keys %CNSTable) {

	if(defined $positionTable{$curCNS}{'Positions'} && $CNSTable{$curCNS}{'CNSID'} eq $curCNS) {  ### The second conditions is to verify that all the CNS in the position file are found in the CNS file.
																								  ### This only occurs if we input partial data.
		if((scalar @{ $positionTable{$curCNS}{'Positions'} }) >0 ) {
			print $outputCNSFile join(",",
					$CNSTable{$curCNS}{'ReferenceGenome'},
					$CNSTable{$curCNS}{'CNSID'},
					$CNSTable{$curCNS}{'Chromosome'},
					$CNSTable{$curCNS}{'Strand'},
					$CNSTable{$curCNS}{'Start'},	
					$CNSTable{$curCNS}{'End'},
					$CNSTable{$curCNS}{'Locus'},
					$CNSTable{$curCNS}{'RelStart'},
					$CNSTable{$curCNS}{'RelEnd'},
					$CNSTable{$curCNS}{'Level'},
					$CNSTable{$curCNS}{'SupportingSpecies'},
					$CNSTable{$curCNS}{'ORFLength'},
					$CNSTable{$curCNS}{'ORFDir'},
					$CNSTable{$curCNS}{'Omega'},
					$CNSTable{$curCNS}{'AncesteralSeq'}) ."\n";
	
			foreach my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
				print $outputMapFile join(",",
					$curCNS,
					$mapping->{'TargetSpecies'},
					$mapping->{'TargetLocus'},
					$mapping->{'TargetPosition'},
					$mapping->{'ReferenceRelativePos'},
					$mapping->{'Length'},
					$mapping->{'TargetSequence'}) ."\n";		
			}
		}
	}
}

close($outputCNSFile);
close($outputMapFile);

##########

if($outputMergedCNSFileName ne "") {
	open (my $outputMergedCNSFile, ">$outputMergedCNSFileName") || die ("INTERNAL ERROR.\n");
	foreach my $groupCNS (sort keys %CNSGroups) {
		foreach my $subCNS (@{ $CNSGroups{$groupCNS} } ) {
			print $outputMergedCNSFile "$groupCNS,$subCNS\n";
		}
	}
	close ($outputMergedCNSFile);
}

print "END: Deleted $CNSDeleted duplicated CNSs, of which $CNSDeletedButMappingKept mapping kept; Merged $CNSMerged CNSs, of which " . $deepCNSMerged . " were deep CNSs, collated into $CNSCollated grouped CNSs.\n";

#############################################################################3
### Compute overlap between two fragments. 
### Parameters:
### overlap(startOne, endOne, StartTwo, endTwo, mode)
### returns relative overlap (0-1).
###

sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		return (min($endOne, $endTwo) - max($startOne, $startTwo))/ max( $endOne-$startOne, $endTwo-$startTwo);
	}
}


#########################################################################################################
#### Recurive function to identify all overlapping CNSs
#### format: collateCNS(<Name of CNS>, <hash of CNS-CNS overlaps>, <list of overlapping CNS>)
####
####   usage:
####   my $overlappingCNSs = collateCNS($CNS, $CNSMergeMap)
####
sub collateCNS {
	my ($cnsName, $map, $collatedCNSObject) = @_;
	my %collatedCNSs;  ## This is the list of CNSs that make up this superCNS
	if(defined $collatedCNSObject) {
		%collatedCNSs = %{ $collatedCNSObject->{'CollatedCNSs'} };
	} 	$collatedCNSs{$cnsName} =1;

	my @CNSsToScan = keys %{ $map->{$cnsName} };
	foreach my $curCNSToScan (@CNSsToScan) {
		### If we didn't scan this CNS already
		if(!defined %collatedCNSs{$curCNSToScan}) {
			my $scanResults = collateCNS($curCNSToScan, $map, { "CollatedCNSs" => \%collatedCNSs});
			## and copy scan results to main hash
			foreach my $curCNSToCopy (keys %{ $scanResults->{'CollatedCNSs'}}) { $collatedCNSs{$curCNSToCopy} =1;}
		}
	}
	foreach my $curCNSToScan (@CNSsToScan) { $collatedCNSs{$curCNSToScan} = 1; }
	
	return { "CollatedCNSs" => \%collatedCNSs };
}

#########################################################################################################
### 
###  format: mergeOverlappingTargetsForCNS(\@positionMap)
###

sub mergeOverlappingTargetsForCNS {
	my ($positionMapRef) = @_;
	my @positionMap = @$positionMapRef;
	my @positionMapMerged;

	my @positionMapSortedByGene = sort { $a->{'TargetLocus'} cmp $b->{'TargetLocus'} } @positionMap;
	my $curLocus = $positionMapSortedByGene[0]->{'TargetLocus'};
	my @positionMapForLocus=();

	foreach my $curPositionForGene (@positionMapSortedByGene) {
		if($curPositionForGene->{'TargetLocus'} eq $curLocus) {
			push @positionMapForLocus, $curPositionForGene;
		} else {
			## Sort the positions
			my @positionMapSorted = sort { $a->{'TargetPosition'} <=> $b->{'TargetPosition'} } @positionMapForLocus;

			my $curPosition = $positionMapSorted[0];
			foreach my $nextPosition (@positionMapSorted) {
				print $curPosition->{'TargetLocus'} . ":" . $curPosition->{'TargetPosition'} . ":" . $curPosition->{'Length'} . " with " . $nextPosition->{'TargetPosition'} . ":" . $nextPosition->{'Length'} . "\n";
				if(overlap($curPosition->{'TargetPosition'},$curPosition->{'TargetPosition'} + $curPosition->{'Length'},
					   	$nextPosition->{'TargetPosition'}, $nextPosition->{'TargetPosition'} + $nextPosition->{'Length'})) {
					### merge the two positions
					$curPosition->{'TargetSequence'} = substr($curPosition->{'TargetSequence'}, 0, $nextPosition->{'TargetPosition'} - $curPosition->{'TargetPosition'}) . $nextPosition->{'TargetSequence'};
					$curPosition->{'Length'} = length($curPosition->{'TargetSequence'});
					print "Merging overlap. New length: " . $curPosition->{'Length'} . "\n";
	   			} else {
					my %newPosition = %$curPosition;
					push @positionMapMerged, \%newPosition;
					$curPosition = $nextPosition;
		   		}
			}
			push @positionMapMerged, $curPosition;
			$curLocus = $curPositionForGene->{'TargetLocus'};
			@positionMapForLocus = ($curPositionForGene);
		}
	}

	return @positionMapMerged;
}

##########################################################################################################
####
####  Given a tree and a set of nodes on the tree, findDeepestCommonNode returns the name of the deepest node
####   shared by all leaves. This can be used to identify the evolutionary origin of a CNS
###

sub findDeepestCommonNode {
	my ($tree, $leavesListRef) = @_;
	my @leavesList = @$leavesListRef;


	my $anchorLeafNode = $tree->find_node($leavesList[0]);
	my %anchorLeafPath;
	my $node = $anchorLeafNode;
	my $deepestNode = $node->id;

	my $deepness=1;
	while($node->ancestor) {
		$node = $node->ancestor;
		$anchorLeafPath{$node->id} = $deepness++;
	}

	foreach my $leaf (@leavesList) {
		my $node = $tree->find_node( -id => $leaf);
		while($node->ancestor) {
			$node = $node->ancestor;
			if(defined $anchorLeafPath{$node->id}) {  ### This is where the path intersect. Check if this is the deepest we found
				if( $anchorLeafPath{$node->id} > $anchorLeafPath{$deepestNode}) {
					$deepestNode = $node->id;
				}
				last;
			}
		}
	}
	return $deepestNode;
}