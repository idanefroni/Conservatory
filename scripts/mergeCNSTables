#!/usr/bin/perl

use POSIX;
use strict;
use Array::Utils qw(:all);
use Cwd 'abs_path';
use List::Util qw(min max uniq);
use Bio::AlignIO;
use Bio::Seq;
use Bio::LocatableSeq;
use Bio::Tools::Run::Alignment::Muscle;
use Algorithm::NeedlemanWunsch;
use Bio::SimpleAlign;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;
use Getopt::Long;
$|=1;


### Filenames
my $conservatoryDir=abs_path(".");
my $CNSFileName="";
my $mapFileName="";
my $outputCNSFileName="";
my $outputMapFileName="";
my $outputMergedCNSFileName="";


### Merging parameters
my $superCNSPrefix = "Super";
my $minOverlappingSpeciesForMerge=5; ### How many overlapping hits to merge a CNS
my $minCNSOverlap = 0.5;
my $minSyntenyBiasToAssignCNS= 1.2; ### Number between 1 and 2 (how many more species need to support a two-gene CNS assignment to just one of the genes, based on synteny)
my $removeOriginalCNS=0;
my $minCNSIdentityToMerge=70;

## Filtering parameters
my $CLASSIFICATION_CLASSES_NUM=6;
my $minSpeciesForClassification=6; 	### Minimum absolute number of species to support a classification

my %CNSTable;
my %positionTable;
my %genomeToSpecies;
my %genomeToFamily;
my %speciesToFamily;
my %speciesClassification;

my $CNSMerged=0;
my $CNSMergedExtended=0;
my $CNSDeleted=0;
my $deepCNSMerged=0;
my $donotFilter=0;

my $verbose=0;
my $help=0;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"in-cns=s" => \$CNSFileName,
			"in-map=s" => \$mapFileName,
			"out-cns=s" => \$outputCNSFileName,
			"out-map=s" => \$outputMapFileName,
			"out-merged=s" => \$outputMergedCNSFileName,
			"verbose" => \$verbose,
			"min-overlapping" => \$minOverlappingSpeciesForMerge,
			"remove-original-CNS" => \$removeOriginalCNS,
			"do-not-filter" => \$donotFilter,
			"help" => \$help) or die ("Error in command line arguments\n");
			
			
if($help || $CNSFileName eq "" || $mapFileName eq "" || $outputCNSFileName eq "" || $outputMapFileName eq "" ) {
	print "Conservatory version 2.0.1\n\n";
	print "mergeCNSTables --in-cns <cnsFile> --in-map <cnsPositionMapFile> --out-cns <cnsFile> --out-map <cnsPositionMapFile>  [--out-merged <mergedDeepCNSfile>] [--min-overlapping <number>] [--remove-original-CNS] [--do-not-filter].\n\n";
	
	exit();
}

if ($verbose) { print "START: Loading genome database.\n"; }
my $genomedbFile = $conservatoryDir . "/genome_database.csv";
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;
my $t_muscle = `sh -c 'command -v muscle'`;
die "ERROR: Cannot find muscle in path. Please make sure muscle v3.8.1551 is installed.\n" unless ($t_muscle ne "");  

open (my $genomeDatabase, "<", $genomedbFile);
while((my $curgenomeline = <$genomeDatabase>)) {
	chomp($curgenomeline);
	if(substr($curgenomeline,0,1) ne "#")  {
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$genomeToSpecies{$curgenomeName}=  $curgenomeSpecies;
		$genomeToFamily{$curgenomeName} = $curgenomeFamily;
		$speciesToFamily{$curgenomeSpecies} = $curgenomeFamily;
		$speciesClassification{$curgenomeSpecies} = $classification;
	}
}

if ($verbose) { print "END: Loading genome database.\n"; }

my $positionLineCount = (qx(wc -l $mapFileName))[0];
chomp ($positionLineCount);
my $curPos=1;

########## Load position table to memory
open (my $CNSPositionFile, $mapFileName) ||  die "ERROR: Cannot find position file $mapFileName.\n";
while(<$CNSPositionFile>) {
	if($verbose) { print "PROGRESS: Loading mappings..." . $curPos++ . "/$positionLineCount\r" };

	chomp;
	my ($CNSID, $targetSpecies, $targetLocus, $targetRelativePosition, $referenceRelativePosition, $length, $targetSequence) = split /,/;
	
	### Filter for only embryophyta hits
	my @classification = split /-/, $speciesClassification{ $genomeToSpecies{$targetSpecies} }; 
	if($classification[0] eq "Embryophyta") {
		## Only if non-filtered CNS
		if(!defined $positionTable{$CNSID}) {
			$positionTable{$CNSID} = {
						'CNSID' => $CNSID,
						'Positions' => () };
		}

		push( @{ $positionTable{$CNSID}{'Positions'} } , {
					'TargetSpecies' => $targetSpecies,
					'TargetLocus' => $targetLocus,
					'TargetPosition' => $targetRelativePosition,
					'ReferenceRelativePos' => $referenceRelativePosition,
					'Length' => $length,
					'TargetSequence' => $targetSequence} );		
	}
}
close($CNSPositionFile);
if($verbose) { print "\n"; };

### Now start merging CNSs. First read and merge all CNSs in the family

open (my $CNSInputFile,"sort -t',' -k1,1 -k3,3 -k5,5n $CNSFileName |") ||  die "ERROR: Cannot find CNS file $CNSFileName.\n";
$curPos=1;
my $CNSLineCount= (qx(wc -l $CNSFileName))[0];
chomp($CNSLineCount);
my $lastCNS ="";
my %CNSTable;
while(<$CNSInputFile>) {
	if($verbose) { print "PROGRESS: Merging family CNS... " . $curPos++ . "/$CNSLineCount. Merged $CNSMerged.\r" };
	chomp;
	my ($referenceGenome, $CNSID, $chromosome, $strand, $start, $end, $locus, $relStart, $relEnd, $level, $supportingSpecies, $orfLength, $orfDir, $omega, $ancesteralSeq) = split /,/;

	if(!defined $positionTable{$CNSID} ) { next; }
	
	my $regulatorySeqPart;
	if($relStart<0) {
		$regulatorySeqPart = "Upstream";
	} else {
		$regulatorySeqPart = "Downstream";
	}
	$CNSTable{$CNSID} = {
				'ReferenceGenome' => $referenceGenome,
				'CNSID' => $CNSID,
				'Chromosome' => $chromosome,
				'Strand' => $strand,
				'Start' => $start,	
				'End' => $end,
				'Locus' => $locus,
				'RelStart' => $relStart,
				'RelEnd' => $relEnd,
				'Level' => $level,
				'SupportingSpecies' => $supportingSpecies,
				'ORFLength' => $orfLength,
				'ORFDir' => $orfDir,
				'Omega' => $omega,
				'AncesteralSeq' => $ancesteralSeq,
				'RegulatorySeqPart' => $regulatorySeqPart
	};
	
	if($lastCNS eq "") {
		$lastCNS = $CNSID;
	} else {
		### If this CNS overlap with last, pick one gene to associate it with (or merge)
		###
		my $CNSToDelete= "";
		if($CNSTable{$lastCNS}{'ReferenceGenome'} eq $referenceGenome && 
			$CNSTable{$lastCNS}{'Chromosome'} eq $chromosome && 
			overlap($CNSTable{$lastCNS}{'Start'},$CNSTable{$lastCNS}{'End'}, $start, $end)) {

#				if($verbose) { print "Found overlapping CNS: $lastCNS and $CNSID.\n"; }

				## Prefer the CNS with the most conserved synteny (largest number of supporting species for CNS-Gene synteny)
				if($CNSTable{$lastCNS}{'SupportingSpecies'} > $CNSTable{$CNSID}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $CNSID;
					$CNSDeleted++;
				} elsif($CNSTable{$CNSID}{'SupportingSpecies'} > $CNSTable{$lastCNS}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $lastCNS;
					$CNSDeleted++;
				} else {   ### If both CNSs have the same number of supporting species, we have to decide:
						### If the genes are same orientation and the CNS is in the same part of the regulatory sequence (Up/downstream)
						###  then associate with the closest gene.
						if( ($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Upstream") &&
							($CNSTable{$lastCNS}{'Strand'} eq $strand)) {    #### If both upstream. delete the one further away
							if($relEnd > $CNSTable{$lastCNS}{'RelEnd'}) {
								$CNSToDelete = $lastCNS;
							}
							else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Downstream") &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {  ### If both downstream, delete the one further away
							if($relStart < $CNSTable{$lastCNS}{'RelStart'}) {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} ne $regulatorySeqPart)  &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {   ### If one is upsteam, one downstream on opposite strands, delete the downstream (we assume upstream more likely)
							if($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Downstream") {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif( $CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Merged" ) {   #### If CNS hits a CNS that was already merged, just delete it
						$CNSToDelete = $CNSID;
						$CNSDeleted++;
					} else { ### If orientation is different then merge into one CNS.
						my $diffInCNSPos = $start-$CNSTable{$lastCNS}{'Start'};

						### Pick the longest one
						my $longestSeq;
						if( ($CNSTable{$CNSID}{'End'} - $CNSTable{$CNSID}{'Start'}) > ($CNSTable{$lastCNS}{'End'} - $CNSTable{$lastCNS}{'Start'}) ) {
							$longestSeq = $CNSTable{$CNSID}{'AncesteralSeq'};
						} else {
							$longestSeq = $CNSTable{$lastCNS}{'AncesteralSeq'};
						}
						## Update all the positions
						my @CNSMappings = @{ $positionTable{$CNSID}{'Positions'} };

						foreach my $mapping (@CNSMappings) {
							my @lastCNSMappings = @{ $positionTable{$lastCNS}{'Positions'} };
							$mapping->{'PosInCNS'} = $mapping->{'PosInCNS'} + $diffInCNSPos;
							my %newmapping = %$mapping;
							push( @{ $positionTable{$lastCNS}{'Positions'} } , \%newmapping);
						}

						### Merge CNS rel position
						$CNSTable{$lastCNS}{'RegulatorySeqPart'}="Merged";
						$CNSTable{$lastCNS}{'AncesteralSeq'} = $longestSeq;

						# and remove the old CNS
						$CNSToDelete = $CNSID;
						$CNSMerged++;
				}
			}
		} else {
			$lastCNS = $CNSID;
		}

		if($CNSToDelete ne "") {
			delete $positionTable{$CNSToDelete};
			delete $CNSTable{$CNSToDelete};
			if($CNSToDelete eq $lastCNS) { $lastCNS=$CNSID; }
		}
	}
}

close($CNSInputFile);
if($verbose) { print "\n"; }

###### Now go to the deeper merge - merge across different references

### First, build a map of hits indexed by gene

my %positionLocusMap;
my $totalToScreen = scalar (keys %positionTable);
$curPos=1;

foreach my $curCNS (keys %positionTable) {
	if($verbose) { print "PROGRESS: Building CNS Map..." . $curPos++. "/$totalToScreen\r"; };
	foreach my $curHit (@{ $positionTable{$curCNS}{'Positions'} }) {
		if(!defined $positionLocusMap{ $curHit->{'TargetLocus'} }) {
			$positionLocusMap{ $curHit->{'TargetLocus'} } = {
					'Positions' => () };
		 }
		 push( @{ $positionLocusMap{ $curHit->{'TargetLocus'} }{'Positions'} } , {
				'TargetSpecies' => $curHit->{'TargetSpecies'},
				'TargetLocus' => $curHit->{'TargetLocus'},
				'CNSID' => $curCNS,
				'TargetPosition' => $curHit->{'TargetPosition'} ,
				'ReferenceRelativePos' => $curHit->{'ReferenceRelativePos'},
				'Length' => $curHit->{'Length'},
				'TargetSequence' => $curHit->{'TargetSequence'} } );			
		}	
}

if($verbose) { print "\n" };
### Now Identify CNS to merge
my %CNSToMerge;
my %CNSToMergeHitMap;

### Scan all the hits to the locus. See if an alignment is hitting Two CNSs. If so, merge them.
$totalToScreen = scalar (keys %positionLocusMap);
$curPos=1;

foreach my $curLocus (keys %positionLocusMap) {
	
	if($verbose) { print "PROGRESS: Identifying deep CNS to merge..." . ($curPos++) . "/$totalToScreen. Found $deepCNSMerged.\r"; }
	
	foreach my $firstHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
		foreach my $secondHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {

			if(($firstHit->{'CNSID'} ne $secondHit->{'CNSID'}) && ($CNSTable{ $firstHit->{'CNSID'} }{'ReferenceGenome'} ne $CNSTable{ $secondHit->{'CNSID'} }{'ReferenceGenome'}) &&
			   ($CNSTable{ $firstHit->{'CNSID'} }{'RegulatorySeqPart'} eq $CNSTable{ $secondHit->{'CNSID'} }{'RegulatorySeqPart'}) ) {

				if(overlap($firstHit->{'TargetPosition'}, $firstHit->{'TargetPosition'}+$firstHit->{'Length'}, $secondHit->{'TargetPosition'}, $secondHit->{'TargetPosition'}+$secondHit->{'Length'}) > $minCNSOverlap ) {
					### We should merge the CNS
					my $first;
					my $second;
					if(defined $CNSToMerge{ $secondHit->{'CNSID'}}) {
						$first = $secondHit->{'CNSID'};
						$second = $firstHit->{'CNSID'};
					} else {
						$first = $firstHit->{'CNSID'};
						$second = $secondHit->{'CNSID'};
					}

					$CNSToMerge{ $first }{ $second }{ $firstHit->{'TargetSpecies'} } ++;

					if( (scalar keys %{ $CNSToMerge{ $first }{ $second } }) == $minOverlappingSpeciesForMerge) {
						$CNSMerged++;
						$deepCNSMerged++;
					}
				}
			}
		}
	}
}
if($verbose) {print "\n";}

### Release memory
undef (%positionLocusMap);

### Convert Merge table to number of supporting species. Filter out CNS hits that have low identity scores following alignment to avoid merger of CNS that have diverged too far

$totalToScreen = scalar keys %CNSToMerge;
$curPos=1;
my $deletedForLowIdentity=0;

for my $curCNSA (keys %CNSToMerge ) {
	if($verbose) { print "PROGRESS: Calculating overlapping CNS hits and filtering..." . $curPos++ . "/$totalToScreen. Removed $deletedForLowIdentity low quality CNS merge events.\r"; }
	for my $curCNSB (keys %{ $CNSToMerge{$curCNSA}}) {
		$CNSToMerge{ $curCNSA }{ $curCNSB } = scalar keys %{  $CNSToMerge{$curCNSA}{$curCNSB} };
		## Check to see if we have enough similarity between the ancesteral CNSs

		sub score_sub {
			  if (!@_) {  return -0.5;  }  ## gap penalty
  				## mismatch scores -1, match +1
  				return ($_[0] eq $_[1]) ? 1 : -1;
		}
		my $nw = Algorithm::NeedlemanWunsch->new(\&score_sub);
		$nw->gap_open_penalty(-5);
		$nw->gap_extend_penalty(-0.25);

		my $seq1Arr = [split//, $CNSTable{$curCNSA}{'AncesteralSeq'}];
		my $seq2Arr = [split//, $CNSTable{$curCNSB}{'AncesteralSeq'}];
		my (@align1, @align2);

		$nw->align($seq1Arr,$seq2Arr,
		   {
   				align   => sub {unshift @align1, $seq1Arr->[shift]; unshift @align2, $seq2Arr->[shift];},
   				shift_a => sub {unshift @align1, $seq1Arr->[shift]; unshift @align2,            '-'},
   				shift_b => sub {unshift @align1,               '-'; unshift @align2, $seq2Arr->[shift]},
  			});
		my $pairwise = Bio::SimpleAlign->new();
		$pairwise->add_seq(Bio::LocatableSeq->new( -seq => join("",@align1), -id=> "seq1", -start=>0, -end=> scalar @align1));
		$pairwise->add_seq(Bio::LocatableSeq->new( -seq => join("",@align2), -id=> "seq2", -start=>0, -end=> scalar @align2));
		if($pairwise->percentage_identity() < $minCNSIdentityToMerge) {
			delete $CNSToMerge{$curCNSA}{$curCNSB};
			if((scalar keys %{ $CNSToMerge{$curCNSA} }) ==0) { delete $CNSToMerge{$curCNSA}; }
			$deletedForLowIdentity++;
		}
	}
}
if($verbose) { print "\n";}
### Now merge merged CNS
my $superGroupMerged=0;
my %collatedCNS;
my $CNSCollated=0;

## First, collate the CNS but looking for CNS groups with shared CNS and merge them into one.

my %CNSGroupMappingHash;

if($verbose) { print "PROGRESS: Building CNS overlap map...\n"; }
## First, create a reverse mapping hash. Every child CNS has a subhash with its parent and all of its siblings.

for my $curCNS (keys %CNSToMerge) {
	my @curCNScontent = keys %{ $CNSToMerge{$curCNS} };
	for my $curSubCNS (@curCNScontent) {
		$CNSGroupMappingHash{$curSubCNS}{$curCNS}=1;
		for my $curSubSiblingCNS (@curCNScontent) {
			if ($curSubCNS ne $curSubSiblingCNS) {
				$CNSGroupMappingHash{$curSubCNS}{$curSubSiblingCNS}=1;
			}
		}
	}
	$CNSGroupMappingHash{$curCNS}{$curCNS}=1;
}

my @CNSGroupsSorted = reverse sort { (scalar keys %{ $CNSToMerge{$a} } ) <=> (scalar keys %{ $CNSToMerge{$b} } ) } keys %CNSToMerge;

$totalToScreen = scalar @CNSGroupsSorted;
$curPos=1;

for my $curCNS (@CNSGroupsSorted) {
	if($verbose) { print "PROGRESS: Collating merged CNSs..." . $curPos++ . "/$totalToScreen. Found $CNSCollated.\r";}
	if(defined $CNSGroupMappingHash{ $curCNS } && !defined $collatedCNS{$curCNS}) {
		my @newCNSComposition = grep {$_ ne $curCNS } uniq(keys %{ $CNSGroupMappingHash{$curCNS} }, keys %{ $CNSToMerge{$curCNS} });
		for my $curCNSToAdd (@newCNSComposition) {
			$CNSToMerge{$curCNS}{$curCNSToAdd} = $minOverlappingSpeciesForMerge;
			delete $CNSGroupMappingHash{$curCNS}{$curCNSToAdd};
			delete $CNSGroupMappingHash{$curCNSToAdd}{$curCNS};

			$collatedCNS{$curCNSToAdd}=1;
		}
		$CNSCollated++;
#		print "Collating $curCNS: new composition: " . join(",", @newCNSComposition) . "\n";
	} 
}

for my $curCNSToDelete (keys %collatedCNS) {
#	print "We dont need $curCNSToDelete anymore\n";
	delete $CNSToMerge{$curCNSToDelete};
}

if($verbose) { print("\n"); }
$totalToScreen = scalar (keys %CNSToMerge);
$curPos=1;
my %CNSGroups;

foreach my $curCNS (keys %CNSToMerge) {
	my $deepCNSNotice = "PROGRESS: Forming deep CNS groups...". $curPos++ . "/$totalToScreen.";
	if($verbose) { print $deepCNSNotice . "\r"; }
	# filter low support mergers
#	print "$curCNS after filtering has subCNSs. " . (scalar keys %{ $CNSToMerge{$curCNS} }) . ". CNSs:" . join(",", keys %{ $CNSToMerge{$curCNS} }) . "\n";
	foreach my $cnsB (keys %{ $CNSToMerge{$curCNS } }) {
		if($CNSToMerge{$curCNS}{$cnsB} < $minOverlappingSpeciesForMerge) {
			delete $CNSToMerge{$curCNS}{$cnsB};
		}
	}

	my @otherCNSs = keys %{ $CNSToMerge{$curCNS} };

#	print "$curCNS after filtering has subCNSs. " . scalar @otherCNSs . ". CNSs:" . join(",", @otherCNSs) . "\n";

	if( @otherCNSs >0) {
		my $CNSGroupName = "$superCNSPrefix.$curCNS";

		$CNSTable{$CNSGroupName} = {
				'ReferenceGenome' => "SuperCNS",
				'CNSID' => $CNSGroupName,
				'Chromosome' => "",
				'Strand' => "",
				'Start' => "",	
				'End' => "",
				'Locus' => "",
				'RelStart' => "",
				'RelEnd' => "",
				'Level' => $CNSTable{$curCNS}{'Level'},
				'SupportingSpecies' => 0,
				'ORFLength' => "",
				'ORFDir' => "",
				'Omega' => "",
				'AncesteralSeq' => "",
				'RegulatorySeqPart' => ""};
		my @CNSsToJoin = ($curCNS, keys %{ $CNSToMerge{$curCNS} });
	
		$CNSGroups{$CNSGroupName} = \@CNSsToJoin;

		$positionTable{$CNSGroupName}{'Positions'} = ();

		my $remappedPositions=0;
		my @ancesteralSeqs;

		foreach my $curCNSToJoin ( @CNSsToJoin ) {
			my $numPosToMap = scalar @{ $positionTable{$curCNSToJoin}{'Positions'} };
			# if($verbose) { print "$deepCNSNotice. Joining $curCNSToJoin to $CNSGroupName. Remapped $remappedPositions/$numPosToMap.\r"; }
			my $ancesteralCNSSeq = Bio::LocatableSeq->new(-seq => $CNSTable{$curCNSToJoin}{'AncesteralSeq'},
						    	  					  -id => $curCNSToJoin,
						    	  					  -start => 1,
						    	  					  -end => length($CNSTable{$curCNSToJoin}{'AncesteralSeq'}));
			push @ancesteralSeqs, $ancesteralCNSSeq;

			foreach my $mapping ( @{ $positionTable{$curCNSToJoin}{'Positions'} }  ) {
			
				### Check to see if it is not there yet
				my $needToRemap=1;
				foreach my $curMapPos ( @{ $positionTable{$CNSGroupName}{'Positions'} }) {
					if($curMapPos->{'TargetLocus'} eq $mapping->{'TargetLocus'} &&
				   	   $curMapPos->{'TargetPosition'} eq $mapping->{'TargetPosition'}) {
						$needToRemap=0;
					}
				}
				if($needToRemap) {
					push ( @{ $positionTable{$CNSGroupName}{'Positions'} } , 	{
						'TargetSpecies' => $mapping->{'TargetSpecies'},
						'TargetLocus' => $mapping->{'TargetLocus'},
						'TargetPosition' => $mapping->{'TargetPosition'},
						'ReferenceRelativePos' => $mapping->{'ReferenceRelativePos'},
						'Length' => $mapping->{'Length'},
						'TargetSequence' => $mapping->{'TargetSequence'}
					});
					$remappedPositions++;
				}
			}
		}

		#### Align CNSs to obtain a consensus sequence for the Super CNS

		my $aligner = Bio::Tools::Run::Alignment::Muscle->new(('quiet' => 1));
		my $superCNSSeqs = $aligner->align(\@ancesteralSeqs);
		$CNSTable{$CNSGroupName}{'AncesteralSeq'} = $superCNSSeqs->consensus_string(30);
	} 
}

if($removeOriginalCNS) {
	foreach my $curCNS (keys %CNSToMerge) {
		foreach my $targetCNS (keys %{ $CNSToMerge{$curCNS} }) {
			if(!($targetCNS =~ /^$superCNSPrefix/)) {
				delete $CNSTable{$targetCNS};
				delete $positionTable{$targetCNS};
			}
		}
		if(!($curCNS =~ /^$superCNSPrefix/)) {
			delete $CNSTable{$curCNS};
			delete $positionTable{$curCNS};			
		}
	}
						
}
if($verbose) { print "\n";}


$totalToScreen = scalar (keys %CNSTable);
$curPos=1;
foreach my $curCNS (keys %CNSTable) {
	## Count supporting species
	if($verbose) { print "PROGRESS: Remapping and filtering..." . $curPos++ . "/$totalToScreen\r"; }

	my %speciesForCNS;
	for my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
		$speciesForCNS{ $mapping->{'TargetSpecies'} } =1;
	}
	my @speciesForCNSArray = keys %speciesForCNS;
	$CNSTable{$curCNS}{'SupportingSpecies'} = scalar @speciesForCNSArray;

	my @CNSConservationLevels;

	for my $curSpecies (@speciesForCNSArray) {
  	  my @classification = split '-' , $speciesClassification{$curSpecies};
    	for my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {
			$CNSConservationLevels[$curClassificationLevel]{$classification[$curClassificationLevel]}++;
    	}
   }
   
   my $CNSConservationLevel;

   	#determine for each conservation level if we are over the cut off, but don't go all the 
	# way down to family level (at -2) to avoid accidental deletion of the reference species because of 
	# unbalanced number of species in each family
   	for my $curLevel (0..($CLASSIFICATION_CLASSES_NUM-2)) {
		my %classificationForLevel = %{ $CNSConservationLevels[$curLevel] };
		my %classificationForDeeperLevel = %{ $CNSConservationLevels[$curLevel+1] };
		if (scalar keys %classificationForDeeperLevel > 1 && scalar keys %classificationForLevel == 1 && $CNSConservationLevel eq "") { ### We have potential for classification. See if we have enough species
			$CNSConservationLevel = (keys %classificationForLevel)[0];
		}
	}
	if($CNSConservationLevel eq "") {
		my @familyClassification = reverse sort { $CNSConservationLevels[$CLASSIFICATION_CLASSES_NUM-1]{$a} <=> $CNSConservationLevels[$CLASSIFICATION_CLASSES_NUM-1]{$b} } keys %{ $CNSConservationLevels[$CLASSIFICATION_CLASSES_NUM - 1] };
		$CNSConservationLevel = $familyClassification[0];
	}

  	$CNSTable{$curCNS}{'Level'} = $CNSConservationLevel;
}
if($verbose) { print "\n"; }

## Merge overlapping position hits segments
$totalToScreen = scalar (keys %CNSTable);
$curPos=1;
my $overlappingPositionMerged=0;

foreach my $curCNS (keys %CNSTable) {

	if($verbose) { print "PROGRESS: Merging overlapping positions " . $curPos++ . "/$totalToScreen. Merged $overlappingPositionMerged mappings.\r"; }
	my @newPositions;
	my @curPositions = @{ $positionTable{$curCNS}{'Positions'} };
	my %speciesMappings;
	for my $curPosition (@curPositions) {
		my $foundOverlap=0;
		for my $positionToCheckNum (0..(scalar @newPositions-1)) {
			my $positionToCheck = @newPositions[$positionToCheckNum];

			if($curPosition->{'TargetLocus'} eq $positionToCheck->{'TargetLocus'} &&
			   overlap($curPosition->{'TargetPosition'},$curPosition->{'TargetPosition'}+$curPosition->{'Length'}, $positionToCheck->{'TargetPosition'}, $positionToCheck->{'TargetPosition'} + $positionToCheck->{'Length'} )) {

				$foundOverlap=1;
				$overlappingPositionMerged++;
				my $newStart = min($curPosition->{'TargetPosition'}, $positionToCheck->{'TargetPosition'});
				my $newRefStart = min($curPosition->{'ReferenceRelativePos'},$positionToCheck->{'ReferenceRelativePos'});
				my $newLength = max($curPosition->{'TargetPosition'} + $curPosition->{'Length'}, $positionToCheck->{'TargetPosition'} + $positionToCheck->{'Length'}) - $newStart;
				my $newSeq;
				if($curPosition->{'TargetPosition'} <= $positionToCheck->{'TargetPosition'}) {
					$newSeq = substr($curPosition->{'TargetSequence'},0, ($positionToCheck->{'TargetPosition'}- $curPosition->{'TargetPosition'}) ) . $positionToCheck->{'TargetSequence'};
				} else {
					$newSeq = substr($positionToCheck->{'TargetSequence'},0, ($curPosition->{'TargetPosition'}- $positionToCheck->{'TargetPosition'}) ) . $curPosition->{'TargetSequence'};
				}
				$newPositions[$positionToCheckNum] = {
						'TargetSpecies' => $curPosition->{'TargetSpecies'},
						'TargetLocus' => $curPosition->{'TargetLocus'},
						'TargetPosition' => $newStart,
						'ReferenceRelativePos' => $newRefStart, 
						'Length' => $newLength,
						'TargetSequence' => $newSeq
					};
			}
		}
		if(!$foundOverlap) {
			push @newPositions, $curPosition;
		}
	}
	$positionTable{$curCNS}{'Positions'} = \@newPositions;
}
if($verbose) { print "\nPROGRESS: Done. Output files.\n"; }

########### Output files
### New CNS files
open (my $outputCNSFile, ">$outputCNSFileName") || die ("INTERNAL ERROR.\n");
open (my $outputMapFile, ">$outputMapFileName") || die ("INTERNAL ERROR.\n");

foreach my $curCNS (sort keys %CNSTable) {

	if(defined $positionTable{$curCNS}{'Positions'} && $CNSTable{$curCNS}{'CNSID'} eq $curCNS) {  ### The second conditions is to verify that all the CNS in the position file are found in the CNS file.
																								  ### This only occurs if we input partial data.
		if((scalar @{ $positionTable{$curCNS}{'Positions'} }) >0 ) {
			print $outputCNSFile join(",",
					$CNSTable{$curCNS}{'ReferenceGenome'},
					$CNSTable{$curCNS}{'CNSID'},
					$CNSTable{$curCNS}{'Chromosome'},
					$CNSTable{$curCNS}{'Strand'},
					$CNSTable{$curCNS}{'Start'},	
					$CNSTable{$curCNS}{'End'},
					$CNSTable{$curCNS}{'Locus'},
					$CNSTable{$curCNS}{'RelStart'},
					$CNSTable{$curCNS}{'RelEnd'},
					$CNSTable{$curCNS}{'Level'},
					$CNSTable{$curCNS}{'SupportingSpecies'},
					$CNSTable{$curCNS}{'ORFLength'},
					$CNSTable{$curCNS}{'ORFDir'},
					$CNSTable{$curCNS}{'Omega'},
					$CNSTable{$curCNS}{'AncesteralSeq'}) ."\n";
	
			foreach my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
				print $outputMapFile join(",",
					$curCNS,
					$mapping->{'TargetSpecies'},
					$mapping->{'TargetLocus'},
					$mapping->{'TargetPosition'},
					$mapping->{'ReferenceRelativePos'},
					$mapping->{'Length'},
					$mapping->{'TargetSequence'}) ."\n";		
			}
		}
	}
}

close($outputCNSFile);
close($outputMapFile);

##########

if($outputMergedCNSFileName ne "") {
	open (my $outputMergedCNSFile, ">$outputMergedCNSFileName") || die ("INTERNAL ERROR.\n");
	foreach my $groupCNS (sort keys %CNSGroups) {
		foreach my $subCNS (@{ $CNSGroups{$groupCNS} } ) {
			print $outputMergedCNSFile "$groupCNS,$subCNS\n";
		}
	}
	close ($outputMergedCNSFile);
}

print "END: Deleted $CNSDeleted duplicated CNSs; Merged $CNSMerged CNSs, of $deepCNSMerged were deep CNSs, $CNSCollated were collated. Assembled $superGroupMerged CNS groups.\n";

#############################################################################3
### Compute overlap between two fragments. 
### Parameters:
### overlap(startOne, endOne, StartTwo, endTwo, mode)
### returns relative overlap (0-1).
###

sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		return (min($endOne, $endTwo) - max($startOne, $startTwo))/ max( $endOne-$startOne, $endTwo-$startTwo);
	}
}

