#!/usr/bin/perl
use strict;
use POSIX;
use threads;
use Thread::Semaphore;
use Cwd 'abs_path';

use Array::Utils qw(:all);

use List::Util qw(min max uniq);
use Set::Scalar;
use Bio::Root::Root;
use Bio::SeqIO;
use Bio::AlignIO;
use Bio::TreeIO;
use Bio::Seq;
use Bio::LocatableSeq;
use Algorithm::NeedlemanWunsch;
use Bio::SimpleAlign;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;
use Getopt::Long;

use lib './scripts';
use ConservatoryUtils;

$|=1;

### Filenames
my $conservatoryDir=abs_path(".");
my $tmpDir= "/dev/shm/";
my $CNSFileName="";
my $mapFileName="";
my $outputCNSFileName="";
my $outputMapFileName="";
my $outputMergedCNSFileName="";

my $conservatoryTreeFileName;


### Merging parameters
my $superCNSPrefix = "Super";
my $minOverlappingSpeciesForMerge=5; ### How many overlapping hits to merge a CNS
my $minCNSOverlap = 0.1;
my $minSyntenyBiasToAssignCNS= 1.1; ### Number between 1 and 2 (how many more species need to support a two-gene CNS assignment to just one of the genes, based on synteny)
my $minSupportingSpeciesToKeepMultipleCNS = 80;
my $removeOriginalCNS=0;
my $minCNSLength=8;
my $minSpeciesForCNS=6; ### The minimum number of species aligned to a CNS to keep the CNS
my $minCNSCoverageAfterSplit=0.3;
my $minCNSIdentityToMerge=70;
my $keep_tmp=0;
my $outputAnnotatedTree=0;

my $threads = 1;

## Filtering parameters
my $CLASSIFICATION_CLASSES_NUM=6;
my $minSpeciesForClassification=6; 	### Minimum absolute number of species to support a classification
my $minSequenceContentToConsiderReconstruction = 33; ## how many of the sequences in the alignment has to be informative (non-gap)
													  # for the nucleotide to be considered for ancesteral seq reconstruction. 
													  # this is to avoid reconstructing sequences based on small number of samples.

my %CNSTable;
my %positionTable;
my %genomeToSpecies;
my %genomeToFamily;
my %speciesToFamily;
my %speciesClassification;

my $CNSMerged=0;
my $CNSDeletedButMappingKept=0;
my $CNSDeleted=0;
my $deepCNSMerged=0;

my $verbose=0;
my $help=0;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"in-cns=s" => \$CNSFileName,
			"in-map=s" => \$mapFileName,
			"out-cns=s" => \$outputCNSFileName,
			"out-map=s" => \$outputMapFileName,
			"verbose" => \$verbose,
			"min-overlapping" => \$minOverlappingSpeciesForMerge,
			"min-keep-multiple" => \$minSupportingSpeciesToKeepMultipleCNS,
			"remove-original-CNS" => \$removeOriginalCNS,
			"threads=i" => \$threads,
			"keep-tmp" => \$keep_tmp,
			"annotated-tree" => \$outputAnnotatedTree,
			"help" => \$help) or die ("Error in command line arguments\n");
			
			
if($help || $CNSFileName eq "" || $mapFileName eq "" || $outputCNSFileName eq "" || $outputMapFileName eq "" ) {
	print "Conservatory version 2.0.1\n\n";
	print "mergeCNSTables --in-cns <cnsFile> --in-map <cnsPositionMapFile> --out-cns <cnsFile> --out-map <cnsPositionMapFile> [--min-overlapping <number>] [--min-keep-multiple number] [--remove-original-CNS].\n\n";
	
	exit();
}

if ($verbose) { print "START: Loading genome database.\n"; }
my $genomedbFile = $conservatoryDir . "/genome_database.csv";
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;

$conservatoryTreeFileName = $conservatoryDir . "/genomes/Conservatory.tree";
if(! -e $conservatoryTreeFileName) { print "WARNING: Cannot find conservatory tree ($conservatoryTreeFileName).\n"; $conservatoryTreeFileName=""; }
### Load the super tree
my $conservatoryTreeio = Bio::TreeIO->new(-file => $conservatoryTreeFileName, -format => 'newick');
my $conservatoryTree = $conservatoryTreeio->next_tree;
my %speciesInTree = map { ($_)->id => 1} $conservatoryTree->get_leaf_nodes();

if(!defined $conservatoryTree) { die "ERROR: Cannot read tree file $conservatoryTreeFileName. Bad format.\n"; }

open (my $genomeDatabase, "<", $genomedbFile);
while((my $curgenomeline = <$genomeDatabase>)) {
	chomp($curgenomeline);
	if(substr($curgenomeline,0,1) ne "#")  {
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$genomeToSpecies{$curgenomeName}=  $curgenomeSpecies;
		$genomeToFamily{$curgenomeName} = $curgenomeFamily;
		$speciesToFamily{$curgenomeSpecies} = $curgenomeFamily;
		$speciesClassification{$curgenomeSpecies} = $classification;
	}
}

if ($verbose) { print "END: Loading genome database.\n"; }

my $positionLineCount = (qx(wc -l $mapFileName))[0];
chomp ($positionLineCount);
my $curPos=1;

########## Load position table to memory
open (my $CNSPositionFile, $mapFileName) ||  die "ERROR: Cannot find position file $mapFileName.\n";
while(<$CNSPositionFile>) {
	if($verbose) { print "PROGRESS: Loading mappings..." . $curPos++ . "/$positionLineCount\r" };
	chomp;
	my ($CNSID, $targetSpecies, $targetLocus, $targetRelativePosition, $targetStrand, $referenceRelativePosition, $length, $targetSequence) = split /,/;
	
	### Filter for only embryophyta hits
	my @classification = split /-/, $speciesClassification{ $targetSpecies }; 

	## Only if non-filtered CNS
	if(!defined $positionTable{$CNSID}) {
		$positionTable{$CNSID} = {
					'CNSID' => $CNSID,
					'Positions' => () };
	}

	push( @{ $positionTable{$CNSID}{'Positions'} } , {
				'TargetSpecies' => $targetSpecies,
				'TargetLocus' => $targetLocus,
				'TargetPosition' => $targetRelativePosition,
				'TargetStrand' => $targetStrand,
				'ReferenceRelativePosition' => $referenceRelativePosition,
				'Length' => $length,
				'TargetSequence' => $targetSequence} );		
}
close($CNSPositionFile);
if($verbose) { print "\n"; };

### Start merging CNSs. First read and merge all CNSs in the family

open (my $CNSInputFile,"sort -t',' -k1,1 -k3,3 -k5,5n $CNSFileName |") ||  die "ERROR: Cannot find CNS file $CNSFileName.\n";
$curPos=1;
my $CNSLineCount= (qx(wc -l $CNSFileName))[0];
chomp($CNSLineCount);
my $lastCNS ="";
my %CNSTable;
while(<$CNSInputFile>) {
	if($verbose) { print "PROGRESS: Merging family CNS... " . $curPos++ . "/$CNSLineCount. Merged $CNSMerged.\r" };
	chomp;
	my ($referenceGenome, $CNSID, $chromosome, $strand, $start, $end, $locus, $relStart, $relEnd, $level, $supportingSpecies, $orfLength, $orfDir, $omega, $ancesteralSeq) = split /,/;

	if(!defined $positionTable{$CNSID} ) { next; }
	
	my $regulatorySeqPart;
	if($relStart<0) {
		$regulatorySeqPart = "Upstream";
	} else {
		$regulatorySeqPart = "Downstream";
	}
	$CNSTable{$CNSID} = {
				'ReferenceGenome' => $referenceGenome,
				'CNSID' => $CNSID,
				'Chromosome' => $chromosome,
				'Strand' => $strand,
				'Start' => $start,	
				'End' => $end,
				'Locus' => $locus,
				'RelStart' => $relStart,
				'RelEnd' => $relEnd,
				'Level' => $level,
				'SupportingSpecies' => $supportingSpecies,
				'ORFLength' => $orfLength,
				'ORFDir' => $orfDir,
				'Omega' => $omega,
				'AncesteralSeq' => $ancesteralSeq,
				'RegulatorySeqPart' => $regulatorySeqPart
	};
	
	if($lastCNS eq "") {
		$lastCNS = $CNSID;
	} else {
		### If this CNS overlap with last, pick one gene to associate it with (or merge)
		###
		my $CNSToDelete= "";
		if($CNSTable{$lastCNS}{'ReferenceGenome'} eq $referenceGenome && 
			$CNSTable{$lastCNS}{'Chromosome'} eq $chromosome && 
			overlap($CNSTable{$lastCNS}{'Start'},$CNSTable{$lastCNS}{'End'}, $start, $end)) {

				## Prefer the CNS with the most conserved synteny (largest number of supporting species for CNS-Gene synteny)
				if($CNSTable{$lastCNS}{'SupportingSpecies'} > $CNSTable{$CNSID}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $CNSID;
					$CNSDeleted++;
				} elsif($CNSTable{$CNSID}{'SupportingSpecies'} > $CNSTable{$lastCNS}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $lastCNS;
					$CNSDeleted++;
				} else {   ### If both CNSs have the same number of supporting species, we have to decide:
						### If the genes are same orientation and the CNS is in the same part of the regulatory sequence (Up/downstream)
						###  then associate with the closest gene.
						if( ($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Upstream") &&
							($CNSTable{$lastCNS}{'Strand'} eq $strand)) {    #### If both upstream. delete the one further away
							if($relEnd > $CNSTable{$lastCNS}{'RelEnd'}) {
								$CNSToDelete = $lastCNS;
							}
							else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Downstream") &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {  ### If both downstream, delete the one further away
							if($relStart < $CNSTable{$lastCNS}{'RelStart'}) {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} ne $regulatorySeqPart)  &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {   ### If one is upsteam, one downstream on opposite strands, delete the downstream (we assume upstream more likely)
							if($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Downstream") {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif( $CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Merged" ) {   #### If CNS hits a CNS that was already merged, just delete it
						$CNSToDelete = $CNSID;
						$CNSDeleted++;
					} else { ### If orientation is different then merge into one CNS.
						my $diffInCNSPos = $start-$CNSTable{$lastCNS}{'Start'};

						### Pick the longest one
						my $longestSeq;
						my $longestSeqCNS;
						if( ($CNSTable{$CNSID}{'End'} - $CNSTable{$CNSID}{'Start'}) > ($CNSTable{$lastCNS}{'End'} - $CNSTable{$lastCNS}{'Start'}) ) {
							$longestSeq = $CNSTable{$CNSID}{'AncesteralSeq'};
							$longestSeqCNS = $CNSID;
						} else {
							$longestSeq = $CNSTable{$lastCNS}{'AncesteralSeq'};
							$longestSeqCNS = $lastCNS;
						}
						## Update all the positions

						### If there is a mismatch of the stands between the merged CNS, reverse complement the mismatched one
						if($CNSTable{$CNSID}{'Strand'} ne $CNSTable{$lastCNS}{'Strand'} && $longestSeqCNS eq $CNSID) {

							my @lastCNSMappings = @{ $positionTable{$lastCNS}{'Positions'} };
							$positionTable{$lastCNS}{'Positions'} = ();

							foreach my $mapping (@lastCNSMappings) {
								my $seq = $mapping->{'TargetSequence'};
								$seq = reverse $seq;
                                $seq =~ tr/ACGT/TGCA/;
								$mapping->{'TargetSequence'} = $seq;
								my %newmapping = %$mapping;
								push( @{ $positionTable{$lastCNS}{'Positions'} }, \%newmapping);
							}
						}
						
						my @CNSMappings = @{ $positionTable{$CNSID}{'Positions'} };

						foreach my $mapping (@CNSMappings) {

							$mapping->{'PosInCNS'} = $mapping->{'PosInCNS'} + $diffInCNSPos;
							# If we changed the direction, we should reverse the sequence
							if($CNSTable{$CNSID}{'Strand'} ne $CNSTable{$lastCNS}{'Strand'} && $longestSeqCNS eq $lastCNS) {
								my $seq = $mapping->{'TargetSequence'};
								$seq = reverse $seq;
                                $seq =~ tr/ACGT/TGCA/;
								$mapping->{'TargetSequence'} = $seq;
							}
							my %newmapping = %$mapping;
							push( @{ $positionTable{$lastCNS}{'Positions'} } , \%newmapping);
						}

						### Merge CNS rel position
						$CNSTable{$lastCNS}{'RegulatorySeqPart'}="Merged";
						$CNSTable{$lastCNS}{'AncesteralSeq'} = $longestSeq;

						# and remove the old CNS
						$CNSToDelete = $CNSID;
						$CNSMerged++;
				}
			}
		} else {
			$lastCNS = $CNSID;
		}

		if($CNSToDelete ne "") {
			### Delete the CNS. 
			### One exception. If this is a deeply conserved CNS, maintain a link to the other genes.
			if($CNSTable{$CNSToDelete}{'SupportingSpecies'} > $minSupportingSpeciesToKeepMultipleCNS) {
				$CNSDeletedButMappingKept++;
				my $CNSToCopyTo = $lastCNS;
				if($CNSToDelete eq $lastCNS) { $CNSToCopyTo = $CNSID; }
			
				my @CNSMappingsToCopy = @{ $positionTable{$CNSToDelete}{'Positions'} };
				my @CNSMappingsInTargetCNS = @{ $positionTable{$CNSToCopyTo}{'Positions'} };

				foreach my $mapping (@CNSMappingsToCopy) {
					my %newmapping = %$mapping;
					my $mappingAlreadyExists=0;
					## Search to see that we don't already if we already have that mapping
					foreach my $mappingInCNS (@CNSMappingsInTargetCNS) {
						if($newmapping{'TargetLocus'} eq $mappingInCNS->{'TargetLocus'} && $newmapping{'TargetPosition'} eq $mappingInCNS->{'TargetPosition'}) {
							$mappingAlreadyExists=1;
							next;
						}
					}
					if($mappingAlreadyExists) {
						push( @{ $positionTable{$CNSToCopyTo}{'Positions'} } , \%newmapping );
					}
				}
			}

			delete $positionTable{$CNSToDelete};
			delete $CNSTable{$CNSToDelete};
			if($CNSToDelete eq $lastCNS) { $lastCNS=$CNSID; }
		}
	}
}

close($CNSInputFile);
if($verbose) { print "\n"; }

#######################################################################################
###### Go to the deeper merge - merge across different references

### First, build a map of hits indexed by gene

my %positionLocusMap;
my $totalToScreen = scalar (keys %positionTable);
$curPos=1;

foreach my $curCNS (keys %positionTable) {
	if($verbose) { print "PROGRESS: Building CNS Map..." . $curPos++. "/$totalToScreen\r"; };
	foreach my $curHit (@{ $positionTable{$curCNS}{'Positions'} }) {
		if(!defined $positionLocusMap{ $curHit->{'TargetLocus'} }) {
			$positionLocusMap{ $curHit->{'TargetLocus'} } = {
					'Positions' => () };
		 }
		 push( @{ $positionLocusMap{ $curHit->{'TargetLocus'} }{'Positions'} } , {
				'TargetSpecies' => $curHit->{'TargetSpecies'},
				'TargetLocus' => $curHit->{'TargetLocus'},
				'TargetStrand' => $curHit->{'TargetStrand'},
				'CNSID' => $curCNS,
				'TargetPosition' => $curHit->{'TargetPosition'} ,
				'ReferenceRelativePosition' => $curHit->{'ReferenceRelativePosition'},
				'Length' => $curHit->{'Length'},
				'TargetSequence' => $curHit->{'TargetSequence'} } );			
		}	
}

if($verbose) { print "\n" };


### Identify CNS to merge
my %CNSToMergeMap;
my %CNSToMergeHitMap;

### Scan all the hits to the locus. See if an alignment is hitting Two CNSs. If so, merge them.
$totalToScreen = scalar (keys %positionLocusMap);
$curPos=1;

foreach my $curLocus (keys %positionLocusMap) {
	
	if($verbose) { print "PROGRESS: Identifying deep CNS to merge..." . ($curPos++) . "/$totalToScreen.\r"; }
	
	foreach my $firstHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
		foreach my $secondHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {

			if(($firstHit->{'CNSID'} ne $secondHit->{'CNSID'}) && ($CNSTable{ $firstHit->{'CNSID'} }{'ReferenceGenome'} ne $CNSTable{ $secondHit->{'CNSID'} }{'ReferenceGenome'}) &&
			   ($CNSTable{ $firstHit->{'CNSID'} }{'RegulatorySeqPart'} eq $CNSTable{ $secondHit->{'CNSID'} }{'RegulatorySeqPart'}) ) {

				if(overlap($firstHit->{'TargetPosition'}, $firstHit->{'TargetPosition'}+$firstHit->{'Length'}, $secondHit->{'TargetPosition'}, $secondHit->{'TargetPosition'}+$secondHit->{'Length'}) > $minCNSOverlap ) {

					## Record the merging species
					if(!defined $CNSToMergeMap{ $firstHit->{'CNSID'} }{ $secondHit->{'CNSID'} }{ $firstHit->{'TargetSpecies'} } ) {
						$CNSToMergeMap{ $firstHit->{'CNSID'} }{ $secondHit->{'CNSID'} }{ $firstHit->{'TargetSpecies'} } = 1;
						$CNSToMergeMap{ $secondHit->{'CNSID'} }{ $firstHit->{'CNSID'} }{ $firstHit->{'TargetSpecies'} } = 1;
					}
				}
			}
		}
	}
}
if($verbose) {print "\n";}

my $deletedForLowSupport=0;

### Filter CNS merge events with too few hits

foreach my $curCNSA (keys %CNSToMergeMap) {
	foreach my $curCNSB (keys %{ $CNSToMergeMap{$curCNSA} }) {
		if( scalar keys %{ $CNSToMergeMap{$curCNSA}{$curCNSB} } < $minOverlappingSpeciesForMerge) {
			delete $CNSToMergeMap{$curCNSA}{$curCNSB};
			delete $CNSToMergeMap{$curCNSB}{$curCNSA};
			if((scalar keys %{ $CNSToMergeMap{$curCNSA} }) ==0) { delete $CNSToMergeMap{$curCNSA}; }
			if((scalar keys %{ $CNSToMergeMap{$curCNSB} }) ==0) { delete $CNSToMergeMap{$curCNSB}; }
			$deletedForLowSupport++;
		}
	}
}

if($verbose) { print "PROGRESS: Removed $deletedForLowSupport CNS merge events for low support.\n"; }

### Release memory
undef (%positionLocusMap);

### Convert Merge table to number of supporting species. Filter out CNS hits that have low identity scores following alignment to avoid merger of CNS that have diverged too far
$totalToScreen = scalar keys %CNSToMergeMap;
$curPos=1;
my $deletedForLowIdentity=0;

#### Filter CNS merge events with low sequence similarity (too divergent)

for my $curCNSA (keys %CNSToMergeMap ) {
	if($verbose) { print "PROGRESS: Merging overlapping CNS hits and filtering divergent sequences..." . $curPos++ . "/$totalToScreen. Removed $deletedForLowIdentity CNS merge events.\r"; }
	for my $curCNSB (keys %{ $CNSToMergeMap{$curCNSA}}) {

		## Check to see if we have enough similarity between the ancesteral CNSs

		sub score_sub {
			  if (!@_) {  return -0.5;  }  ## gap penalty
  				## mismatch scores -1, match +1
  				return ($_[0] eq $_[1]) ? 1 : -1;
		}
		my $nw = Algorithm::NeedlemanWunsch->new(\&score_sub);
		$nw->gap_open_penalty(-5);
		$nw->gap_extend_penalty(-0.25);

		my $seq1Arr = [split//, $CNSTable{$curCNSA}{'AncesteralSeq'}];
		my $seq2Arr = [split//, $CNSTable{$curCNSB}{'AncesteralSeq'}];
		my (@align1, @align2);

		$nw->align($seq1Arr,$seq2Arr,
		   {
   				align   => sub {unshift @align1, $seq1Arr->[shift]; unshift @align2, $seq2Arr->[shift];},
   				shift_a => sub {unshift @align1, $seq1Arr->[shift]; unshift @align2,            '-'},
   				shift_b => sub {unshift @align1,               '-'; unshift @align2, $seq2Arr->[shift]},
  			});
		my $pairwise = Bio::SimpleAlign->new();
		$pairwise->add_seq(Bio::LocatableSeq->new( -seq => join("",@align1), -id=> "seq1", -start=>0, -end=> scalar @align1));
		$pairwise->add_seq(Bio::LocatableSeq->new( -seq => join("",@align2), -id=> "seq2", -start=>0, -end=> scalar @align2));
		if($pairwise->percentage_identity() < $minCNSIdentityToMerge) {
			delete $CNSToMergeMap{$curCNSA}{$curCNSB};
			delete $CNSToMergeMap{$curCNSB}{$curCNSA};
			$deletedForLowIdentity++;
		}
	}
	if((scalar (keys %{ $CNSToMergeMap{$curCNSA} })) ==0) { delete $CNSToMergeMap{$curCNSA}; }	
}
if($verbose) { print "\n";}

### Collate CNSs into group. The first one is the anchor CNS and is the key for the superGroup hash

my %superGroups;
my %alreadyProcessedCNSs;

my $CNSCollated;
$totalToScreen = scalar (keys %CNSToMergeMap);
$curPos=1;

for my $curCNSToCollate (keys %CNSToMergeMap) {
	if($verbose) { print "PROGRESS: Collating CNS..." . $curPos++ . "/$totalToScreen. Found $CNSCollated that can be collated.\r"; }

	if(!defined $alreadyProcessedCNSs{$curCNSToCollate}) {
		my $collated = collateCNS($curCNSToCollate, \%CNSToMergeMap);
		$alreadyProcessedCNSs{$curCNSToCollate} = 1;
		$superGroups{$curCNSToCollate}{$curCNSToCollate} = 1;
		foreach my $curKeyToCopy ( keys %{ $collated->{'CollatedCNSs'} } ) { $alreadyProcessedCNSs{$curKeyToCopy} =1; $superGroups{$curCNSToCollate}{$curKeyToCopy}=1; }
		$CNSCollated++;
	}
}

if($verbose) { print("\n"); }

### Merge merged CNS
my $superGroupMerged=0;

$totalToScreen = scalar (keys %superGroups);
$curPos=1;
my %CNSGroups;

foreach my $anchorCNS (keys %superGroups) {

	if($verbose) { print "PROGRESS: Forming super CNS groups...". $curPos++ . "/$totalToScreen.\r"; }
	my %CNSsInGroup = %{ $superGroups{$anchorCNS} };

	$deepCNSMerged = $deepCNSMerged + (scalar keys %CNSsInGroup);
	$CNSMerged = $CNSMerged + (scalar keys %CNSsInGroup);

	my @positionConcats;

	for my $curCNS (keys %CNSsInGroup) {
		my @positions = @{ $positionTable{$curCNS}{'Positions'} };
		for my $curPos (@positions) {
			push @positionConcats, $curPos;
		}
	}
	### Merge overlapping position
	my @mergedPositions = mergeOverlappingTargetsForCNS(\@positionConcats);

	## Assemble sequences

	#### build FASTA file for alignment
	my $tmpOutputSuperCNSFastaFileName = $tmpDir . "/tmp_$anchorCNS.fasta";
	my $tmpOutputSuperCNSFastaAlignedFileName = $tmpDir . "/tmp_$anchorCNS.aligned.fasta";
	open(my $tmpOutputSuperCNSFastaFile, ">" , $tmpOutputSuperCNSFastaFileName);

	foreach my $curPos (@mergedPositions) {
		print $tmpOutputSuperCNSFastaFile ">" . $curPos->{'TargetLocus'} . ":" . $curPos->{'TargetPosition'} . ":" . $curPos->{'TargetStrand'} . "\n" . $curPos->{'TargetSequence'} . "\n";
	}

	close($tmpOutputSuperCNSFastaFile);

	## Align using MAFFT
	system("mafft --quiet --thread $threads $tmpOutputSuperCNSFastaFileName > $tmpOutputSuperCNSFastaAlignedFileName ");

	my $alignedCNSFile = Bio::AlignIO->new(-file => $tmpOutputSuperCNSFastaAlignedFileName,
										-format => "fasta");
	my $superCNSAlignment = $alignedCNSFile->next_aln;

	### Set up the super CNS
	my $CNSGroupName = "$superCNSPrefix.$anchorCNS";

	$CNSTable{$CNSGroupName} = {
			'ReferenceGenome' => "SuperCNS",
			'CNSID' => $CNSGroupName,
			'Chromosome' => "",
			'Strand' => "",
			'Start' => 0,	
			'End' => $superCNSAlignment->length,
			'Locus' => "",
			'RelStart' => "",
			'RelEnd' => "",
			'Level' => "",
			'SupportingSpecies' => 0,
			'ORFLength' => "",
			'ORFDir' => "",
			'Omega' => "",
			'AncesteralSeq' => $superCNSAlignment->consensus_string(50),
			'RegulatorySeqPart' => ""};
	$positionTable{$CNSGroupName}{'Positions'} = ();

	### Map the alignments to the super CNS
	foreach my $curCNSposition ($superCNSAlignment->each_seq) {
		my ($targetLocus,$targetPosition,$targetStrand) = split /:/, $curCNSposition->id;
		my ($targetSpecies) = split /-/, $targetLocus;
		my $sequence = uc($curCNSposition->seq);
		my ($leadingDashes) = $sequence =~ /^(-+)/;
		my $positionInCNS = length($leadingDashes);  ## The start position in the CNS is the number of leading dashes
		if($positionInCNS eq "") { $positionInCNS = 0; }

		### Clear leading and trailing gaps
		$sequence =~ s/^(-+)//;
		$sequence =~ s/(-+)$//;

		push ( @{ $positionTable{$CNSGroupName}{'Positions'} } , {
			'TargetSpecies' => $targetSpecies,
			'TargetLocus' => $targetLocus,
			'TargetPosition' => $targetPosition,
			'TargetStrand' => $targetStrand,
			'ReferenceRelativePosition' => $positionInCNS,
			'Length' => length($sequence),
			'TargetSequence' => $sequence } );
	}

	$CNSGroups{$CNSGroupName} = 1;
	if($removeOriginalCNS) {
		foreach my $curCNS (keys %CNSsInGroup) {
			delete $CNSTable{$curCNS};
			delete $positionTable{$curCNS};
			delete $CNSToMergeMap{$curCNS};
		}
	}
	unlink($tmpOutputSuperCNSFastaFileName);
	unlink($tmpOutputSuperCNSFastaAlignedFileName);	
} 

if($verbose) { print "\n";}

## Merge overlapping position hits segments
$totalToScreen = scalar (keys %CNSTable);
$curPos=1;
my $overlappingPositionMerged=0;

### Split the merged CNSs

foreach my $curCNS (keys %CNSGroups) {
	### See if we can split it
	my @CNShits = @{ $positionTable{$curCNS}{'Positions'}};

	my $CNSBreakpointsRef = getCNSbreakpoints($CNSTable{$curCNS}{'End'}, \@CNShits , $minCNSLength);
	my @CNSBreakpoints = @$CNSBreakpointsRef;

	if(@CNSBreakpoints > 2) {
		if($verbose) { print "PROGRESS: Breaking CNS $curCNS. Breakpoints: " . join(",", @CNSBreakpoints) . "\n"; }

		my $polishedAlignmentsRef = polishCNSAlignments(\@CNSBreakpoints, \@CNShits, $minCNSCoverageAfterSplit, $minCNSLength);
		my @polishedAlignments = @$polishedAlignmentsRef;

		for my $curBreakpoint (0.. ((scalar @CNSBreakpoints) - 2)) {
			### Create a new sub-CNS
			my $newSubCNSName = "$curCNS.$CNSBreakpoints[$curBreakpoint]";

			## Build the CNS
			$CNSTable{$newSubCNSName} = {
				'ReferenceGenome' => "SuperCNS",
				'CNSID' => $newSubCNSName,
				'Chromosome' => "",
				'Strand' => "",
				'Start' => $CNSBreakpoints[$curBreakpoint],
				'End' => $CNSBreakpoints[$curBreakpoint+1]-1,			
				'Locus' => $curCNS,
				'RelStart' => "",
				'RelEnd' => "",
				'Level' => "",
				'SupportingSpecies' => 0,
				'ORFLength' => "",
				'ORFDir' => "",
				'Omega' => "",
				'AncesteralSeq' =>"",
				'RegulatorySeqPart' => ""};
			
			$positionTable{$newSubCNSName}{'Positions'} = ();
			$CNSGroups{$newSubCNSName} =1;

			## Reassign deep alignments
			foreach my $curHit (@polishedAlignments) {
				### If there is an overlap, assign the deep CNS to the new subCNS.
				if(overlap($CNSTable{$newSubCNSName}{'Start'}, $CNSTable{$newSubCNSName}{'End'},
						   $curHit->{'ReferenceRelativePosition'}, $curHit->{'ReferenceRelativePosition'} + $curHit->{'Length'})>$minCNSCoverageAfterSplit) {

					push @{ $positionTable{$newSubCNSName}{ 'Positions' } }, {
							'ReferenceLocus' => $newSubCNSName,
							'ReferenceRelativePosition' => $curHit->{'ReferenceRelativePosition'} - $CNSTable{$newSubCNSName}{'Start'} ,
							'ReferenceUpDown' => $curHit->{'ReferenceUpDown'},
							'Length' => $curHit->{'Length'},
							'TargetSpecies' => $curHit->{'TargetSpecies'},
							'TargetLocus' => $curHit->{'TargetLocus'},
							'TargetStrand' => $curHit->{'TargetStrand'},
							'TargetSequence' => $curHit->{'TargetSequence'},
							'TargetPosition' => $curHit->{'TargetPosition'} }; 
				}
			}

		}
		### Finally, delete the original CNS
		delete $CNSTable{$curCNS};
		delete $positionTable{$curCNS};
		delete $CNSGroups{$curCNS};
	}
}


### Reconstruct sequences of Super CNS and determine conservation level

my $origConservatoryTree = $conservatoryTree->clone();

### Annotated Internal nodes
my $curNodeNumber=1;
my @nodes = $conservatoryTree->get_nodes();
foreach my $curNode (@nodes) {
	if($curNode->id eq "") { 
		$curNode->id("N$curNodeNumber");
		$curNodeNumber++;
	}
}

#my $conservatoryTreeOutput = Bio::TreeIO->new(-file => ">AnnotatedTree.tree", -format => 'newick');
#$conservatoryTreeOutput->write_tree($conservatoryTree);

#my $totalToScreen = scalar (keys %CNSTable);
#$curPos=1;

#foreach my $cnsToReconstruct (keys %CNSTable) {

#	if($verbose) { print "PROGRESS: Counting sequences..." . $curPos++ . "/$totalToScreen\r"; }	

#	my %speciesForCNS = getSpeciesForCNS($cnsToReconstruct, \%positionTable);
#	$CNSTable{$cnsToReconstruct}{'SupportingSpecies'} = scalar (keys %speciesForCNS);

#	if($CNSTable{$cnsToReconstruct}{'SupportingSpecies'} < $minSpeciesForCNS ) { 
#		delete $CNSTable{$cnsToReconstruct};
#		delete $positionTable{$cnsToReconstruct};
#	}
#}

if($verbose) { print "\n"; }

if($verbose) { print "\nPROGRESS: Done. Output files.\n"; }

########### Output files
### New CNS files
open (my $outputCNSFile, ">$outputCNSFileName") || die ("INTERNAL ERROR.\n");
open (my $outputMapFile, ">$outputMapFileName") || die ("INTERNAL ERROR.\n");

foreach my $curCNS (sort keys %CNSTable) {

	if(defined $positionTable{$curCNS}{'Positions'} && $CNSTable{$curCNS}{'CNSID'} eq $curCNS) {  ### The second conditions is to verify that all the CNS in the position file are found in the CNS file.
																								  ### This only occurs if we partial files in our input
		if((scalar @{ $positionTable{$curCNS}{'Positions'} }) >0 ) {
			print $outputCNSFile join(",",
					$CNSTable{$curCNS}{'ReferenceGenome'},
					$CNSTable{$curCNS}{'CNSID'},
					$CNSTable{$curCNS}{'Chromosome'},
					$CNSTable{$curCNS}{'Strand'},
					$CNSTable{$curCNS}{'Start'},	
					$CNSTable{$curCNS}{'End'},
					$CNSTable{$curCNS}{'Locus'},
					$CNSTable{$curCNS}{'RelStart'},
					$CNSTable{$curCNS}{'RelEnd'},
					$CNSTable{$curCNS}{'Level'},
					$CNSTable{$curCNS}{'SupportingSpecies'},
					$CNSTable{$curCNS}{'ORFLength'},
					$CNSTable{$curCNS}{'ORFDir'},
					$CNSTable{$curCNS}{'Omega'},
					$CNSTable{$curCNS}{'AncesteralSeq'}) ."\n";
	
			foreach my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
				print $outputMapFile join(",",
					$curCNS,
					$mapping->{'TargetSpecies'},
					$mapping->{'TargetLocus'},
					$mapping->{'TargetPosition'},
					$mapping->{'TargetStrand'},					
					$mapping->{'ReferenceRelativePosition'},
					$mapping->{'Length'},
					$mapping->{'TargetSequence'}) ."\n";		
			}
		}
	}
}

close($outputCNSFile);
close($outputMapFile);

##########

print "END: Deleted $CNSDeleted duplicated CNSs, of which $CNSDeletedButMappingKept mapping kept; Merged $CNSMerged CNSs, of which " . $deepCNSMerged . " were deep CNSs, collated into $CNSCollated grouped CNSs.\n";


#########################################################################################################
#### Recurive function to identify all overlapping CNSs
#### format: collateCNS(<Name of CNS>, <hash of CNS-CNS overlaps>, <list of overlapping CNS>)
####
####   usage:
####   my $overlappingCNSs = collateCNS($CNS, $CNSMergeMap)
####
sub collateCNS {
	my ($cnsName, $map, $collatedCNSObject) = @_;
	my %collatedCNSs;  ## This is the list of CNSs that make up this superCNS
	if(defined $collatedCNSObject) {
		%collatedCNSs = %{ $collatedCNSObject->{'CollatedCNSs'} };
	} 	$collatedCNSs{$cnsName} =1;

	my @CNSsToScan = keys %{ $map->{$cnsName} };
	foreach my $curCNSToScan (@CNSsToScan) {
		### If we didn't scan this CNS already
		if(!defined %collatedCNSs{$curCNSToScan}) {
			my $scanResults = collateCNS($curCNSToScan, $map, { "CollatedCNSs" => \%collatedCNSs});
			## and copy scan results to main hash
			foreach my $curCNSToCopy (keys %{ $scanResults->{'CollatedCNSs'}}) { $collatedCNSs{$curCNSToCopy} =1;}
		}
	}
	foreach my $curCNSToScan (@CNSsToScan) { $collatedCNSs{$curCNSToScan} = 1; }
	
	return { "CollatedCNSs" => \%collatedCNSs };
}

#########################################################################################################
### 
###  format: mergeOverlappingTargetsForCNS(\@positionMap)
###

sub mergeOverlappingTargetsForCNS {
	my ($positionMapRef) = @_;
	my @positionMap = @$positionMapRef;
	my @positionMapMerged;

	my @positionMapSortedByGene = sort { $a->{'TargetLocus'} cmp $b->{'TargetLocus'} } @positionMap;
	my $curLocus = $positionMapSortedByGene[0]->{'TargetLocus'};
	my @positionMapForLocus=();

	foreach my $curPositionForGene (@positionMapSortedByGene) {
		if($curPositionForGene->{'TargetLocus'} eq $curLocus) {
			push @positionMapForLocus, $curPositionForGene;
		} else {
			## Sort the positions
			my @positionMapSorted = sort { $a->{'TargetPosition'} <=> $b->{'TargetPosition'} } @positionMapForLocus;

			my $curPosition = $positionMapSorted[0];
			foreach my $nextPosition (@positionMapSorted) {
				#print $curPosition->{'TargetLocus'} . ":" . $curPosition->{'TargetPosition'} . ":" . $curPosition->{'Length'} . " with " . $nextPosition->{'TargetPosition'} . ":" . $nextPosition->{'Length'} . "\n";
				if(overlap($curPosition->{'TargetPosition'},$curPosition->{'TargetPosition'} + $curPosition->{'Length'},
					   	$nextPosition->{'TargetPosition'}, $nextPosition->{'TargetPosition'} + $nextPosition->{'Length'})) {
					### merge the two positions
					### Set up the merged sequence string background
					my $combinedSequence = '-' x (max($curPosition->{'TargetPosition'} + $curPosition->{'Length'}, $nextPosition->{'TargetPosition'} + $nextPosition->{'Length'} ) - $curPosition->{'TargetPosition'});
					substr($combinedSequence,0, $curPosition->{'Length'}) = $curPosition->{'TargetSequence'};
					substr($combinedSequence,$nextPosition->{'TargetPosition'} - $curPosition->{'TargetPosition'}, $nextPosition->{'Length'}) = $nextPosition->{'TargetSequence'};
					$curPosition->{'TargetSequence'} = $combinedSequence;
					### 
					$curPosition->{'Length'} = length($curPosition->{'TargetSequence'});

	   			} else {
					my %newPosition = %$curPosition;
					push @positionMapMerged, \%newPosition;
					$curPosition = $nextPosition;
		   		}
			}
			push @positionMapMerged, $curPosition;
			$curLocus = $curPositionForGene->{'TargetLocus'};
			@positionMapForLocus = ($curPositionForGene);
		}
	}

	return @positionMapMerged;
}


sub getSpeciesForCNS{
	my ($CNSName, $positionTableRef) = @_;
	my %species;

	foreach my $curPosInCNS (@{ $positionTableRef->{$CNSName}{'Positions'}}) {
		$species{$curPosInCNS->{'TargetSpecies'} } = 1;
	}
	return %species;
}

