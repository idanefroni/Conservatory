#!/usr/bin/perl

use POSIX;
use strict;
use Cwd 'abs_path';
use List::Util qw(min max);
use Bio::AlignIO;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;
use Getopt::Long;
$|=1;

my $conservatoryDir=abs_path(".");
my $CNSFileName="";
my $mapFileName="";
my $outputCNSFileName="";
my $outputMapFileName="";
my $outputMergedCNSFileName="";
my $superCNSPrefix = "Super";

my $verbose=0;
my $help=0;
my $minOverlappingSpeciesForMerge=5; ### How many overlapping hits to merge a CNS
my $removeOriginalCNS=0;

my %conservationLevelDic = ( "Family" => 0,
						     "Level1" => 1,
						     "Level2" => 2,
						     "Level3" => 3,
						     "Level4" => 4,						     
						     "Level5" => 5,
   					  	     "Level6" => 6);						     
my %CNSTable;
my %positionTable;
my $CNSMerged=0;
my $CNSDeleted=0;
my $deepCNSMerged=0;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"in-cns=s" => \$CNSFileName,
			"in-map=s" => \$mapFileName,
			"out-cns=s" => \$outputCNSFileName,
			"out-map=s" => \$outputMapFileName,
			"out-merged=s" => \$outputMergedCNSFileName,
			"verbose" => \$verbose,
			"min-overlapping" => \$minOverlappingSpeciesForMerge,
			"remove-original-CNS" => \$removeOriginalCNS,
			"help" => \$help) or die ("Error in command line arguments\n");
			
			
if($help || $CNSFileName eq "" || $mapFileName eq "" || $outputCNSFileName eq "" || $outputMapFileName eq "" ) {
	print "Conservatory version 2.0.1\n\n";
	print "mergeCNSTables --in-cns <cnsFile> --in-map <cnsPositionMapFile> --out-cns <cnsFile> --out-map <cnsPositionMapFile>  [--out-merged <mergedDeepCNSfile>] [--min-overlapping <number>] [--remove-original-CNS].\n\n";
	
#	print "\t\tmerged.cns.table.csv\t\tMerged CNS file\n\t\tmerged.cns.position.table.csv\t\tMerged position file\n";
	exit();
}

if ($verbose) { print "START: Merging CNSs.\n"; }

if($verbose) { print "PROGRESS: Loading mappings...\n" };

########## Load position table to memory
open (my $CNSPositionFile, $mapFileName) ||  die "ERROR: Cannot find position file $mapFileName.\n";
while(<$CNSPositionFile>) {
	chomp;
	my ($CNSID, $targetGenome, $targetLocus, $targetRelativePosition, $referenceRelativePosition, $length) = split /,/;
	## Only if non-filtered CNS
	if(!defined $positionTable{$CNSID}) {
		$positionTable{$CNSID} = {
					'CNSID' => $CNSID,
					'Positions' => () };
	}

	push( @{ $positionTable{$CNSID}{'Positions'} } , {
				'TargetGenome' => $targetGenome,
				'TargetLocus' => $targetLocus,
				'TargetPosition' => $targetRelativePosition,
				'ReferenceRelativePos' => $referenceRelativePosition,
				'Length' => $length} );			
}
close($CNSPositionFile);


### Now start merging CNSs. First read and merge all CNSs in the family
if($verbose) { print "PROGRESS: Begin merge family CNS.\n" };

open (my $CNSInputFile,"sort -t',' -k1,1 -k3,3 -k5,5n $CNSFileName |") ||  die "ERROR: Cannot find CNS file $CNSFileName.\n";

my $lastCNS ="";
my %CNSTable;
while(<$CNSInputFile>) {
	chomp;
	my ($referenceGenome, $CNSID, $chromosome, $strand, $start, $end, $locus, $relStart, $relEnd, $level, $supportingSpecies, $orfLength, $orfDir, $omega, $ancesteralSeq) = split /,/;
	my $regulatorySeqPart;
	if($relStart<0) {
		$regulatorySeqPart = "Upstream";
	} else {
		$regulatorySeqPart = "Downstream";
	}
	$CNSTable{$CNSID} = {
				'ReferenceGenome' => $referenceGenome,
				'CNSID' => $CNSID,
				'Chromosome' => $chromosome,
				'Strand' => $strand,
				'Start' => $start,	
				'End' => $end,
				'Locus' => $locus,
				'RelStart' => $relStart,
				'RelEnd' => $relEnd,
				'Level' => $level,
				'SupportingSpecies' => $supportingSpecies,
				'ORFLength' => $orfLength,
				'ORFDir' => $orfDir,
				'Omega' => $omega,
				'AncesteralSeq' => $ancesteralSeq,
				'RegulatorySeqPart' => $regulatorySeqPart
	};
	
	if($lastCNS eq "") {
		$lastCNS = $CNSID;
	} else {
		### If this CNS overlap with last, merge them or pick one gene to associate it with
		###
		my $CNSToDelete= "";
		if($CNSTable{$lastCNS}{'ReferenceGenome'} eq $referenceGenome && 
			$CNSTable{$lastCNS}{'Chromosome'} eq $chromosome &&
			overlap($CNSTable{$lastCNS}{'Start'},$CNSTable{$lastCNS}{'End'}, $start, $end)) {

				### If the genes are same orientation and the CNS is in the same part of the regulatory sequence (Up/downstream)
				###  then associate with the closest gene.
				if($verbose) { print "Found overlapping CNS: $lastCNS and $CNSID.\n"; }
				
				if( ($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) &&
					($CNSTable{$lastCNS}{'Strand'} eq $strand) &&
					($regulatorySeqPart eq "Upstream")) {
						if($relEnd > $CNSTable{$lastCNS}{'RelEnd'}) {  ### If the current CNS is closer, delete the lastone
							$CNSToDelete = $lastCNS;
						} else {   ## else, delete the current one
							$CNSToDelete = $CNSID;
						}
						$CNSDeleted++;
				} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) &&
						($CNSTable{$lastCNS}{'Strand'} ne $strand) &&
						($regulatorySeqPart eq "Downstream")) {
							
						if($relStart < $CNSTable{$lastCNS}{'RelStart'}) { ## If the current CNS is closer, delete the last one
							$CNSToDelete = $lastCNS;
						} else {
							$CNSToDelete = $CNSID;
						}
						$CNSDeleted++;
				} elsif( $CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Merged" ) {   #### If CNS hits a CNS that was already merged, just delete it
					if($verbose) { print "$CNSID overlaps with $lastCNS, but $lastCNS was already merged. Deleting...\n"}
					$CNSToDelete = $CNSID;
				} else { ### If orientation is different then merge into one CNS.
	
					if($verbose) { print "PROGRESS: Merging family CNS $lastCNS and $CNSID...(" . $CNSTable{$lastCNS}{'RegulatorySeqPart'} . ":" . $CNSTable{$CNSID}{'RegulatorySeqPart'} .")\n"; }
					my $diffInCNSPos = $start-$CNSTable{$lastCNS}{'Start'};
					## Merge coordinates
					$CNSTable{$lastCNS}{'End'} = max($CNSTable{$lastCNS}{'End'}, $end);
					if($end >0) {
						$CNSTable{$lastCNS}{'relEnd'} = max($CNSTable{$lastCNS}{'relEnd'}, $end);
					} else {
						$CNSTable{$lastCNS}{'relEnd'} = min($CNSTable{$lastCNS}{'relEnd'}, $end);
					}
					## Update all the positions
					my @CNSMappings = @{ $positionTable{$CNSID}{'Positions'} };

					foreach my $mapping (@CNSMappings) {
						my @lastCNSMappings = @{ $positionTable{$lastCNS}{'Positions'} };
						$mapping->{'PosInCNS'} = $mapping->{'PosInCNS'} + $diffInCNSPos;
						my %newmapping = %$mapping;
						push( @{ $positionTable{$lastCNS}{'Positions'} } , \%newmapping);
						if($verbose) { print "Updating $CNSID to $lastCNS: " . $newmapping{'TargetGenome'} . "," . $newmapping{'TargetLocus'} . "\n"; }
					}
					### Merge level
					if($CNSTable{$CNSID}{'Level'} ne $CNSTable{$lastCNS}{'Level'}) {
						my $bestLevel = max($conservationLevelDic{ $CNSTable{$CNSID}{'Level'} }, $conservationLevelDic{ $CNSTable{$lastCNS}{'Level'} });
						my @levels = keys %conservationLevelDic;

						if($verbose) { print "Merging levels: (" . $conservationLevelDic{ $CNSTable{$CNSID}{'Level'} } . "," . $conservationLevelDic{ $CNSTable{$lastCNS}{'Level'} } . "): $bestLevel (" . $levels[$bestLevel-1] . ").\n"; }
						$CNSTable{$lastCNS}{'Level'} = $levels[$bestLevel-1];
					}
					### Merge CNS rel position
					$CNSTable{$lastCNS}{'RegulatorySeqPart'}="Merged";

					### Merge Hits
					$CNSTable{$lastCNS}{'SupportingSpecies'} = max($CNSTable{$lastCNS}{'SupportingSpecies'}, $supportingSpecies);
					### Merge sequence (Future)
					if($diffInCNSPos != 0) {
	#					print "Merge sequence:\n";
	#					my $lastCNSSeq = Bio::Seq->new(-seq => $CNSTable{$lastCNS}{'AncesteralSeq'});
	#					my $curCNSSeq = Bio::Seq->new(-seq => $CNSTable{$CNSID}{'AncesteralSeq'});
	#					my $curCNSSeqRev = $curCNSSeq->revcom;
	#					my $overlapLast = substr($lastCNSSeq->seq, $diffInCNSPos-2);
	#					my $overlapCur = substr($lastCNSSeq->seq, 0);
	#					my $overlapCurRev = substr($curCNSSeqRev->seq, 0);
	#					my $mergedSeq = substr($lastCNSSeq,0, $diffInCNSPos) . $curCNSSeq;
		#				print "----\n$overlapLast\n$overlapCur\n$overlapCurRev\n";
		#				print "Diff: $diffInCNSPos  Merge:" . length($mergedSeq) . " --- of len:" . ($CNSTable{$lastCNS}{'End'} - $CNSTable{$lastCNS}{'Start'}) . "\n"; 
					}
					
					
		#			# and remove the old CNS
					$CNSToDelete = $CNSID;
					$CNSMerged++;
			}
		} else {
			$lastCNS = $CNSID;
		}

		if($CNSToDelete ne "") {
				if($verbose) { print "PROGRESS: Deleting $CNSToDelete.\n"; }
				delete $positionTable{$CNSToDelete};
				delete $CNSTable{$CNSToDelete};
				if($CNSToDelete eq $lastCNS) { $lastCNS=$CNSID; }
		}
	}
}

close($CNSInputFile);


###### Now go to the deeper merge - merge across different references
if($verbose) { print "PROGRESS: Begin merging deep CNS.\n" };

### First, build a map of hits indexed by gene
my %positionLocusMap;

foreach my $curCNS (keys %positionTable) {
	foreach my $curHit (@{ $positionTable{$curCNS}{'Positions'} }) {
		if(!defined $positionLocusMap{ $curHit->{'TargetLocus'} }) {
			$positionLocusMap{ $curHit->{'TargetLocus'} } = {
					'Positions' => () };
		 }
		 push( @{ $positionLocusMap{ $curHit->{'TargetLocus'} }{'Positions'} } , {
				'TargetGenome' => $curHit->{'TargetGenome'},
				'TargetLocus' => $curHit->{'TargetLocus'},
				'CNSID' => $curCNS,
				'TargetPosition' => $curHit->{'TargetPosition'} ,
				'ReferenceRelativePos' => $curHit->{'ReferenceRelativePos'},
				'Length' => $curHit->{'Length'} } );			
		}	
}


### Now Identify CNS to merge
my %CNSToMerge;
my %CNSToMergeHitMap;

### Scan all the hits to the locus. See if an alignment is hitting Two CNSs. If so, merge them.

foreach my $curLocus (keys %positionLocusMap) {

	my $curPos=0;
	
	foreach my $firstHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
		foreach my $secondHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
			# && ($firstHit->{'TargetGenome'} eq $secondHit->{'TargetGenome'})
			if(($firstHit->{'CNSID'} ne $secondHit->{'CNSID'}) && ($CNSTable{ $firstHit->{'CNSID'} } {'ReferenceGenome'} ne $CNSTable{ $secondHit->{'CNSID'} }{'ReferenceGenome'}) ) {
				if(overlap($firstHit->{'TargetPosition'}, $firstHit->{'TargetPosition'}+$firstHit->{'Length'}, $secondHit->{'TargetPosition'}, $secondHit->{'TargetPosition'}+$secondHit->{'Length'}) >0.25 ) {
					### We should merge the CNS
					my $first;
					my $second;

					if(defined $CNSToMerge{ $firstHit->{'CNSID'} }) {
						$first = $firstHit->{'CNSID'};
						$second = $secondHit->{'CNSID'};
					} else {
						$first = $secondHit->{'CNSID'};
						$second = $firstHit->{'CNSID'};
					}

					if(!defined $CNSToMerge{ $first }{ $second }  ) { 
						$CNSToMerge{ $first } { $second }=1;
					} else {
						### make sure we keep the CNS association unidirectional and unique

						$CNSToMerge{ $first }{ $second }++;
				
						if($CNSToMerge{ $first }{ $second } == $minOverlappingSpeciesForMerge) {
#							if($verbose) { print "PROGRESS: Merge deep CNS $first and $second because of $curLocus of (" . $firstHit->{'TargetGenome'} . ").\n"; }
							$CNSMerged++;
							$deepCNSMerged++;
						}
					}
				}
			}
		}
	}
}

if($verbose) { print "PROGRESS: Found " . $deepCNSMerged . " CNS to merge.\n"; }
### Now merge merged CNS
if($verbose) { print "PROGRESS: Collating merged CNSs\n";}
my $CNSMergedInCurrentPass;
my $superGroupMerged=0;
do {
	$CNSMergedInCurrentPass=0;
	foreach my $curCNS (keys %CNSToMerge) {
		foreach my $CNSToScan (keys %CNSToMerge) {
			if($curCNS ne $CNSToScan) {
				for my $curSuperCNSMember (keys %{ $CNSToMerge{$CNSToScan} } )  {
#					if ($curSuperCNSMember eq $curCNS && $CNSToMerge{CNSToScan}{$curSuperCNSMember}> $minOverlappingSpeciesForMerge) {  ### If there is an overlap, merge the CNSs
					if ($curSuperCNSMember eq $curCNS) {  ### If there is an overlap, merge the CNSs
						if($verbose) { print "PROGRESS: Merging $curCNS and $CNSToScan.\n"; }

						$CNSToMerge{$curCNS}{$CNSToScan} = 1;
						# now copy superCNS members
						foreach my $curSuperCNSMemberToCopy (keys %{ $CNSToMerge{$CNSToScan} }) {
							if($curCNS ne $curSuperCNSMemberToCopy) {
								$CNSToMerge{$curCNS}{$curSuperCNSMemberToCopy} = $CNSToMerge{$curCNS}{$curSuperCNSMemberToCopy} + $CNSToMerge{$CNSToScan}{$curSuperCNSMember} + $minOverlappingSpeciesForMerge;
							}
						}
						#and delete
						delete $CNSToMerge{$CNSToScan};
						$CNSMergedInCurrentPass++;
						$superGroupMerged++;
					}
				}
			}
		}
	}
} while($CNSMergedInCurrentPass >0);

if($verbose) { print "PROGRESS: Forming deep CNS groups.\n"; }

my %CNSGroups;

foreach my $curCNS (keys %CNSToMerge) {
	# filter low support alignments
	foreach my $cnsB (keys %{ $CNSToMerge{$curCNS } }) {
		if($CNSToMerge{$curCNS}{$cnsB}< $minOverlappingSpeciesForMerge) {
			delete $CNSToMerge{$curCNS}{$cnsB};
		}
	}

	my @otherCNSs = keys %{ $CNSToMerge{$curCNS} };

	if( @otherCNSs >0) {
		my $CNSGroupName = "$superCNSPrefix.$curCNS";

		$CNSTable{$CNSGroupName} = {
				'ReferenceGenome' => "SuperCNS",
				'CNSID' => $CNSGroupName,
				'Chromosome' => "",
				'Strand' => "",
				'Start' => "",	
				'End' => "",
				'Locus' => "",
				'RelStart' => "",
				'RelEnd' => "",
				'Level' => $CNSTable{$curCNS}{'Level'},
				'SupportingSpecies' => 0,
				'ORFLength' => "",
				'ORFDir' => "",
				'Omega' => "",
				'AncesteralSeq' => "",
				'RegulatorySeqPart' => ""};
		my @CNSsToJoin = ($curCNS, keys %{ $CNSToMerge{$curCNS} });
	
		$CNSGroups{$CNSGroupName} = \@CNSsToJoin;

		$positionTable{$CNSGroupName}{'Positions'} = ();

		my $remappedPositions=0;

		foreach my $curCNSToJoin ( @CNSsToJoin ) {
			foreach my $mapping ( @{ $positionTable{$curCNS}{'Positions'} }  ) {
			
				### Check to see if it is not there yet
				my $needToRemap=1;
				foreach my $curMapPos ( @{ $positionTable{$CNSGroupName}{'Positions'} }) {
					if($curMapPos->{'TargetLocus'} eq $mapping->{'TargetLocus'} &&
				   	   $curMapPos->{'TargetPosition'} eq $mapping->{'TargetPosition'}) {
						$needToRemap=0;
					}
				}

				if($needToRemap) {
					push ( @{ $positionTable{$CNSGroupName}{'Positions'} } , 	{
						'TargetGenome' => $mapping->{'TargetGenome'},
						'TargetLocus' => $mapping->{'TargetLocus'},
						'TargetPosition' => $mapping->{'TargetPosition'},
						'ReferenceRelativePos' => $mapping->{'ReferenceRelativePos'},
						'Length' => $mapping->{'Length'}
					});
					$remappedPositions++;
				}
			}
		}
		if($verbose) { print "PROGRESS: Created $CNSGroupName ($remappedPositions):" . join(",", @CNSsToJoin) . "\n"; }
	}
}

if($removeOriginalCNS) {
	foreach my $curCNS (keys %CNSToMerge) {
		foreach my $targetCNS (keys %{ $CNSToMerge{$curCNS} }) {
			if(!($targetCNS =~ /^$superCNSPrefix/)) { delete $CNSTable{$targetCNS}; }
		}
		if(!($curCNS =~ /^$superCNSPrefix/)) { delete $CNSTable{$curCNS}; }
	}
						
}

if($verbose) { print "PROGRESS: Done. Output files.\n"; }

########### Output files
### New CNS files
open (my $outputCNSFile, ">$outputCNSFileName") || die ("INTERNAL ERROR.\n");
open (my $outputMapFile, ">$outputMapFileName") || die ("INTERNAL ERROR.\n");

foreach my $curCNS (sort keys %CNSTable) {
	print $outputCNSFile join(",",
				$CNSTable{$curCNS}{'ReferenceGenome'},
				$CNSTable{$curCNS}{'CNSID'},
				$CNSTable{$curCNS}{'Chromosome'},
				$CNSTable{$curCNS}{'Strand'},
				$CNSTable{$curCNS}{'Start'},	
				$CNSTable{$curCNS}{'End'},
				$CNSTable{$curCNS}{'Locus'},
				$CNSTable{$curCNS}{'RelStart'},
				$CNSTable{$curCNS}{'RelEnd'},
				$CNSTable{$curCNS}{'Level'},
				$CNSTable{$curCNS}{'SupportingSpecies'},
				$CNSTable{$curCNS}{'ORFLength'},
				$CNSTable{$curCNS}{'ORFDir'},
				$CNSTable{$curCNS}{'Omega'},
				$CNSTable{$curCNS}{'AncesteralSeq'}) ."\n";
	
	foreach my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
		print $outputMapFile join(",",
				$curCNS,
				$mapping->{'TargetGenome'},
				$mapping->{'TargetLocus'},
				$mapping->{'TargetPosition'},
				$mapping->{'ReferenceRelativePos'},
				$mapping->{'Length'}) ."\n";		
	}
}

close($outputCNSFile);

close($outputMapFile);

##########
if($outputMergedCNSFileName ne "") {
	open (my $outputMergedCNSFile, ">$outputMergedCNSFileName") || die ("INTERNAL ERROR.\n");
	foreach my $groupCNS (sort keys %CNSGroups) {
		foreach my $subCNS (@{ $CNSGroups{$groupCNS} } ) {
			print $outputMergedCNSFile "$groupCNS,$subCNS\n";
		}
	}
	close ($outputMergedCNSFile);
}

print "END: Deleted $CNSDeleted duplicated CNSs; Merged $CNSMerged CNSs, of which $deepCNSMerged deep CNSs. Assembled $superGroupMerged CNS groups.\n";



#############################################################################3
### Compute overlap between two fragments. 
### Parameters:
### overlap(startOne, endOne, StartTwo, endTwo, mode)
### mode can be "ABS", in which case returns the absolute overlap in bp
### else, returns relative overlap (0-1).
###

sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo, $mode) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		#### return the percent overlap
		if($endOne < $endTwo) {
			if($startOne >= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endOne -$startTwo);
				} else {
					return ($endOne -$startTwo) /($endOne - $startOne);
				}
			} 
		} else {
			if($startOne <= $startTwo) {
				if($mode eq "ABS") {
					return ($endOne-$startOne);					
				} else {
					return 1;
				}
			} else {
				if($mode eq "ABS") {
					return ($endTwo -$startOne);
				} else {
					return ($endTwo -$startOne) /($endOne - $startOne);
				}
			} 			
		}
	}
}
