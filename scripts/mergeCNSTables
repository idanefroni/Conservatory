#!/usr/bin/perl

use POSIX;
use strict;
use Array::Utils qw(:all);
use Cwd 'abs_path';
use List::Util qw(min max);
use Bio::AlignIO;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;
use Getopt::Long;
$|=1;


### Filenames
my $conservatoryDir=abs_path(".");
my $CNSFileName="";
my $mapFileName="";
my $outputCNSFileName="";
my $outputMapFileName="";
my $outputMergedCNSFileName="";


### Merging parameters
my $superCNSPrefix = "Super";
my $minOverlappingSpeciesForMerge=5; ### How many overlapping hits to merge a CNS
my $minCNSOverlap = 0.5;
my $minSyntenyBiasToAssignCNS= 1.2; ### Number between 1 and 2 (how many more species need to support a two-gene CNS assignment to just one of the genes, based on synteny)
my $removeOriginalCNS=0;

## Filtering parameters
my $CLASSIFICATION_CLASSES_NUM=6;
my @minSpeciesRelativeNumPerConservationLevel= (0.6,0.6,0.5,0.5,0.3,0.3); ## Must have atleast these many alignments to support level assignment, following merger. This is stricter than gene-specific filters
my @classificationCutoffs;

my %CNSTable;
my %positionTable;
my %genomeToSpecies;
my %genomeToFamily;
my %speciesToFamily;
my %speciesClassification;

my $CNSMerged=0;
my $CNSMergedExtended=0;
my $CNSDeleted=0;
my $deepCNSMerged=0;

my $verbose=0;
my $help=0;

GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"in-cns=s" => \$CNSFileName,
			"in-map=s" => \$mapFileName,
			"out-cns=s" => \$outputCNSFileName,
			"out-map=s" => \$outputMapFileName,
			"out-merged=s" => \$outputMergedCNSFileName,
			"verbose" => \$verbose,
			"min-overlapping" => \$minOverlappingSpeciesForMerge,
			"remove-original-CNS" => \$removeOriginalCNS,
			"help" => \$help) or die ("Error in command line arguments\n");
			
			
if($help || $CNSFileName eq "" || $mapFileName eq "" || $outputCNSFileName eq "" || $outputMapFileName eq "" ) {
	print "Conservatory version 2.0.1\n\n";
	print "mergeCNSTables --in-cns <cnsFile> --in-map <cnsPositionMapFile> --out-cns <cnsFile> --out-map <cnsPositionMapFile>  [--out-merged <mergedDeepCNSfile>] [--min-overlapping <number>] [--remove-original-CNS].\n\n";
	
#	print "\t\tmerged.cns.table.csv\t\tMerged CNS file\n\t\tmerged.cns.position.table.csv\t\tMerged position file\n";
	exit();
}

if ($verbose) { print "START: Loading genome database.\n"; }
my $genomedbFile = $conservatoryDir . "/genome_database.csv";
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;

open (my $genomeDatabase, "<", $genomedbFile);
while((my $curgenomeline = <$genomeDatabase>)) {
	chomp($curgenomeline);
	if(substr($curgenomeline,0,1) ne "#")  {
		my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx, $classification) = split /,/, $curgenomeline;
		$genomeToSpecies{$curgenomeName}=  $curgenomeSpecies;
		$genomeToFamily{$curgenomeName} = $curgenomeFamily;
		$speciesToFamily{$curgenomeSpecies} = $curgenomeFamily;
		$speciesClassification{$curgenomeSpecies} = $classification;
	}
}

### Calculate classification level filters

for my $curSpecies (keys %speciesClassification) {
	my @spClassifications = split /-/,$speciesClassification{$curSpecies};
	for my $curLevel (0..($CLASSIFICATION_CLASSES_NUM-1) ) {
		$classificationCutoffs[$curLevel]{$spClassifications[$curLevel]}++;
	}
}
for my $curLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {
	for my $curClassification (keys %{ $classificationCutoffs[$curLevel]}) {
		$classificationCutoffs[$curLevel]{$curClassification} = $classificationCutoffs[$curLevel]{$curClassification} * $minSpeciesRelativeNumPerConservationLevel[$curLevel];
	}
}


if ($verbose) { print "END: Loading genome database.\n"; }

if ($verbose) { print "START: Merging CNSs.\n"; }


my $curPos=1;

########## Load position table to memory
open (my $CNSPositionFile, $mapFileName) ||  die "ERROR: Cannot find position file $mapFileName.\n";
while(<$CNSPositionFile>) {
	if($verbose) { print "PROGRESS: Loading mappings..." . $curPos++ . "\r" };

	chomp;
	my ($CNSID, $targetSpecies, $targetLocus, $targetRelativePosition, $referenceRelativePosition, $length, $targetSequence) = split /,/;
	
	### Filter for only embryophyta hits
	my @classification = split /-/, $speciesClassification{ $genomeToSpecies{$targetSpecies} }; 
	if($classification[0] eq "Embryophyta") {
		## Only if non-filtered CNS
		if(!defined $positionTable{$CNSID}) {
			$positionTable{$CNSID} = {
						'CNSID' => $CNSID,
						'Positions' => () };
		}

		push( @{ $positionTable{$CNSID}{'Positions'} } , {
					'TargetSpecies' => $targetSpecies,
					'TargetLocus' => $targetLocus,
					'TargetPosition' => $targetRelativePosition,
					'ReferenceRelativePos' => $referenceRelativePosition,
					'Length' => $length,
					'TargetSequence' => $targetSequence} );			
	}
}
close($CNSPositionFile);
if($verbose) { print "\n"; };


### Now start merging CNSs. First read and merge all CNSs in the family
if($verbose) { print "PROGRESS: Begin merge family CNS.\n" };

open (my $CNSInputFile,"sort -t',' -k1,1 -k3,3 -k5,5n $CNSFileName |") ||  die "ERROR: Cannot find CNS file $CNSFileName.\n";

my $lastCNS ="";
my %CNSTable;
while(<$CNSInputFile>) {
	chomp;
	my ($referenceGenome, $CNSID, $chromosome, $strand, $start, $end, $locus, $relStart, $relEnd, $level, $supportingSpecies, $orfLength, $orfDir, $omega, $ancesteralSeq) = split /,/;
	my $regulatorySeqPart;
	if($relStart<0) {
		$regulatorySeqPart = "Upstream";
	} else {
		$regulatorySeqPart = "Downstream";
	}
	$CNSTable{$CNSID} = {
				'ReferenceGenome' => $referenceGenome,
				'CNSID' => $CNSID,
				'Chromosome' => $chromosome,
				'Strand' => $strand,
				'Start' => $start,	
				'End' => $end,
				'Locus' => $locus,
				'RelStart' => $relStart,
				'RelEnd' => $relEnd,
				'Level' => $level,
				'SupportingSpecies' => $supportingSpecies,
				'ORFLength' => $orfLength,
				'ORFDir' => $orfDir,
				'Omega' => $omega,
				'AncesteralSeq' => $ancesteralSeq,
				'RegulatorySeqPart' => $regulatorySeqPart
	};
	
	if($lastCNS eq "") {
		$lastCNS = $CNSID;
	} else {
		### If this CNS overlap with last, pick one gene to associate it with (or merge)
		###
		my $CNSToDelete= "";
		if($CNSTable{$lastCNS}{'ReferenceGenome'} eq $referenceGenome && 
			$CNSTable{$lastCNS}{'Chromosome'} eq $chromosome &&
			overlap($CNSTable{$lastCNS}{'Start'},$CNSTable{$lastCNS}{'End'}, $start, $end)) {

				#if($verbose) { print "Found overlapping CNS: $lastCNS and $CNSID.\n"; }

				## Prefer the CNS with the most conserved synteny (largest number of supporting species for CNS-Gene synteny)
				if($CNSTable{$lastCNS}{'SupportingSpecies'} > $CNSTable{$CNSID}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $CNSID;
					$CNSDeleted++;
				} elsif($CNSTable{$CNSID}{'SupportingSpecies'} > $CNSTable{$lastCNS}{'SupportingSpecies'} * $minSyntenyBiasToAssignCNS) {
					$CNSToDelete = $lastCNS;
					$CNSDeleted++;
				} else {   ### If both CNSs have the same number of supporting species, we have to decide:
						### If the genes are same orientation and the CNS is in the same part of the regulatory sequence (Up/downstream)
						###  then associate with the closest gene.
						if( ($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Upstream") &&
							($CNSTable{$lastCNS}{'Strand'} eq $strand)) {    #### If both upstream. delete the one further away
							if($relEnd > $CNSTable{$lastCNS}{'RelEnd'}) {
								$CNSToDelete = $lastCNS;
							}
							else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq $regulatorySeqPart) && ($regulatorySeqPart eq "Downstream") &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {  ### If both downstream, delete the one further away
							if($relStart < $CNSTable{$lastCNS}{'RelStart'}) {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif(($CNSTable{$lastCNS}{'RegulatorySeqPart'} ne $regulatorySeqPart)  &&
							($CNSTable{$lastCNS}{'Strand'} ne $strand)) {   ### If one is upsteam, one downstream on opposite strands, delete the downstream (we assume upstream more likely)
							if($CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Downstream") {
								$CNSToDelete = $lastCNS;
							} else {
								$CNSToDelete = $CNSID;
							}
							$CNSDeleted++;
					} elsif( $CNSTable{$lastCNS}{'RegulatorySeqPart'} eq "Merged" ) {   #### If CNS hits a CNS that was already merged, just delete it
						if($verbose) { print "$CNSID overlaps with $lastCNS, but $lastCNS was already merged. Deleting...\n"}
						$CNSToDelete = $CNSID;
						$CNSDeleted++;
					} else { ### If orientation is different then merge into one CNS.
#						if($verbose) { print "PROGRESS: Merging family CNS $lastCNS and $CNSID...(" . $CNSTable{$lastCNS}{'RegulatorySeqPart'} . ":" . $CNSTable{$CNSID}{'RegulatorySeqPart'} .")\n"; }
						my $diffInCNSPos = $start-$CNSTable{$lastCNS}{'Start'};

						### Pick the longest one
						my $longestSeq;
						if( ($CNSTable{$CNSID}{'End'} - $CNSTable{$CNSID}{'Start'}) > ($CNSTable{$lastCNS}{'End'} - $CNSTable{$lastCNS}{'Start'}) ) {
							$longestSeq = $CNSTable{$CNSID}{'AncesteralSeq'};
						} else {
							$longestSeq = $CNSTable{$lastCNS}{'AncesteralSeq'};
						}
						## Update all the positions
						my @CNSMappings = @{ $positionTable{$CNSID}{'Positions'} };

						foreach my $mapping (@CNSMappings) {
							my @lastCNSMappings = @{ $positionTable{$lastCNS}{'Positions'} };
							$mapping->{'PosInCNS'} = $mapping->{'PosInCNS'} + $diffInCNSPos;
							my %newmapping = %$mapping;
							push( @{ $positionTable{$lastCNS}{'Positions'} } , \%newmapping);
#							if($verbose) { print "Updating $CNSID to $lastCNS: " . $newmapping{'TargetSpecies'} . "," . $newmapping{'TargetLocus'} . "\n"; }
						}

						### Merge CNS rel position
						$CNSTable{$lastCNS}{'RegulatorySeqPart'}="Merged";
						$CNSTable{$lastCNS}{'AncesteralSeq'} = $longestSeq;

						# and remove the old CNS
						$CNSToDelete = $CNSID;
						$CNSMerged++;
				}
			}
		} else {
			$lastCNS = $CNSID;
		}

		if($CNSToDelete ne "") {
#			if($verbose) { print "PROGRESS: Deleting $CNSToDelete.\n"; }
			delete $positionTable{$CNSToDelete};
			delete $CNSTable{$CNSToDelete};
			if($CNSToDelete eq $lastCNS) { $lastCNS=$CNSID; }
		}
	}
}

close($CNSInputFile);


###### Now go to the deeper merge - merge across different references
if($verbose) { print "PROGRESS: Begin merging deep CNS.\n" };


### First, build a map of hits indexed by gene


my %positionLocusMap;
my $totalToScreen = scalar (keys %positionTable);
$curPos=1;

foreach my $curCNS (keys %positionTable) {
	if($verbose) { print "PROGRESS: Building CNS Map..." . $curPos++. "/$totalToScreen\r"; };

	foreach my $curHit (@{ $positionTable{$curCNS}{'Positions'} }) {
		if(!defined $positionLocusMap{ $curHit->{'TargetLocus'} }) {
			$positionLocusMap{ $curHit->{'TargetLocus'} } = {
					'Positions' => () };
		 }
		 push( @{ $positionLocusMap{ $curHit->{'TargetLocus'} }{'Positions'} } , {
				'TargetSpecies' => $curHit->{'TargetSpecies'},
				'TargetLocus' => $curHit->{'TargetLocus'},
				'CNSID' => $curCNS,
				'TargetPosition' => $curHit->{'TargetPosition'} ,
				'ReferenceRelativePos' => $curHit->{'ReferenceRelativePos'},
				'Length' => $curHit->{'Length'},
				'TargetSequence' => $curHit->{'TargetSequence'} } );			
		}	
}

if($verbose) { print "\n\t\t...Done.\n" };
### Now Identify CNS to merge
my %CNSToMerge;
my %CNSToMergeHitMap;

### Scan all the hits to the locus. See if an alignment is hitting Two CNSs. If so, merge them.
$totalToScreen = scalar (keys %positionLocusMap);
$curPos=1;

foreach my $curLocus (keys %positionLocusMap) {
	#if($verbose) { print "PROGRESS: Testing deep CNS for $curLocus.\n"; }
	
	if($verbose) { print "PROGRESS: Identifying deep CNS to merge..." . ($curPos++) . "/$totalToScreen. Found $deepCNSMerged.\r"; }
	
	foreach my $firstHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
		foreach my $secondHit ( @{ $positionLocusMap{$curLocus}{'Positions'} } ) {
			if(($firstHit->{'CNSID'} ne $secondHit->{'CNSID'}) && ($CNSTable{ $firstHit->{'CNSID'} } {'ReferenceGenome'} ne $CNSTable{ $secondHit->{'CNSID'} }{'ReferenceGenome'}) && ($CNSTable{ $firstHit->{'CNSID'} } {'RegulatorySeqPart'} eq $CNSTable{ $secondHit->{'CNSID'} }{'RegulatorySeqPart'}) ) {
				if(overlap($firstHit->{'TargetPosition'}, $firstHit->{'TargetPosition'}+$firstHit->{'Length'}, $secondHit->{'TargetPosition'}, $secondHit->{'TargetPosition'}+$secondHit->{'Length'}) > $minCNSOverlap ) {
					### We should merge the CNS
					my $first;
					my $second;

					if(defined $CNSToMerge{ $firstHit->{'CNSID'} }) {
						$first = $firstHit->{'CNSID'};
						$second = $secondHit->{'CNSID'};
					} else {
						$first = $secondHit->{'CNSID'};
						$second = $firstHit->{'CNSID'};
					}

					$CNSToMerge{ $first }{ $second }++;
				
					if($CNSToMerge{ $first }{ $second } == $minOverlappingSpeciesForMerge) {
#						if($verbose) { print "PROGRESS: Merge deep CNS $first and $second because of $curLocus of (" . $firstHit->{'TargetSpecies'} . ").\n"; }
						$CNSMerged++;
						$deepCNSMerged++;
					}
				}
			}
		}
	}
}

if($verbose) {print "\n\t\t...Done.\n";}
### Now merge merged CNS
if($verbose) { print "PROGRESS: Collating merged CNSs.\n";}
my $CNSMergedInCurrentPass;
my $superGroupMerged=0;
my %CNSToCollate;
my $curPass=0;
do {
	$CNSMergedInCurrentPass=0;
	%CNSToCollate=();
	foreach my $curCNS (keys %CNSToMerge) {
		my @curCNScontent = keys %{ $CNSToMerge{$curCNS} };
		push @curCNScontent, $curCNS;
		foreach my $CNSToScan (keys %CNSToMerge) {
			if($curCNS ne $CNSToScan) {
				my @CNSToScanContent = keys %{ $CNSToMerge{$CNSToScan} };
				push (@CNSToScanContent, $CNSToScan);
				my @CNSintersect = intersect(@curCNScontent, @CNSToScanContent);

				if ((scalar @CNSintersect) > 0 ) {  #### If we have a shared CNS between the two
					if(!defined $CNSToCollate{$CNSToScan}) {
						$CNSToCollate{$curCNS} = $CNSToScan;
					} 
					$CNSMergedInCurrentPass++;
				}
			}
		}
	}
	if($CNSMergedInCurrentPass>0) {  ### Do the merging
		foreach my $curCNSToCollate (keys %CNSToCollate) {
			foreach my $curCNSMemberToCopy (keys %{ $CNSToMerge{ $CNSToCollate{$curCNSToCollate} } }) {
				$CNSToMerge{$curCNSToCollate}{ $curCNSMemberToCopy } = $minOverlappingSpeciesForMerge;
			}
			$CNSToMerge{$curCNSToCollate}{ $CNSToCollate{$curCNSToCollate} } = $minOverlappingSpeciesForMerge;

			delete $CNSToMerge{ $CNSToCollate{$curCNSToCollate} };
		}
	}
	if($verbose) { print "PROGRESS: Collating pass ". $curPass++ . ". Merged $CNSMergedInCurrentPass CNS groups \n"; }
} while($CNSMergedInCurrentPass >0);

$totalToScreen = scalar (keys %CNSToMerge);
$curPos=1;
my %CNSGroups;

foreach my $curCNS (keys %CNSToMerge) {
	if($verbose) { print "PROGRESS: Forming deep CNS groups...". $curPos++ . "/$totalToScreen\r"; }
	# filter low support alignments
	foreach my $cnsB (keys %{ $CNSToMerge{$curCNS } }) {
		if($CNSToMerge{$curCNS}{$cnsB}< $minOverlappingSpeciesForMerge) {
			delete $CNSToMerge{$curCNS}{$cnsB};
		}
	}

	my @otherCNSs = keys %{ $CNSToMerge{$curCNS} };

	if( @otherCNSs >0) {
		my $CNSGroupName = "$superCNSPrefix.$curCNS";

		$CNSTable{$CNSGroupName} = {
				'ReferenceGenome' => "SuperCNS",
				'CNSID' => $CNSGroupName,
				'Chromosome' => "",
				'Strand' => "",
				'Start' => "",	
				'End' => "",
				'Locus' => "",
				'RelStart' => "",
				'RelEnd' => "",
				'Level' => $CNSTable{$curCNS}{'Level'},
				'SupportingSpecies' => 0,
				'ORFLength' => "",
				'ORFDir' => "",
				'Omega' => "",
				'AncesteralSeq' => "",
				'RegulatorySeqPart' => ""};
		my @CNSsToJoin = ($curCNS, keys %{ $CNSToMerge{$curCNS} });
	
		$CNSGroups{$CNSGroupName} = \@CNSsToJoin;

		$positionTable{$CNSGroupName}{'Positions'} = ();

		my $remappedPositions=0;

		foreach my $curCNSToJoin ( @CNSsToJoin ) {
			foreach my $mapping ( @{ $positionTable{$curCNSToJoin}{'Positions'} }  ) {
			
				### Check to see if it is not there yet
				my $needToRemap=1;
				foreach my $curMapPos ( @{ $positionTable{$CNSGroupName}{'Positions'} }) {
					if($curMapPos->{'TargetLocus'} eq $mapping->{'TargetLocus'} &&
				   	   $curMapPos->{'TargetPosition'} eq $mapping->{'TargetPosition'}) {
						$needToRemap=0;
					}
				}

				if($needToRemap) {
					push ( @{ $positionTable{$CNSGroupName}{'Positions'} } , 	{
						'TargetSpecies' => $mapping->{'TargetSpecies'},
						'TargetLocus' => $mapping->{'TargetLocus'},
						'TargetPosition' => $mapping->{'TargetPosition'},
						'ReferenceRelativePos' => $mapping->{'ReferenceRelativePos'},
						'Length' => $mapping->{'Length'},
						'TargetSequence' => $mapping->{'TargetSequence'}
					});
					$remappedPositions++;
				}
			}
		}
		if($verbose) { print "PROGRESS: Created $CNSGroupName ($remappedPositions):" . join(",", @CNSsToJoin) . "\n"; }
	}
}

if($removeOriginalCNS) {
	foreach my $curCNS (keys %CNSToMerge) {
		foreach my $targetCNS (keys %{ $CNSToMerge{$curCNS} }) {
			if(!($targetCNS =~ /^$superCNSPrefix/)) { delete $CNSTable{$targetCNS}; }
		}
		if(!($curCNS =~ /^$superCNSPrefix/)) { delete $CNSTable{$curCNS}; }
	}
						
}
if($verbose) { print "...Done.\n";}


$totalToScreen = scalar (keys %CNSTable);
$curPos=1;
foreach my $curCNS (keys %CNSTable) {
	## Count supporting species
	if($verbose) { print "PROGRESS: Remapping and filtering..." . $curPos++ . "/$totalToScreen\r"; }

	my %speciesForCNS;
	for my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
		$speciesForCNS{ $mapping->{'TargetSpecies'} } =1;
	}
	my @speciesForCNSArray = keys %speciesForCNS;
	$CNSTable{$curCNS}{'SupportingSpecies'} = scalar @speciesForCNSArray;

	my @CNSConservationLevels;

	for my $curSpecies (@speciesForCNSArray) {
  	  my @classification = split '-' , $speciesClassification{$curSpecies};
    	for my $curClassificationLevel (0..($CLASSIFICATION_CLASSES_NUM-1)) {
			$CNSConservationLevels[$curClassificationLevel]{$classification[$curClassificationLevel]}++;
    	}
   }

   my $CNSConservationLevel;
   #determine for each conservation level if we are over the cut off.
   for my $curLevel (0..($CLASSIFICATION_CLASSES_NUM-2)) {
		my %classificationForLevel = %{ $CNSConservationLevels[$curLevel] };
		my %classificationForDeeperLevel = %{ $CNSConservationLevels[$curLevel+1] };
	
		if (scalar keys %classificationForDeeperLevel > 1 && scalar keys %classificationForLevel == 1 && $CNSConservationLevel eq "") { ### We have potential for classification. See if we have enough species
			my @classificationForLevelArray = keys %classificationForLevel;
			
			my $bestClassification = @classificationForLevelArray[0];
			if( $classificationForLevel{$bestClassification} >= $classificationCutoffs[$curLevel]{$bestClassification} ) {
				$CNSConservationLevel = $bestClassification;
			} else { ### We have unsupported mapping. removing the errorneous mappings
#				print "$curCNS:Unsupported $bestClassification  $classificationForLevel{$bestClassification} And we want $classificationCutoffs[$curLevel]{$bestClassification} \n";
				my @sortedClassificationClasses = reverse sort { $classificationForDeeperLevel{$a} <=> $classificationForDeeperLevel{$b} } keys %classificationForDeeperLevel;
				my $keepClassification = $sortedClassificationClasses[0];
				my @positions = @{ $positionTable{$curCNS}{'Positions'} };
				my @newPositions;
				for my $curPosition (@positions) {
					my @spClassifications = split /-/, $speciesClassification{ $curPosition->{'TargetSpecies'} };
					if($spClassifications[$curLevel+1] eq $keepClassification) {
						push @newPositions, $curPosition;
					}
				}
				$positionTable{$curCNS}{'Positions'} = \@newPositions;

				# remove the other classifications
				for my $curClassification (@sortedClassificationClasses) {
					if($curClassification ne $keepClassification) {
						delete $CNSConservationLevels[$curLevel+1]{$curClassification};
					}
				}
				## If this is the last level, just keep the family
				if($curLevel == $CLASSIFICATION_CLASSES_NUM -2 ) {
					$CNSConservationLevel = $keepClassification;

				}
			}
		} elsif($CNSConservationLevel eq "" && $curLevel == $CLASSIFICATION_CLASSES_NUM -2 ) {
			$CNSConservationLevel = (keys %classificationForDeeperLevel)[0];
		}
   }

  $CNSTable{$curCNS}{'Level'} = $CNSConservationLevel;
}

if($verbose) { print "\nPROGRESS: Done. Output files.\n"; }

########### Output files
### New CNS files
open (my $outputCNSFile, ">$outputCNSFileName") || die ("INTERNAL ERROR.\n");
open (my $outputMapFile, ">$outputMapFileName") || die ("INTERNAL ERROR.\n");

foreach my $curCNS (sort keys %CNSTable) {
	print $outputCNSFile join(",",
				$CNSTable{$curCNS}{'ReferenceGenome'},
				$CNSTable{$curCNS}{'CNSID'},
				$CNSTable{$curCNS}{'Chromosome'},
				$CNSTable{$curCNS}{'Strand'},
				$CNSTable{$curCNS}{'Start'},	
				$CNSTable{$curCNS}{'End'},
				$CNSTable{$curCNS}{'Locus'},
				$CNSTable{$curCNS}{'RelStart'},
				$CNSTable{$curCNS}{'RelEnd'},
				$CNSTable{$curCNS}{'Level'},
				$CNSTable{$curCNS}{'SupportingSpecies'},
				$CNSTable{$curCNS}{'ORFLength'},
				$CNSTable{$curCNS}{'ORFDir'},
				$CNSTable{$curCNS}{'Omega'},
				$CNSTable{$curCNS}{'AncesteralSeq'}) ."\n";
	
	foreach my $mapping (@{ $positionTable{$curCNS}{'Positions'} }) {
		print $outputMapFile join(",",
				$curCNS,
				$mapping->{'TargetSpecies'},
				$mapping->{'TargetLocus'},
				$mapping->{'TargetPosition'},
				$mapping->{'ReferenceRelativePos'},
				$mapping->{'Length'},
				$mapping->{'TargetSequence'}) ."\n";		
	}
}

close($outputCNSFile);

close($outputMapFile);

##########
if($outputMergedCNSFileName ne "") {
	open (my $outputMergedCNSFile, ">$outputMergedCNSFileName") || die ("INTERNAL ERROR.\n");
	foreach my $groupCNS (sort keys %CNSGroups) {
		foreach my $subCNS (@{ $CNSGroups{$groupCNS} } ) {
			print $outputMergedCNSFile "$groupCNS,$subCNS\n";
		}
	}
	close ($outputMergedCNSFile);
}

print "END: Deleted $CNSDeleted duplicated CNSs; Merged $CNSMerged CNSs, of $deepCNSMerged were deep CNSs. Assembled $superGroupMerged CNS groups.\n";



#############################################################################3
### Compute overlap between two fragments. 
### Parameters:
### overlap(startOne, endOne, StartTwo, endTwo, mode)
### returns relative overlap (0-1).
###

sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		return (min($endOne, $endTwo) - max($startOne, $startTwo))/ max( $endOne-$startOne, $endTwo-$startTwo);
	}
}
